{$A+,B-,D-,E+,F-,G-,I+,L-,N+,O-,P-,Q-,R-,S-,T-,V+,X+,Y-}

//---------------------------------
unit PT4OOP3Behav_ru;

{$MODE Delphi}

interface


procedure InitTask(num: integer); stdcall;
procedure inittaskgroup;


implementation


uses PT5TaskMaker, SysUtils;

//-----------------------------------

const
  TestHeader = '\P\SТестирование разработанной системы классов\s.'#13;
  Subgroup1 = 'Observer, Strategy, Template Method';
  Subgroup2 = 'Iterator, Command, State';
  Subgroup3 = 'Mediator, Chain of Responsibility, Visitor, Interpreter';


procedure Swap(var a: integer; var b: integer);
var x : integer;
begin
  x := a;
  a := b;
  b := x;
end;

procedure SwapC(var a: char; var b: char);
var x : char;
begin
  x := a;
  a := b;
  b := x;
end;

procedure Pat1;
var s, s1: string;
    i, n, k: integer;
    ind: array[1..20] of integer;
begin
  CreateTask(Subgroup1);
  TaskText(
'\G<Graph\OOPStrategy.png>\BStrategy\b (\BСтратегия\b)~\= паттерн поведения.'#13+
'\PИзвестен также под именем \BPolicy\b (\BПолитика\b).'#13+
'\P\SЧастота использования\s: выше средней.'#13+
'\P\SНазначение\s: определяет семейство алгоритмов, инкапсулирует каждый из них'#13+
'и делает их взаимозаменяемыми. Стратегия позволяет заменять алгоритмы'#13+
'для любого клиента (\<контекста\>) на этапе выполнения.'#13+
'\P\SУчастники\s: \P\X~\IStrategy\i (\IСтратегия\i)~\= объявляет общий для всех поддерживаемых'#13+
'алгоритмов интерфейс; класс Context пользуется этим интерфейсом для вызова'#13+
'конкретного алгоритма, определенного в одном из классов ConcreteStrategy;'#13+
'\P\X~\IConcreteStrategyA\i, \IConcreteStrategyB\i, \IConcreteStrategyC\i (\IКонкретные\i'#13+
'\Iстратегии\i)~\= реализуют алгоритм, используя интерфейс, объявленный в классе'#13+
'Strategy; \P\X~\IContext\i (\IКонтекст\i)~\= конфигурируется объектом класса'#13+
'ConcreteStrategy; хранит ссылку на объект класса Strategy; может определять'#13+
'интерфейс, который позволяет объекту Strategy получить доступ'#13+
'к данным контекста.'#13+
'\P\SЗадание 1\s. Реализовать две иерархии классов. Первая иерархия включает'#13+
'абстрактный класс \MStrategy\m с абстрактным методом \MAlgorithmInterface(info)\m'#13+
'(метод имеет строковый параметр \Minfo\m и возвращает строковое значение)'#13+
'и конкретные классы \MConcreteStrategyA\m, \MConcreteStrategyB\m, \MConcreteStrategyC\m~\='#13+
'потомки класса \MStrategy\m. Конкретные классы имеют конструкторы без параметров,'#13+
'не выполняющие дополнительных действий. Метод \MAlgorithmInterface(info)\m'#13+
'конкретных классов A, B, C возвращает строку, полученную из строки \Minfo\m'#13+
'добавлением справа символа \<A\>, \<B\>, \<C\> соответственно.'#13+
'\PВторая иерархия включает абстрактный класс \MContext\m и конкретные классы'#13+
'\MContext1\m и \MContext2\m~\= потомки класса \MContext\m. Класс \MContext\m содержит'#13+
'поле \Mst\m~\= ссылку на объект типа \MStrategy\m~\= и методы \MSetStrategy(st)\m'#13+
'(с параметром-ссылкой \Mst\m типа \MStrategy\m) и \MContextInterface\m (без параметров,'#13+
'возвращает строковое значение). Метод \MSetStrategy\m класса \MContext\m присваивает'#13+
'свой параметр полю \Mst\m, метод \MContextInterface\m является абстрактным. Классы'#13+
'\MContext1\m и \MContext2\m переопределяют метод \MContextInterface\m, вызывая в нем'#13+
'метод \MAlgorithmInterface\m для поля \Mst\m, причем в качестве параметра \Minfo\m'#13+
'указывается строка \<1\> (для класса \MContext1\m) или \<2\> (для класса \MContext2\m);'#13+
'метод \MContextInterface\m возвращает строку, возвращаемую методом'#13+
'\MAlgorithmInterface\m. Конструкторы классов \MContext1\m и \MContext2\m не имеют'#13+
'параметров; в них создается объект типа \MConcreteStrategyA\m (для класса'#13+
'\MContext1\m) или \MConcreteStrategyB\m (для класса \MContext2\m) и поле \Mst\m'#13+
'инициализируется ссылкой на созданный объект.'#13+
TestHeader+
'Дана строка {S}, состоящая из символов \<1\> и \<2\>; ее длина не превосходит~15.'#13+
'Также дано целое число~{K}, не превосходящее длины строки~{S}, и набор {Ind}'#13+
'из {K}~различных целых чисел, определяющих индексы символов в строке~S'#13+
'(символы индексируются от~0). Создать коллекцию (например, массив) \Mct\m'#13+
'объектов-ссылок типа \MContext\m; размер коллекции равен длине строки~{S},'#13+
'фактический тип каждого элемента коллекции определяется соответствующим'#13+
'символом строки~{S} (тип \MContext1\m для символа \<1\> и тип \MContext2\m'#13+
'для символа \<2\>). Для элементов коллекции \Mct\m, индексы которых входят'#13+
'в исходный набор чисел {Ind}, вызвать метод \MSetStrategy\m, передав в качестве'#13+
'параметра объект типа \MConcreteStrategyC\m. Перебирая все объекты коллекции ct'#13+
'в исходном порядке, вызвать для них метод \MContextInterface\m'#13+
'и вывести его возвращаемое значение.'
);

s := ''; s1 := '';
n := Random(6) + 10;
for i := 1 to n do
  if Random(2) = 0 then
  begin
    s := s + '1';
    s1 := s1 + 'A';
  end
  else
  begin
    s := s + '2';
    s1 := s1 + 'B';
  end;
k := Random(n-8) + 4;
for i := 1 to n do
  ind[i] := i-1;
for i := 1 to n - 4 do
  swap(ind[Random(n)+1], ind[Random(n) + 1]);
DataS('S: ', s, 2, 1);
DataN('K = ', k, 28, 1, 1);
for i := 1 to k do
begin
  DataN('', ind[i], 36 + i * 4{Center(i, k, 2, 2) + 10}, 1, 2);
  s1[ind[i]+1] := 'C';
end;
for i := 1 to n do
  ResultS('',s[i]+s1[i],Center(i, n, 4, 1), 1);
end;


function RandID: string;
var i: integer;
begin
  result := '';
  for i := 1 to Random(3) + 2 do
    case Random(3) of
    0: result := result + chr(Random(10) + 48);
    1: result := result + chr(Random(26) + 65);
    2: result := result + chr(Random(26) + 97);
    end;
end;


procedure Pat2;
var n, a, b, k, i, j, min, max: integer;
    ind: array[1..10] of integer;
    v1,v: array[1..10] of char;
    c1, c2, c3: integer;
    s: array[1..5,1..10] of string;
    res: string;


function checkval(v: char; s: string): string;
var i, k: integer;
begin
  result := '';
  val(s, k, i);
  case v of
  'E': if s = '' then
         result := '!Empty text';
  'N': if i <> 0 then
         result := '!'''+s+''': not a number';
  'R': if (i <> 0) or (k < min) or (k> max) then
         result := '!'''+s+''': not in range '+IntToStr(min) + '..' + IntToStr(max);
   end;
end;

function checkall(i: integer): string;
var j: integer;
begin
  result := '';
  for j := 1 to n do
    result := result + checkval(v[j], s[i,j]);

end;

begin
  CreateTask(Subgroup1);
TaskText(
'\BStrategy\b (\BСтратегия\b)~\= паттерн поведения.'#13+
'\P\SЗадание 2\s. Реализовать иерархию классов-\Iвалидаторов\i, включающую'#13+
'класс \MValidator\m и его классы-потомки \MEmptyValidator\m, \MNumberValidator\m'#13+
'и \MRangeValidator\m. Классы-валидаторы предназначены для проверки правильности'#13+
'введенных строковых данных.'#13+
'\PКлассы \MValidator\m, \MEmptyValidator\m и \MNumberValidator\m не имеют полей,'#13+
'их конструкторы не имеют параметров и не выполняют дополнительных действий.'#13+
'В классе \MValidator\m определен метод \MValidate(s)\m, который имеет строковый'#13+
'параметр \Ms\m и возвращает строку с описанием ошибки, обнаруженной в строке~\Ms\m.'#13+
'Метод \MValidate\m класса \MValidator\m всегда возвращает пустую строку;'#13+
'таким образом, класс \MValidator\m считает допустимой любую строку.'#13+
'\PДля класса \MEmptyValidator\m метод \MValidate(s)\m возвращает пустую строку,'#13+
'если параметр~\Ms\m не является пустой строкой; в противном случае'#13+
'он возвращает строку \<!Empty text\>.'#13+
'\PДля класса \MNumberValidator\m метод \MValidate(s)\m возвращает пустую строку,'#13+
'если параметр~\Ms\m содержит строковое представление некоторого целого числа;'#13+
'в противном случае он возвращает строку вида \<!''<s>'': not a number\>,'#13+
'где <s>~\= значение параметра~\Ms\m.'#13+
'\PКласс \MRangeValidator\m содержит целочисленные поля \Mmin\m и \Mmax\m; его конструктор'#13+
'имеет целочисленные параметры~\Ma\m и~\Mb\m, инициализирующие поля таким образом,'#13+
'чтобы поле \Mmin\m было равно минимальному из чисел~\Ma\m и~\Mb\m, а поле \Mmax\m~\='#13+
'максимальному из этих чисел. Для класса \MRangeValidator\m метод \MValidate(s)\m'#13+
'возвращает пустую строку, если параметр~\Ms\m содержит строковое представление'#13+
'некоторого целого числа и при этом данное число лежит в диапазоне от \Mmin\m'#13+
'до \Mmax\m включительно; в противном случае метод возвращает строку вида'#13+
'\<!''<s>'': not in range <min>..<max>\>, где <s>~\= значение параметра~\Ms\m,'#13+
'а <min> и <max>~\= значения соответствующих полей.'#13+
'\PРеализовать класс \MTextBox\m, содержащий строковое поле \Mtext\m и поле~\Mv\m~\= ссылку'#13+
'на объект типа \MValidator\m. Конструктор класса не имеет параметров, в нем'#13+
'создается объект \MValidator\m, ссылка на него присваивается полю \Mv\m, а поле \Mtext\m'#13+
'инициализируется пустой строкой. Класс \MTextBox\m включает три метода:'#13+
'\P\X \MSetText(text)\m~\= изменяет поле \Mtext\m, присваивая ему значение параметра;'#13+
'\P\X \MSetValidator(v)\m~\= изменяет поле \Mv\m, присваивая ему значение параметра;'#13+
'\P\X Validate (без параметров)~\= вызывает для объекта~\Mv\m метод \MValidate\m'#13+
'с параметром \Mtext\m и возвращает значение, возвращенное этим методом.'#13+
'\PТакже реализовать класс \MTextForm\m. Он содержит коллекцию (например, массив) tb'#13+
'элементов типа \MTextBox\m. Конструктор класса \MTextForm\m имеет параметр~\Mn\m,'#13+
'который определяет размер коллекции \Mtb\m (можно считать, что параметр~\Mn\m'#13+
'не превосходит~10); в конструкторе создаются все элементы коллекции \Mtb\m.'#13+
'Класс \MTextForm\m включает три метода: \P\X \MSetText(ind, text)\m~\= изменяет поле \Mtext\m'#13+
'для элемента коллекции \Mtb\m с индексом \Mind\m; \P\X \MSetValidator(ind, v)\m~\= изменяет'#13+
'поле~\Mv\m для элемента набора \Mtb\m с индексом \Mind\m; \P\X \MValidate\m (без параметров)~\='#13+
'вызывает методы \MValidate\m для \Iвсех\i элементов коллекции \Mtb\m и возвращает строку,'#13+
'полученную объединением строк, возвращенных этими методами.'#13+
'\PПри реализации методов \MSetText\m и \MSetValidator\m можно считать, что параметр \Mind\m'#13+
'всегда лежит в допустимом диапазоне: от~0 до {n}\,\-\,1,'#13+
'где {n}~\= размер коллекции~\Mtb\m.'#13+
TestHeader+
'Даны три целых числа~{N}, {A}, {B}, причем~{N} лежит в диапазоне от~1 до~10.'#13+
'Также дано целое число~{K}, не превосходящее~{N}, и набор из {K} пар ({ind}, {val}),'#13+
'где {ind} является целым числом в диапазоне от~0 до {N}\,\-\,1, а {val} является одним'#13+
'из символов \<E\>, \<N\>, \<R\>. Все значения {ind} являются различными. Кроме того,'#13+
'дано пять наборов строк, каждый из которых содержит по {N} элементов.'#13+
'\PСоздать объект \Mtf\m типа \MTextForm\m, вызвав его конструктор с параметром~{N}.'#13+
'Для каждой пары ({ind}, {val}) вызвать метод \MSetValidator\m объекта \Mtf\m с первым'#13+
'параметром {ind} и вторым параметром~\= ссылкой на объект-валидатор, тип которого'#13+
'соответствует символу {val}: \<E\>~\= \MEmptyValidator\m, \<N\>~\= \MNumberValidator\m,'#13+
'\<R\>~\= \MRangeValidator\m; для объекта \MRangeValidator\m использовать конструктор'#13+
'с параметрами~{A} и~{B}, где~{A} и~{B}~\= ранее указанные числа. Для каждого из пяти'#13+
'данных наборов строк выполнить следующие действия: добавить набор строк'#13+
'в объект \Mtf\m (вызвав требуемое число раз метод \MSetText\m объекта \Mtf\m) и проверить'#13+
'правильность этого набора строк (вызвав метод \MValidate\m объекта \Mtf\m'#13+
'и выведя его результат).'
);

n := Random(6) + 5;
a := Random(9) + 1;
b := Random(9) + 1;
min := a;
max := b;
if min > max then
  Swap(min, max);
k := Random(n-4) + 3;
for i := 1 to n do
  ind[i] := i-1;
for i := 1 to n - 4 do
  swap(ind[Random(n)+1], ind[Random(n) + 1]);
repeat
  c1 := 0;
  c2 := 0;
  c3 := 0;
  for i := 1 to k do
    case Random(3) of
    0: begin
         v1[i] := 'E';
         c1 := c1 + 1;
    end;
    1: begin
         v1[i] := 'N';
         c2 := c2 + 1;
    end;
    2: begin
         v1[i] := 'R';
         c3 := c3 + 1;
    end;
    end;
  until (c1 > 0) and (c2 > 0) and (c3 > 0);

for i := 1 to n do
  v[i] := ' ';
for i := 1 to k do
  v[ind[i]+1] := v1[i];
//for i := 1 to n do
//  ResultC('', v[i], Center(i, n, 3, 3), 2);


DataN('N = ', n, 2, 1, 1);
DataN('A = ', a, 10, 1, 1);
DataN('B = ', b, 17, 1, 1);
DataN('K = ', k, 24, 1, 1);
for i := 1 to k do
begin
  DataN('', ind[i], 26 + i * 6, 1, 1);
  DataC('', v1[i], 28 + i * 6, 1);
end;


for i := 1 to 5 do
begin
repeat
  for j := 1 to n do
    case Random(4) of
    0: s[i,j] := '';
    1: s[i,j] := RandId;
    2: s[i,j] := IntToStr(Random(21) - 5);
    3: s[i,j] := IntToStr(Random(max-min+1) + min);
    end;
  res := checkall(i);
until length(res) <= 75;
  for j := 1 to n do
    DataS('', s[i,j], Center(j, n, 6, 1), i+1);
  ResultS('',res,0,i);


end;

end;


procedure Pat3;
var n, i: integer;
    a: array[1..10] of integer;

function receip(k: integer): string;
begin
  result := 'Boil water';
  case k of
  1,3: result := result + '=Brew tea';
  2,4: result := result + '=Brew coffee';
  end;
  result := result + '=Pour into a cup';
  case k of
  3: result := result + '=Add sugar and lemon';
  4: result := result + '=Add sugar and milk';
  end;
end;

begin
  CreateTask(Subgroup1);
  TaskText(
'\G<Graph\OOPTemplateMethod.png>\BTemplate Method\b (\BШаблонный метод\b)~\= паттерн поведения.'#13+
'\P\SЧастота использования\s: средняя.'#13+
'\P\SНазначение\s: определяет основу алгоритма и позволяет подклассам определить'#13+
'(или переопределить) некоторые шаги алгоритма, не изменяя'#13+
'его структуру в целом.'#13+
'\P\SУчастники\s: \P\X~\IAbstractClass\i (\IАбстрактный класс\i)~\= определяет абстрактные'#13+
'примитивные операции, замещаемые в конкретных подклассах для реализации шагов'#13+
'алгоритма; реализует шаблонный метод, определяющий последовательность действий'#13+
'алгоритма (шаблонный метод вызывает примитивные операции, а также операции,'#13+
'определенные в классе AbstractClass или в других объектах); \P\X~\IConcreteClass\i'#13+
'(\IКонкретный класс\i)~\= реализует примитивные операции, выполняющие шаги'#13+
'алгоритма способом, который зависит от подкласса.'#13+
'\PПомимо абстрактных примитивных операций шаблонного метода, которые \Iнеобходимо\i'#13+
'переопределить в конкретных классах, шаблонный метод может включать'#13+
'операции-\Iперехватчики\i (hooks), которые \Iмогут быть\i переопределены'#13+
'в конкретных класса, а могут быть оставлены без изменения. \PИспользование'#13+
'шаблонного метода позволяет избавиться от избыточного кода в подклассах.'#13+
'\P\SЗадание 1\s. Реализовать иерархию классов, связанную с формированием'#13+
'рецептов приготовления напитков и включающую абстрактный класс \MAbstractClass\m'#13+
'и четыре его потомка: \MConcreteClass1\m, \MConcreteClass2\m (непосредственные потомки'#13+
'абстрактного класса), \MConcreteClass3\m (потомок \MConcreteClass1\m) и \MConcreteClass4\m'#13+
'(потомок \MConcreteClass2\m). В абстрактном классе реализовать шаблонный метод'#13+
'\MTemplateMethod\m, который формирует и возвращает строковое значение.'#13+
'Это значение получается путем последовательного добавления к результирующей'#13+
'строке значений, возвращаемых методами \MBasicOperation1\m, \MPrimitiveOperation\m,'#13+
'\MBasicOperation2\m и \MHookOperation\m. Метод \MPrimitiveOperation\m является абстрактным'#13+
'методом, остальные методы имеют реализацию: метод \MBasicOperation1\m возвращает'#13+
'строку \<Boil water\> (вскипятить воду), метод \MBasicOperation2\m возвращает'#13+
'строку \<=Pour into a cup\> (налить в чашку), метод \MHookOperation\m возвращает'#13+
'пустую строку, причем данный метод является защищенным.'#13+
'\PВ классе \MConcreteClass1\m реализовать метод \MPrimitiveOperation\m, возвращающий'#13+
'строку \<=Brew tea\> (заварить чай), в классе \MConcreteClass2\m реализовать'#13+
'этот же метод, возвращающий строку \<=Brew coffee\> (заварить кофе). В классе'#13+
'\MConcreteClass3\m переопределить метод \MHookOperation\m таким образом, чтобы он'#13+
'возвращал строку \<=Add sugar and lemon\> (добавить сахар и лимон), в классе'#13+
'\MConcreteClass4\m переопределить этот же метод так, чтобы он возвращал строку'#13+
'\<=Add sugar and milk\> (добавить сахар и молоко). Конструкторы всех'#13+
'конкретных классов не имеют параметров и не выполняют дополнительных действий.'#13+
TestHeader+
'Дано целое число {N} (\l\,10) и набор из {N} целых чисел, принимающих значения'#13+
'от~1 до~4. Создать структуру данных (например, массив) из {N} элементов-ссылок'#13+
'типа \MAbstractClass\m и инициализировать ее элементы экземплярами конкретных'#13+
'классов в зависимости от значений соответствующих чисел исходного набора'#13+
'(если число равно~1, то создается экземпляр класса \MConcreteClass1\m,'#13+
'если число равно~2, то создается экземпляр класса \MConcreteClass2\m и т.\,д.).'#13+
'Перебирая элементы созданной структуры \Iв обратном порядке\i, вызвать'#13+
'для каждого из них метод \MTemplateMethod\m и вывести возвращенную им строку.'
);

n := Random(6) + 5;
for i := 1 to n do
  a[i] := Random(4)+1;
DataN('N = ', n, 0, 1, 1);
for i := 1 to n do
begin
  DataN('', a[i], Center(i, n, 1, 3), 2, 1);
  ResultS('', receip(a[n-i+1]), 0, i);
end;

end;



type strarr=array[0..10] of string;

procedure Pat4;
var n, k, i, j: integer;
    a: strarr;
    b: array[1..10] of char;
    kN, kL, kT: integer;

function Compare(k: char; a, b: string): integer;
var a1, b1, i: integer;
begin
  case k of
  'N': begin
    val(a, a1, i);
    if i > 0 then
      a1 := 0;
    val(b, b1, i);
    if i > 0 then
      b1 := 0;
    result := a1 - b1;
  end;
  'L': begin
    result := length(a) - length(b);
  end;
  'T': begin
    if a < b then result := -1
    else if a = b then result := 0
    else result := 1;
  end;
  end;
end;

function IndexMax(k: char; a: strarr; n: integer): integer;
var i: integer;
    max: string;
begin
  result := 0;
  max := a[1];
  for i := 2 to n do
    if Compare(k, a[i], max) > 0 then
    begin
    max := a[i];
    result := i - 1;
    end;
end;

function LastIndexMax(k: char; a: strarr; n: integer): integer;
var i: integer;
    max: string;
begin
  result := 0;
  max := a[1];
  for i := 2 to n do
    if Compare(k, a[i], max) >= 0 then
    begin
    max := a[i];
    result := i - 1;
    end;
end;

function IndexMin(k: char; a: strarr; n: integer): integer;
var i: integer;
    max: string;
begin
  result := 0;
  max := a[1];
  for i := 2 to n do
    if Compare(k, a[i], max) < 0 then
    begin
    max := a[i];
    result := i - 1;
    end;
end;

function LastIndexMin(k: char; a: strarr; n: integer): integer;
var i: integer;
    max: string;
begin
  result := 0;
  max := a[1];
  for i := 2 to n do
    if Compare(k, a[i], max) <= 0 then
    begin
    max := a[i];
    result := i - 1;
    end;
end;


begin
  CreateTask(Subgroup1);
TaskText(
'\BTemplate Method\b (\BШаблонный метод\b)~\= паттерн поведения.'#13+
'\P\SЗадание 2\s. Реализовать иерархию классов, связанную с поиском'#13+
'минимальных и максимальных элементов в наборе данных и включающую абстрактный'#13+
'класс \MAbstractComparable\m и три его потомка: \MNumberComparable\m, \MLengthComparable\m'#13+
'и \MTextComparable\m. В абстрактном классе реализованы четыре \Iстатических\i'#13+
'шаблонных метода \MIndexMax\m, \MLastIndexMax\m, \MIndexMin\m, \MLastIndexMin\m. Параметром'#13+
'каждого метода является коллекция \Mcomp\m (массив или другая структура данных),'#13+
'которая содержит ссылки на объекты типа \MAbstractComparable\m; методы возвращают'#13+
'целое число~\= индекс первого наибольшего, последнего наибольшего, первого'#13+
'наименьшего и последнего наименьшего элемента коллекции \Mcomp\m соответственно'#13+
'(индексирование производится от нуля).'#13+
'\PВ шаблонных методах используется абстрактный метод \MCompareTo(other)\m'#13+
'с параметром-ссылкой \Mother\m типа \MAbstractComparable\m. Этот метод позволяет'#13+
'сравнивать между собой экземпляры~\Ma\m и~\Mb\m одного и того же класса~\= потомка'#13+
'класса \MAbstractComparable\m: вызов \MComparable(b)\m для объекта~\Ma\m возвращает'#13+
'отрицательное значение, если~\Ma\m \<меньше\>, чем~\Mb\m; нулевое значение,'#13+
'если~\Ma\m \<равно\>~\Mb\m; положительное значение, если~\Ma\m \<больше\>, чем~\Mb\m'#13+
'(слова \<меньше\>, \<равно\> и \<больше\> взяты в кавычки, так как смысл сравнений'#13+
'может быть различным для разных потомков класса \MAbstractComparable\m).'#13+
'\PКаждый из конкретных классов имеет конструктор со строковым параметром \Mdata\m,'#13+
'который определяет значение поля \Mkey\m. Для класса \MNumberComparable\m поле \Mkey\m'#13+
'имеет целый тип; если параметр \Mdata\m является строковым представлением'#13+
'некоторого целого числа, то в поле \Mkey\m записывается это число, если параметр'#13+
'\Mdata\m не удовлетворяет указанному условию, то поле \Mkey\m полагается равным~0.'#13+
'Для класса \MLengthComparable\m поле \Mkey\m также имеет целый тип и полагается'#13+
'равным длине строки \Mdata\m. Для класса \MTextComparable\m поле \Mkey\m имеет'#13+
'строковый тип и полагается равным самой строке \Mdata\m.'#13+
'\PРеализовать в классах-потомках метод \MCompareTo(other)\m в котором параметр'#13+
'\Mother\m преобразуется к типу данного класса-потомка, после чего поля \Mkey\m'#13+
'объекта, вызвавшего метод, и объекта \Mother\m сравниваются между собой;'#13+
'если поле \Mkey\m объекта, вызвавшего метод, меньше, равно или больше поля \Mkey\m'#13+
'объекта \Mother\m, то метод возвращает соответственно отрицательное, нулевое'#13+
'или положительное значение (для класса \MTextComparable\m строковые поля \Mkey\m'#13+
'сравниваются лексикографически). Не требуется особым образом обрабатывать'#13+
'ситуацию, когда параметр \Mother\m не может быть преобразован к нужному типу,'#13+
'поскольку она не будет возникать при обработке'#13+
'правильно сформированных наборов данных.'#13+
TestHeader+
'Даны целые числа {N} (\l\,9), {K} (\l\,7), а также {K} наборов из {N}\,+\,1 строки,'#13+
'причем начальная строка в каждом наборе имеет вид \<N\>, \<L\> или \<T\>.'#13+
'Описать структуру данных \Mcomp\m из {N} элементов-ссылок типа \MAbstractComparable\m'#13+
'(тип структуры должен совпадать с типом параметра шаблонных методов)'#13+
'и использовать эту структуру для обработки \Iкаждого\i исходного набора строк'#13+
'следующим образом:'#13+
'\P(1)~создать и записать в структуру \Mcomp\m объекты, тип которых определяется'#13+
'начальной строкой обрабатываемого набора: если начальная строка равна \<N\>,'#13+
'\<L\> или \<T\>, то создаются объекты типа \MNumberComparable\m, \MLengthComparable\m'#13+
'или \MTextComparable\m соответственно; строки исходного набора'#13+
'указываются в качестве параметров конструкторов объектов,'#13+
'для начальной строки (равной \<N\>, \<L\> или \<T\>) объект не создается;'#13+
'\P(2)~вызвать шаблонные методы \MIndexMax\m, \MLastIndexMax\m, \MIndexMin\m, \MLastIndexMin\m'#13+
'с параметром \Mcomp\m и вывести их возвращаемые значения в указанном порядке.'
);
n := Random(7) + 3;
k := Random(4) + 4;
repeat
  kN := 0;
  kL := 0;
  kT := 0;
  for i := 1 to k do
    case Random(3) of
    0: begin
         b[i] := 'N';
         Inc(kN);
       end;
    1: begin
         b[i] := 'L';
         Inc(kL);
       end;
    2: begin
         b[i] := 'T';
         Inc(kT);
       end;
    end;
until kN * kL * kT > 0;

DataN('N = ', n, xLeft, 1, 1);
DataN('K = ', k, xRight, 1, 1);
for i := 1 to k do
begin
  a[0] := b[i];
  for j := 1 to n do
    case Random(4) of
    0: a[j] := '';
    1: a[j] := RandId;
    2,3: a[j] := IntToStr(Random(300) - 99);
    end;
  for j := 0 to n do
    DataS('', a[j], Center(j+1, n+1, 6, 1), i+1);
  ResultN('IndexMax = ', IndexMax(b[i], a, n), 6, i, 2);
  ResultN('LastIndexMax = ', LastIndexMax(b[i], a, n), 22, i, 2);
  ResultN('IndexMin = ', IndexMin(b[i], a, n), 42, i, 2);
  ResultN('LastIndexMin = ', LastIndexMin(b[i], a, n), 58, i, 2);



end;






end;


procedure Pat5;
var n, i, j, k, k1, k2: integer;
    s, ss: string;
    s0: array[1..10] of string;

begin
  CreateTask(Subgroup1);
TaskText(
'\G<Graph\OOPObserver.png>\BObserver\b (\BНаблюдатель\b)~\= паттерн поведения.'#13+
'\PИзвестен также под именем \BPublish-Subscribe\b (\BИздатель-Подписчик\b).'#13+
'\P\SЧастота использования\s: высокая.'#13+
'\P\SНазначение\s: определяет зависимость типа \<один-ко-многим\> между объектами таким'#13+
'образом, что при изменении состояния одного объекта все зависящие'#13+
'от него объекты-наблюдатели оповещаются об этом событии.'#13+
'\P\SУчастники\s: \P\X~\ISubject\i (\IСубъект\i)~\= располагает информацией о своих наблюдателях'#13+
'(за субъектом может следить любое число наблюдателей); предоставляет интерфейс'#13+
'(и, как правило, реализацию) для присоединения и отсоединения наблюдателей;'#13+
'\P\X~\IObserver\i (\IНаблюдатель\i)~\= определяет интерфейс обновления для объектов,'#13+
'которые должны быть уведомлены об изменении субъекта; \P\X~\IConcreteSubject\i'#13+
'(\IКонкретный субъект\i)~\= сохраняет состояние, представляющее интерес'#13+
'для конкретного наблюдателя ConcreteObserver; посылает информацию'#13+
'своим наблюдателям, когда происходит изменение; \P\X~\IConcreteObserver\i'#13+
'(\IКонкретный наблюдатель\i)~\= хранит ссылку на объект класса ConcreteSubject;'#13+
'сохраняет данные, которые должны быть согласованы с данными субъекта.'#13+
'\PОписываемый вариант паттерна Observer, при котором наблюдатель'#13+
'лишь уведомляется об изменении состояния субъекта и должен сам получить'#13+
'информацию о его новом состоянии, обратившись непосредственно к субъекту,'#13+
'называется \Iмоделью вытягивания\i (pull model).'#13+
'\P\SЗадание 1\s. Реализовать две иерархии классов. Первая иерархия'#13+
'включает базовый класс \MSubject\m с \Iконкретными\i методами \MAttach(observ)\m,'#13+
'\MDetach(observ)\m и \MNotify\m и класс-потомок \MConcreteSubject\m. Методы \MAttach\m'#13+
'и \MDetach\m имеют параметр-ссылку типа \MObserver\m и не возвращают значений. Метод'#13+
'\MNotify\m не имеет параметров и не возвращает значения; он является защищенным.'#13+
'\PВ классе \MSubject\m дополнительно описать поле \Mobservers\m. Это поле'#13+
'является структурой данных с элементами-ссылками типа \MObserver\m,'#13+
'в которой хранятся все наблюдатели, присоединенные в настоящий момент'#13+
'к субъекту (можно считать, что наблюдателей не более~10). В качестве'#13+
'такой структуры удобно использовать динамическую структуру, имеющую команды'#13+
'для добавления и удаления элементов. Метод \MAttach(observ)\m добавляет объект'#13+
'\Mobserv\m в структуру \Mobservers\m, метод \MDetach(observ)\m удаляет объект \Mobserv\m'#13+
'из данной структуры. В методе \MNotify\m выполняется перебор элементов структуры'#13+
'\Mobservers\m: для каждого элемента структуры вызывается его метод \MUpdate\m.'#13+
'При реализации метода \MNotify\m необходимо учесть ситуацию, когда во время'#13+
'выполнения метода \MUpdate\m некоторые наблюдатели отсоединятся от субъекта,'#13+
'что приведет к изменению структуры данных \Mobservers\m.'#13+
'\PВ классе \MConcreteSubject\m описать поле \Mstate\m, которое имеет символьный тип'#13+
'и моделирует текущее состояние субъекта. С ним связаны два метода. Метод'#13+
'\MSetState(st)\m имеет символьный параметр \Mst\m; если этот параметр не равен'#13+
'текущему значению поля \Mstate\m, то метод изменяет поле \Mstate\m, присваивая ему'#13+
'значение параметра \Mst\m, и дополнительно вызывает метод \MNotify\m;'#13+
'если параметр \Mst\m совпадает с текущим значением поля \Mstate\m, то метод'#13+
'\MSetState\m не выполняет никаких действий. Метод \MGetState\m (без параметров)'#13+
'возвращает текущее значение поля \Mstate\m. Конструктор класса \MConcreteSubject\m'#13+
'не имеет параметров, поле \Mstate\m инициализируется символом \<пробел\>.'#13+
'\PВторая иерархия включает абстрактный класс \MObserver\m с абстрактным методом'#13+
'\MUpdate\m (не имеет параметров и не возвращает значения) и конкретный класс'#13+
'\MConcreteObserver\m, имеющий строковое поле \Mlog\m, символьное поле \MdetachInfo\m,'#13+
'поле \Msubj\m~\= ссылку на объект типа \MConcreteSubject\m, а также методы \MAttach\m,'#13+
'\MDetach\m и \MGetLog\m. Конструктор класса \MConcreteObserver\m имеет параметры \Msubj\m'#13+
'и \MdetachInfo\m, которые инициализируют соответствующие поля; поле \Mlog\m'#13+
'инициализируется пустой строкой. Методы \MAttach\m и \MDetach\m не имеют параметров'#13+
'и не возвращают значения. В методе \MAttach\m выполняется вызов метода \MAttach\m'#13+
'объекта \Msubj\m, в методе \MDetach\m выполняется вызов метода \MDetach\m объекта \Msubj\m,'#13+
'причем в качестве параметра в обоих вызываемых методах передается ссылка'#13+
'на объект \MConcreteObserver\m, инициировавший вызов этих методов. Метод \MGetLog\m'#13+
'не имеет параметров и возвращает значение поля \Mlog\m.'#13+
'\PМетод \MUpdate\m, переопределяемый в классе \MConcreteObserver\m, является основным'#13+
'методом, обеспечивающим взаимодействие между конкретным субъектом и конкретным'#13+
'наблюдателем. Именно этот метод вызывается конкретным субъектом при изменении'#13+
'его состояния. Таким образом, его вызов означает, что состояние'#13+
'конкретного субъекта изменилось, и наблюдатель может узнать это новое'#13+
'состояние, вызвав в методе \MUpdate\m метод \MGetState\m объекта \Msubj\m. В данном'#13+
'задании в методе \MUpdate\m надо выполнить следующие дополнительные действия:'#13+
'добавить символ, полученный методом \MGetState\m, в конец поля \Mlog\m объекта'#13+
'\MConcreteObserver\m, для которого был вызван метод \MUpdate\m, и, кроме того, если'#13+
'полученный символ совпадает со значением поля \MdetachInfo\m, то немедленно'#13+
'отсоединить наблюдателя \MConcreteObserver\m от субъекта \Msubj\m,'#13+
'вызвав метод \MDetach\m наблюдателя.'#13+
TestHeader+
'Дано целое число {N} (\l\,10) и строка~{S}, содержащая заглавные'#13+
'латинские буквы. Создать объект \Msubj\m типа \MConcreteSubject\m и коллекцию'#13+
'(например, массив) \Mobservers\m из {N}~объектов типа \MConcreteObserver\m,'#13+
'указав в качестве первого параметра конструктора объектов \MConcreteObserver\m'#13+
'ссылку на объект \Msubj\m, а в качестве второго параметра~\= заглавные латинские'#13+
'буквы, перебирая их в алфавитном порядке (\<A\> для первого объекта коллекции'#13+
'observers, \<B\> для второго объекта и т.\,д.). Для каждого объекта'#13+
'\MConcreteObserver\m вызвать его метод \MAttach\m. Затем для каждого символа'#13+
'из данной строки~{S} вызвать метод \MSetState\m объекта \Msubj\m, передав методу этот'#13+
'символ в качестве параметра. После обработки всех символов строки~{S} вывести'#13+
'значения полей \Mlog\m объектов из коллекции \Mobservers\m, используя метод \MGetLog\m'#13+
'класса \MConcreteObserver\m. Выведенные строки будут содержать все начальные'#13+
'символы строки~{S} (без одинаковых соседних символов) вплоть до того символа,'#13+
'который вызвал отсоединение наблюдателя от объекта \Msubj\m.'
//#13+
//'\P\SПримечание\s. В языке C# для реализации паттерна \<Наблюдатель\> удобно'#13+
//'использовать \Iделегаты\i и \Iсобытия\i. В нашем случае можно удалить методы Attach'#13+
//'и Detach из иерархии классов Subject (оставив в абстрактном классе только'#13+
//'метод Notify), удалить структуру observers из класса ConcreteSubject, описать'#13+
//'делегат public delegate void NotifyEventHandler(), добавить событие OnNotify'#13+
//'в класс ConcreteSubject (public event NotifyEventHandler OnNotify)'#13+
//'и определить метод Notify следующим образом: if (OnNotify~!=~null) OnNotify().'#13+
//'В классе ConcreteObserver методы Attach и Detach будут содержать единственный'#13+
//'оператор: subj.OnNotify~+=~Update и subj.OnNotify~-=~Update соответственно.'
);
    n := Random(6) + 5;
repeat
    s := '';
    k := Random(12) + 15;
    k1 := 0;
    k2 := 0;
    for i := 1 to 26 do
      s := s + chr(64 + i);
    for i := 1 to 26 do
      SwapC(s[Random(26)+1], s[Random(26)+1]);
    s := copy(s, 1, k);
    repeat
    ss := s;
    for i := k downto 1 do
    begin
      if Random(3) = 0 then
        Insert(s[i],ss,i);
      if Random(3) = 0 then
        Insert(s[i],ss,i);
    end
    until length(ss) <= 32;
    for i := 1 to n do
    begin
      k := Pos(chr(64+ i), s);
      s0[i] := s;
      if k > 0 then
      begin
        Delete(s0[i], k + 1, 1000);
        k1 := k1 + 1;
      end
      else
        k2 := k2 + 1;
    end;
until (k1 > 0) and (k2 > 0);


    DataN('N = ', n, xLeft, 1, 1);
    DataS('S: ', ss, xRight, 1);
    k := (78 - Length('Наблюдатель A: ' + s)+1) div 2;
    for i := 1 to n do
      ResultS('Наблюдатель '+chr(i+64)+ ': ', s0[i], k, i);

end;

procedure Pat6;
var n, i, j, k, k1, k2, max, kk: integer;
    s1, s2: string;
    s0: array[1..10] of string;
    b1, b2: array[1..10] of boolean;
    s: array[1..30] of string;
    ss: array[1..45] of string;
begin
  CreateTask(Subgroup1);
TaskText(
'\BObserver\b (\BНаблюдатель\b)~\= паттерн поведения.'#13+
'\P\SЗадание 2\s. Реализовать вариант взаимодействия субъектов и наблюдателей,'#13+
'не требующий специальных методов доступа к состоянию субъекта и упрощающий'#13+
'взаимодействие наблюдателя с \Iнесколькими\i субъектами.'#13+
'\PПри таком варианте взаимодействия наблюдатель сразу получает значение'#13+
'нового состояния субъекта и поэтому наблюдателю не требуется обращаться'#13+
'к субъекту за получением дополнительной информации. Подобная модель'#13+
'взаимодействия называется \Iмоделью проталкивания\i (push model).'#13+
'\PПервая иерархия классов включает базовый класс \MSubject\m с \Iконкретными\i'#13+
'методами \MAttach(observ)\m, \MDetach(observ)\m, \MNotify(info)\m и класс-потомок'#13+
'\MConcreteSubject\m. Методы \MAttach\m и \MDetach\m имеют параметр-ссылку типа \MObserver\m'#13+
'и не возвращают значений. Метод \MNotify\m имеет строковый параметр, не возвращает'#13+
'значения и является защищенным. В классе \MSubject\m дополнительно описать поле'#13+
'\Mobservers\m~\= структуру данных с элементами-ссылками типа \MObserver\m, в которой'#13+
'хранятся все наблюдатели, присоединенные в настоящий момент к субъекту (можно'#13+
'считать, что наблюдателей не более~10). В качестве такой структуры удобно'#13+
'использовать динамическую структуру, имеющую команды'#13+
'для добавления и удаления элементов.'#13+
'\PМетод \MAttach(observ)\m добавляет объект \Mobserv\m в структуру \Mobservers\m,'#13+
'метод \MDetach(observ)\m удаляет объект \Mobserv\m из данной структуры. В методе'#13+
'\MNotify(info)\m выполняется перебор элементов структуры \Mobservers\m и для каждого'#13+
'элемента этой структуры вызывается его метод \MOnInfo(sender, info)\m, причем'#13+
'в качестве параметра \Minfo\m указывается параметр метода \MNotify\m, а в качестве'#13+
'параметра \Msender\m~\= ссылка на объект \MSubject\m, вызвавший метод \MNotify\m.'#13+
'Таким образом, наблюдатель сразу информируется и о наступившем событии,'#13+
'получая информацию в параметре \Minfo\m, и о субъекте \Msender\m, который инициировал'#13+
'это событие. При реализации метода \MNotify\m необходимо учесть ситуацию, когда'#13+
'некоторые наблюдатели в своем методе \MOnInfo\m отсоединятся от субъекта,'#13+
'что приведет к изменению структуры данных \Mobservers\m.'#13+
'\PВ классе \MConcreteSubject\m описать поле \Mstate\m, которое имеет строковый тип'#13+
'и моделирует текущее состояние субъекта. С ним связан метод \MSetState(st)\m,'#13+
'имеющий строковый параметр \Mst\m. Если этот параметр не равен текущему'#13+
'значению поля \Mstate\m, то метод изменяет поле \Mstate\m, присваивая ему'#13+
'значение параметра \Mst\m, и дополнительно вызывает метод \MNotify(state)\m;'#13+
'если параметр \Mst\m совпадает с текущим значением поля \Mstate\m, то метод'#13+
'\MSetState\m не выполняет никаких действий. Конструктор класса \MConcreteSubject\m'#13+
'не имеет параметров, поле \Mstate\m инициализируется пустой строкой.'#13+
'\PВторая иерархия включает абстрактный класс \MObserver\m с абстрактным методом'#13+
'\MOnInfo(sender, info)\m и класс-потомок \MConcreteObserver\m. Параметр \Msender\m метода'#13+
'\MOnInfo\m является ссылкой на объект типа \MSubject\m, параметр \Minfo\m~\= строковый.'#13+
'Класс \MConcreteObserver\m дополнительно имеет строковое поле \Mlog\m и символьное'#13+
'поле \MdetachInfo\m, а также методы \MAttach\m, \MDetach\m и \MGetLog\m. Конструктор класса'#13+
'\MConcreteObserver\m имеет параметр \MdetachInfo\m, который инициализирует'#13+
'соответствующее поле; поле \Mlog\m инициализируется пустой строкой. Методы'#13+
'\MAttach(subj)\m и \MDetach(subj)\m имеют параметр-ссылку типа \MSubject\m и не возвращают'#13+
'значений. В методе \MAttach\m выполняется вызов метода \MAttach\m объекта \Msubj\m,'#13+
'в методе \MDetach\m выполняется вызов метода \MDetach\m объекта \Msubj\m, причем'#13+
'в качестве параметра в обоих вызываемых методах передается ссылка на объект'#13+
'\MConcreteObserver\m, инициировавший вызов этих методов. Метод \MGetLog\m не имеет'#13+
'параметров и возвращает значение поля \Mlog\m.'#13+
'\PМетод \MOnInfo(sender, info)\m, переопределяемый в классе \MConcreteObserver\m,'#13+
'является основным методом, обеспечивающим взаимодействие между конкретным'#13+
'субъектом и конкретным наблюдателем. Напомним, что этот метод вызывается'#13+
'конкретным субъектом для информирования всех присоединенных к нему в настоящий'#13+
'момент наблюдателей, причем информация передается в поле \Minfo\m, а поле \Msender\m'#13+
'содержит ссылку на субъект, передавший эту информацию. В данном задании'#13+
'в методе \MOnInfo\m надо выполнить следующие действия: добавить содержимое'#13+
'параметра \Minfo\m в конец строки \Mlog\m объекта \MConcreteObserver\m, для которого'#13+
'был вызван метод \MOnInfo\m, и, кроме того, если \Iпоследний\i символ строки \Minfo\m'#13+
'совпадает со значением поля \MdetachInfo\m объекта \MConcreteObserver\m, то необходимо'#13+
'отсоединить этого наблюдателя от субъекта \Msender\m, вызвав метод \MDetach\m'#13+
'объекта \MConcreteObserver\m с параметром \Msender\m.'#13+
TestHeader+
'Дано целое число {N} (\l\,10). Кроме того, дано целое число~{K} (\l\,45) и набор'#13+
'двухсимвольных строк, первым символом которых является цифра \<1\> или \<2\>,'#13+
'а вторым~\= строчная латинская буква. Создать два объекта \Msubj1\m и \Msubj2\m'#13+
'типа \MConcreteSubject\m и коллекцию (например, массив) \Mobservers\m'#13+
'из {N}~объектов типа \MConcreteObserver\m, указывая в качестве параметра \MdetachInfo\m'#13+
'конструктора объектов \MConcreteObserver\m строчные латинские буквы, которые'#13+
'перебираются в алфавитном порядке (\<a\> для первого объекта коллекции'#13+
'\Mobservers\m, \<b\> для второго объекта и т.\,д.). Для каждого объекта'#13+
'\MConcreteObserver\m вызвать методы \MAttach\m с параметрами-ссылками на объекты'#13+
'\Msubj1\m и \Msubj2\m. Затем для каждой строки из данного набора строк вызвать метод'#13+
'\MSetState\m объекта \Msubj1\m или \Msubj2\m, передав эту строку в качестве параметра,'#13+
'причем если строка начинается с цифры \<1\>, то метод \MSetState\m должен'#13+
'вызываться для объекта \Msubj1\m, а если с цифры \<2\>, то для объекта \Msubj2\m.'#13+
'После обработки всех строк из исходного набора вывести значения полей \Mlog\m'#13+
'объектов из коллекции \Mobservers\m, используя метод \MGetLog\m класса'#13+
'\MConcreteObserver\m. Выведенные строки будут содержать все данные, переданные'#13+
'наблюдателям субъектами \Msubj1\m и \Msubj2\m (без одинаковых соседних данных),'#13+
'вплоть до тех, которые вызвали отсоединение наблюдателя'#13+
'от соответствующего субъекта.'
//#13+
//'\P\SПримечание\s. В языке C# описанный вариант взаимодействия субъектов'#13+
//'и наблюдателей можно реализовать с помощью \Iделегатов\i и \Iсобытий\i'#13+
//'(см. примечание к заданию \1).'
);

    n := Random(6) + 5;
    s1 := '';
    s2 := '';
    k := Random(13) + 18;
    k1 := k div 2 + Random(6) - 3;
    k2 := k - k1;
    for i := 1 to 26 do
      s1 := s1 + chr(96 + i);
    for i := 1 to 26 do
      SwapC(s1[Random(26)+1], s1[Random(26)+1]);
    s1 := copy(s1, 1, k1);
    for i := 1 to 26 do
      s2 := s2 + chr(96 + i);
    for i := 1 to 26 do
      SwapC(s2[Random(26)+1], s2[Random(26)+1]);
    s2 := copy(s2, 1, k2);


    for i := 1 to n do
    begin
      b1[i] := true;
      b2[i] := true;
    end;

    for i := 1 to k do
    begin
      if (Random(2) = 0) and (s1 <> '') or (s2 = '') then
      begin
        s[i] := '1' + s1[1];
        Delete(s1, 1, 1);
      end
      else
      begin
        s[i] := '2' + s2[1];
        Delete(s2, 1, 1);
      end;
      for j := 1 to n do
        case s[i][1] of
        '1': if b1[j] then
        begin
          s0[j] := s0[j] + s[i];
          if s[i][2] = chr(j + 96) then
            b1[j] := false;
        end;
        '2': if b2[j] then
        begin
          s0[j] := s0[j] + s[i];
          if s[i][2] = chr(j + 96) then
            b2[j] := false;
        end;
        end;
    end;

    max := 0;
    for i := 1 to n do
      if length(s0[i]) > max then
        max := length(s0[i]);


    DataN('N = ', n, xLeft, 1, 1);

   repeat
    kk := 0;
    for i := 1 to k do
    begin
      kk := kk + 1;
      if kk > 45 then
        break;
      ss[kk] := s[i];
      for j := 1 to 2 do
        if Random(3) = 0 then
        begin
          kk := kk + 1;
          if kk > 45 then
            break;
          ss[kk] := s[i];
        end;
    end;
    until (kk > 30) and (kk <= 45);

    for i := 2 to kk-1 do
      if (ss[i-1] = ss[i]) and (ss[i][1] <> ss[i+1][1]) and (Random(3) <> 0) then
      begin
        s1 := ss[i];
        ss[i] := ss[i+1];
        ss[i+1] := s1;
      end;


    DataN('K = ', kk, xRight, 1, 1);

    for i := 1 to 15 do
      DataS('', ss[i], 3 + 5*(i-1), 2);
    for i := 16 to 30 do
      DataS('', ss[i], 3 + 5*(i-16), 3);
    for i := 31 to kk do
      DataS('', ss[i], 3 + 5*(i-31), 4);

    k := (78 - (Length('Наблюдатель A: ') + max)+1) div 2;
    for i := 1 to n do
      ResultS('Наблюдатель '+chr(i+96)+ ': ', s0[i], k, i);
//      ResultS('', s0[i], 0, i);

end;

procedure Pat7;
var n, k, m, i, j: integer;
    cmd: array[1..10] of string;
    inv: array[1..30] of integer;
    act: array[1..20] of integer;
    s: array[1..20] of string;
    s0: string;
    b: boolean;
begin
  CreateTask(Subgroup2);
TaskText(
'\G<Graph\OOPCommand.png>\BCommand\b (\BКоманда\b)~\= паттерн поведения.'#13+
'\PИзвестен также под именем \BAction\b (\BДействие\b), \BTransaction\b (\BТранзакция\b).'#13+
'\P\SЧастота использования\s: выше средней.'#13+
'\P\SНазначение\s: инкапсулирует запрос (действие, операцию) как объект, позволяя'#13+
'тем самым задавать параметры клиентов для обработки соответствующих запросов,'#13+
'ставить запросы в очередь или протоколировать их, а также поддерживать'#13+
'отмену операций.'#13+
'\P\SУчастники\s: \P\X~\ICommand\i (\IКоманда\i)~\= объявляет интерфейс для выполнения запроса;'#13+
'\P\X~\IConcreteCommand\i (\IКонкретная команда\i)~\= определяет связь между'#13+
'объектом-получателем Receiver и требуемым запросом; реализует метод Execute'#13+
'путем вызова требуемых методов объекта Receiver; \P\X~\IClient\i (\IКлиент\i)~\= создает'#13+
'объект класса ConcreteCommand и задает его получателя; \P\X~\IInvoker\i (\IИнициатор\i)~\='#13+
'обращается к команде для выполнения запроса; не использует никакой информации'#13+
'о конкретном получателе запроса; \P\X~\IReceiver\i (\IПолучатель\i)~\= располагает'#13+
'информацией об операциях, необходимых для выполнения запроса; в роли'#13+
'получателя может выступать любой класс.'#13+
'\PОсновной особенностью паттерна Command является то, что он отделяет'#13+
'объект-инициатор Invoker, выдающий запросы, от объекта-получателя Receiver,'#13+
'который умеет эти запросы выполнять.'#13+
'\P\SЗадание 1\s. Реализовать классы, связанные с организацией запросов'#13+
'на основе паттерна Command. Иерархия классов-\Iкоманд\i включает абстрактный класс'#13+
'\MCommand\m с абстрактным методом \MExecute\m (который не имеет параметров и ничего'#13+
'не возвращает) и классы \MConcreteCommandA\m и \MConcreteCommandB\m, связанные'#13+
'с конкретными командами A и B. \PКлассы \MConcreteCommandA\m и \MConcreteCommandB\m'#13+
'включают поле \Mrecv\m, определяющее получателя соответствующей команды; это поле'#13+
'является ссылкой на объект класса \MReceiverA\m для команды A и ссылкой на объект'#13+
'класса \MReceiverB\m для команды B; поле \Mrecv\m определяется в конструкторе'#13+
'конкретной команды, имеющем параметр \Mrecv\m соответствующего типа.'#13+
'Метод \MExecute\m конкретной команды A вызывает метод \MActionA\m для объекта \Mrecv\m'#13+
'(типа \MReceiverA\m), метод \MExecute\m конкретной команды B вызывает метод \MActionB\m'#13+
'для объекта \Mrecv\m (типа \MReceiverB\m).'#13+
'\PКлассы-\Iполучатели\i \MReceiverA\m и \MReceiverB\m содержат поле \Mcli\m~\= ссылку на объект'#13+
'класса \MClient\m и поле \Minfo\m строкового типа; эти поля инициализируются'#13+
'в конструкторе, имеющем одноименные параметры. Метод \MActionA\m класса \MReceiverA\m'#13+
'вызывает метод \MAddLeft(info)\m объекта \Mcli\m; метод \MActionB\m класса \MReceiverB\m'#13+
'вызывает метод \MAddRight(info)\m объекта \Mcli\m. Следует подчеркнуть,'#13+
'что классы-получатели не входят в какую-либо особую иерархию,'#13+
'и каждый из них реализует свой собственный набор методов.'#13+
'\PКласс-\Iклиент\i \MClient\m содержит строковое поле \Minfo\m, которое инициализируется'#13+
'пустой строкой в конструкторе (конструктор не имеет параметров). Класс \MClient\m'#13+
'также содержит три метода: \MAddLeft(newInfo)\m, \MAddRight(newInfo)\m и \MGetInfo\m.'#13+
'Методы \MAddLeft\m и \MAddRight\m имеют строковый параметр \MnewInfo\m и добавляют строку'#13+
'\MnewInfo\m соответственно в начало и конец поля \Minfo\m; эти методы ничего'#13+
'не возвращают. Метод \MGetInfo\m без параметров возвращает значение поля \Minfo\m.'#13+
'\PКласс-\Iинициатор\i \MInvoker\m предназначен для выполнения связанной с ним команды.'#13+
'Он содержит поле \Mcmd\m~\= ссылку на объект типа \MCommand\m, которая инициализируется'#13+
'в конструкторе с одноименным параметром, а также метод \MInvoke\m,'#13+
'в котором выполняется вызов метода \MExecute\m команды \Mcmd\m'#13+
'(метод \MInvoke\m не имеет параметров и ничего не возвращает).'#13+
TestHeader+
'Дано целое число {N} (\l\,10), задающее количество различных команд, и набор~{S}'#13+
'из {N} различных строк, каждая из которых начинается либо с символа \<A\>,'#13+
'либо с символа \<B\>. Создать объект \Mcli\m типа \MClient\m и коллекцию \Mcmd\m (например,'#13+
'массив) из {N} команд с элементами-ссылками типа \MCommand\m. Каждый элемент'#13+
'коллекции \Mcmd\m является либо командой \MConcreteCommandA\m (если соответствующая'#13+
'строка набора~{S} начинается с символа \<A\>), либо командой \MConcreteCommandB\m'#13+
'(если соответствующая строка набора~{S} начинается с символа \<B\>);'#13+
'при создании команд~A и~B используются объекты типа \MReceiverA\m или \MReceiverB\m'#13+
'соответственно, которые, в свою очередь, создаются с помощью конструкторов,'#13+
'имеющих  следующие параметры: ранее созданный объект \Mcli\m типа \MClient\m'#13+
'и соответствующая строка из набора~{S}. \PНапример, если очередной строкой'#13+
'набора~{S} является строка \<Apqr\>, то соответствующим элементом коллекции \Mcmd\m'#13+
'должен быть объект \MConcreteCommandA\m, причем его конструктору должен'#13+
'передаваться объект \MReceiverA\m, в конструкторе которого'#13+
'указываются параметры \Mcli\m и \<Apqr\>.'#13+
'\PТакже дано целое число {K} (\l\,30), задающее количество различных инициаторов'#13+
'(объектов типа \MInvoker\m), и набор из {K} целых чисел со значениями из диапазона'#13+
'от 0 до {N}\,\-\,1 (каждый элемент набора определяет \Iиндекс\i некоторой команды'#13+
'из коллекции \Mcmd\m). Создать коллекцию \Minv\m (например, массив) из {K} инициаторов'#13+
'с элементами-ссылками типа \MInvoker\m и инициализировать каждого инициатора'#13+
'командой с соответствующим индексом из коллекции \Mcmd\m (например, если начальным'#13+
'элементом набора из {K} целых чисел является число 5, то начальный инициатор'#13+
'\Minv[0]\m должен инициализироваться командой \Mcmd[5]\m). \PНесколько инициаторов'#13+
'может быть связано с одной и той же командой (что является стандартной'#13+
'ситуацией при организации пользовательского интерфейса, когда одну'#13+
'и ту же команду можно выполнить, например, с помощью пункта меню,'#13+
'кнопки быстрого доступа или горячей клавиши).'#13+
'\PНаконец, дано целое число {M} (\l\,20), задающее количество команд для выполнения,'#13+
'и набор из {M} целых чисел со значениями из диапазона от 0 до {K}\,\-\,1 (каждый'#13+
'элемент набора определяет \Iиндекс\i того инициатора из коллекции \Minv\m, который'#13+
'должен использоваться для выполнения требуемой команды). Выполнить требуемые'#13+
'команды, вызвав метод \MInvoke\m для элементов коллекции \Minv\m с указанными'#13+
'индексами. После выполнения каждой команды выводить текущее состояние'#13+
'объекта \Mcli\m, используя его метод \MGetInfo\m.'
);

n := Random(5) + 6;
for i := 1 to n do
begin
repeat
  cmd[i] := chr(65 + Random(2)) + chr(97+Random(26)) + chr(97+Random(26));
  b := true;
  for j := 1 to i-1 do
    if cmd[i] = cmd[j] then
    begin
      b := false;
      break;
    end;
until b;
end;

k := Random(16) + 15;
for i := 1 to k do
  inv[i] := Random(n);

m := Random(9) + 12;
for i := 1 to m do
  act[i] := Random(k);


DataN('N = ', n, xLeft, 1, 2);
DataComment('Значения команд:', xRight, 1);
for i := 1 to n do
  DataS('', cmd[i], Center(i, n, 5, 2), 2);
DataN('K = ', k, xLeft, 3, 2);
DataComment('Индексы команд для инициаторов:', xRight, 3);
for i := 1 to k do
  DataN('', inv[i], Center(i, k, 1, 1), 4, 1);
DataN('M = ', m, xLeft, 5, 2);
DataComment('Индексы вызываемых инициаторов:', xRight, 5);
for i := 1 to m do
  DataN('', act[i], Center(i, m, 2, 1), 7, 2);


s[1] := cmd[inv[act[1]+1]+1];
for i := 2 to m do
begin
  s0 := cmd[inv[act[i]+1]+1];
  if s0[1] = 'A' then
    s[i] := s0 + s[i-1]
  else
    s[i] := s[i-1] + s0;
end;

for i := 1 to m do
  ResultS('',s[i],0,i);

end;


procedure Pat8;
var c1, c2: char;
    n, k, i, j: integer;
    cmd: array[1..40] of string;
    cc, rc, uc: integer;
    undocmd: array[1..40] of string;
    undoind: integer;
    undocount: integer;
    b: boolean;
    res: array[1..300] of string;
    rescount: integer;
    resdiv, resmod: integer;
    nstart, randmax, cmax, umax, rmax, unum, rnum, ct, datadiv, datamod: integer;

function Exec(cmd0: string): string;
begin
  inc(rescount);
  case cmd0[2] of
  '0': res[rescount] := '+'+c1;
  '1': res[rescount] := '+'+c2;
  '2':
  begin
    cc := cc + 1;
    res[rescount] := '+'+c1;
    inc(rescount);
    res[rescount] := '+'+c2;
  end;
  end;
end;

function Unexec(cmd0: string): string;
begin
  inc(rescount);
  case cmd0[2] of
  '0': res[rescount] := '-'+c1;
  '1': res[rescount] := '-'+c2;
  '2':
  begin
    res[rescount] := '-'+c2;
    inc(rescount);
    res[rescount] := '-'+c1;
  end;
  end;
end;




begin
  CreateTask(Subgroup2);
TaskText(
'\BCommand\b (\BКоманда\b)~\= паттерн поведения.'#13+
'\P\SЗадание 2\s. Реализовать набор классов для варианта паттерна Command'#13+
'с дополнительными возможностями, связанными с \Iсозданием макрокоманд\i'#13+
'и \Iотменой предыдущих действий\i.'#13+
'\PИмеются три класса-\Iполучателя\i, реализующих различные действия и умеющих'#13+
'отменять их: класс \MReceiverA\m включает статические методы \MActionA\m (выводит'#13+
'строку \<+A\>) и \MUndoActionA\m (выводит строку \<\-A\>), класс \MReceiverB\m включает'#13+
'статические методы \MActionB\m (выводит строку \<+B\>) и \MUndoActionB\m (выводит'#13+
'строку \<\-B\>), класс \MReceiverC\m включает статические методы \MActionC\m (выводит'#13+
'строку \<+C\>) и \MUndoActionC\m (выводит строку \<\-C\>). Других методов'#13+
'или полей классы-получатели не содержат. Следует подчеркнуть,'#13+
'что эти классы не входят в какую-либо особую иерархию.'#13+
'\PИерархия классов-\Iкоманд\i начинается с абстрактного класса \MCommand\m, включающего'#13+
'методы \MExecute\m и \MUnexecute\m (методы не имеют параметров и не возвращают'#13+
'значений). Его потомками являются классы \MCommandA\m, \MCommandB\m, \MCommandC\m'#13+
'и \MMacroCommand\m. Конструкторы классов \MCommandA\m, \MCommandB\m, \MCommandC\m не имеют'#13+
'параметров и не выполняют дополнительных действий. Метод \MExecute\m команды A'#13+
'выполняет вызов статического метода \MActionA\m класса-получателя \MReceiverA\m,'#13+
'метод \MUnexecute\m команды A выполняет вызов статического метода \MUndoActionA\m.'#13+
'Методы \MExecute\m и \MUnexecute\m команд B и C определяются аналогично,'#13+
'с использованием статических методов классов \MReceiverB\m и \MReceiverC\m.'#13+
'\PКласс \MMacroCommand\m позволяет объединять имеющиеся команды в последовательности'#13+
'команд (\Iмакрокоманды\i). Он содержит структуру данных \Mcmds\m (например, массив)'#13+
'с элементами-ссылками типа \MCommand\m, которая инициализируется в конструкторе,'#13+
'имеющем соответствующий параметр-структуру (можно считать, что макрокоманда'#13+
'содержит не более 5~команд). Метод \MExecute\m класса \MMacroCommand\m выполняет вызов'#13+
'методов \MExecute\m всех элементов структуры \Mcmds\m в исходном порядке,'#13+
'а метод \MUnexecute\m~\= вызов методов \MUnexecute\m всех элементов'#13+
'структуры \Mcmds\m \Iв обратном порядке\i.'#13+
'\PРеализовать класс \MMenu\m, предоставляющий средства для настройки \Iинициаторов\i'#13+
'команд, их выполнения, а также выполнения операций отмены и восстановления.'#13+
'Класс \MMenu\m содержит две структуры данных: массив \MmenuCmds\m размера~3, в котором'#13+
'хранятся ссылки на команды, \Iдоступные для выполнения\i, и структуру \MlastCmds\m,'#13+
'в котором хранятся ссылки на \Iранее выполненные команды\i, что дает возможность'#13+
'\Iотменять\i эти команды или, после отмены, \Iвосстанавливать\i их. В качестве'#13+
'структуры \MlastCmds\m удобно использовать динамическую структуру, позволяющую'#13+
'добавлять в конец новые элементы и удалять часть последних элементов. Можно'#13+
'считать, что структура \MlastCmds\m в любой момент времени будет содержать'#13+
'не более 40~элементов. Со структурой \MlastCmds\m связано дополнительное'#13+
'целочисленное поле \MundoIndex\m, определяющее индекс элемента из \MlastCmds\m, после'#13+
'которого следуют \Iранее отмененные\i команды (которые впоследствии могут быть'#13+
'восстановлены). \PКонструктор класса \MMenu\m содержит два ссылочных параметра:'#13+
'\Mcmd1\m и \Mcmd2\m типа \MCommand\m; эти параметры определяют два начальных элемента'#13+
'массива \MmenuCmds\m; третий элемент этого массива является макрокомандой'#13+
'(объектом типа \MMacroCommand\m), включающей команды \Mcmd1\m и \Mcmd2\m'#13+
'в указанном порядке.'#13+
'\PКласс \MMenu\m содержит три метода: \MInvoke(cmdIndex)\m, \MUndo(count)\m и \MRedo(count)\m;'#13+
'методы имеют целочисленные параметры и не возвращают значений.'#13+
'\PМетод \MInvoke(cmdIndex)\m \Iвыполняет\i команду из массива \MmenuCmds\m с индексом'#13+
'\McmdIndex\m (при реализации этого метода можно считать, что параметр \McmdIndex\m'#13+
'всегда находится в допустимом диапазоне~0\:2).  Кроме того, при выполнении'#13+
'метода \MInvoke\m из структуры \MlastCmds\m удаляются все конечные элементы, начиная'#13+
'с элемента с индексом \MundoIndex\,+\,1\m (если такие элементы существуют), в конец'#13+
'структуры \MlastCmds\m добавляется ссылка на только что выполненную команду,'#13+
'а значение поля \MundoIndex\m полагается равным индексу добавленной команды.'#13+
'\PМетод \MUndo(count)\m \Iотменяет\i \Mcount\m выполненных команд, хранящихся в структуре'#13+
'\MlastCmds\m, начиная с команды с индексом \MundoIndex\m в направлении \Iуменьшения\i'#13+
'индексов (если в структуре \MlastCmds\m содержится недостаточно элементов,'#13+
'то отменяются все доступные команды). Для каждой из этих команд вызывается'#13+
'метод \MUnexecute\m; кроме того, значение поля \MundoIndex\m корректируется так,'#13+
'чтобы оно соответствовало последней еще не отмененной команде (если отменены'#13+
'все команды из набора \MlastCmds\m, то значение \MundoIndex\m полагается равным~\-1).'#13+
'\PМетод \MRedo(count)\m \Iвосстанавливает\i \Mcount\m ранее отмененных команд, выполняя'#13+
'метод \MExecute\m для элементов структуры \MlastCmds\m, начиная с команды с индексом'#13+
'\MundoIndex\,+\,1\m в направлении \Iувеличения\i индексов (если в структуре \MlastCmds\m'#13+
'содержится недостаточно элементов, то восстанавливаются все ранее отмененные'#13+
'команды). Кроме того, значение поля \MundoIndex\m корректируется так, чтобы оно'#13+
'соответствовало последней восстановленной команде.'#13+
'\PОписанный механизм отмены/восстановления команд позволяет отменять'#13+
'и восстанавливать любое количество ранее выполненных команд (с сохранением'#13+
'их исходного порядка выполнения), однако при выполнении новой команды'#13+
'он блокирует возможность восстановления ранее отмененных команд (поскольку'#13+
'их результат может конфликтовать с результатом выполнения новой команды).'#13+
TestHeader+
'Даны два различных символа {C}_1 и {C}_2, которые могут принимать три значения:'#13+
'\<A\>, \<B\>, \<C\>. Символ {C}_1 определяет тип первого параметра конструктора объекта'#13+
'\MMenu\m (значение \<A\> соответствует классу \MCommandA\m, значение \<B\>~\= классу'#13+
'\MCommandB\m, значение \<C\>~\= классу \MCommandC\m). Аналогичным образом,'#13+
'символ {C}_2 определяет тип второго параметра конструктора объекта \MMenu\m.'#13+
'Используя указанную информацию, создать объект~\Mm\m типа \MMenu\m.'#13+
'\PТакже дано целое число {N} (\l\,40), задающее количество методов объекта~\Mm\m'#13+
'для выполнения, и набор из {N} двухсимвольных строк, кодирующих требуемые'#13+
'методы. Первый символ каждой строки является одной из букв \<I\>, \<U\>, \<R\>,'#13+
'а второй символ является цифрой, причем в случае первого символа \<I\> возможны'#13+
'только цифры \<0\>, \<1\>, \<2\>, а в случае символов \<U\> и \<R\>~\= только цифры'#13+
'в диапазоне от \<1\> до \<9\>. Строки \<I0\>, \<I1\>, \<I2\> соответствуют методу'#13+
'\MInvoke\m с параметрами 0, 1, 2; строки, начинающиеся с символа \<U\>,'#13+
'соответствуют методу \MUndo\m, причем цифра определяет количество команд'#13+
'для отмены (например, строка \<U4\> соответствует методу \MUndo(4)\m); строки,'#13+
'начинающиеся с символа \<R\>, соответствуют методу \MRedo\m, а цифра определяет'#13+
'количество восстанавливаемых команд.'#13+
'\PВыполнить в указанном порядке все методы для созданного объекта~\Mm\m типа \MMenu\m.'#13+
'Выводить какие-либо данные не требуется, так как вывод осуществляется'#13+
'в классах-получателях \MReceiverA\m, \MReceiverB\m и \MReceiverC\m'#13+
'при выполнении соответствующих команд.'
);

c1 := chr(Random(3) + 65);
repeat
  c2 := chr(Random(3) + 65);
until c1 <> c2;
DataC('C1 = ', c1, xLeft, 1);
DataC('C2 = ', c2, xRight, 1);
n := Random(9) + 32;
nstart := 10;
randmax := 3;
cmax := 5;
umax := 10;
rmax := 5;
unum := 5;
rnum := 5;
ct := CurrentTest;
case ct of
1: begin
     nstart := Random(3) + 8;
     n := nstart;
     randmax := 1;
     cmax := 4;
     umax := -1;
     rmax := -1;
     unum := 5;
     rnum := 5;
   end;
2: begin
     nstart := 5;
     n := Random(5) + 11;
     randmax := 2;
     cmax := 3;
     umax := 4;
     rmax := -1;
     unum := 1;
     rnum := 5;
   end;
3: begin
     nstart := 7;
     n := Random(5) + 13;
     randmax := 2;
     cmax := 5;
     umax := 5;
     rmax := -1;
     unum := 5;
     rnum := 5;
   end;
4: begin
     nstart := 5;
     n := Random(5) + 15;
     cmax := 5;
     umax := 5;
     rmax := 3;
     unum := 5;
     rnum := 1;
   end;
5: begin
     nstart := 5;
     n := Random(4) + 17;
     cmax := 5;
     umax := 5;
     rmax := 5;
     unum := 5;
     rnum := 5;
   end;
end;
repeat
rc := 0;
uc := 0;
cc := 0;
rescount := 0;
undocount := 0;
undoind := 0;
for i := 1 to nstart do
begin
  cmd[i] := 'I' + chr(Random(3) + 48);
  undocmd[i] := cmd[i];
  inc(undocount);
  inc(undoind);
  if cmd[i][2] = '2' then
    cc := cc + 1;
  Exec(cmd[i]);
end;
b := false;
for i := nstart+1 to n do
begin
  case Random(randmax) of
  0: begin
         cmd[i] := 'I' + chr(Random(3) + 48);
         if cmd[i][2] = '2' then
           cc := cc + 1;
         b := false;
         undocount := undoind;
         inc(undocount);
         inc(undoind);
         undocmd[undocount] := cmd[i];
         Exec(cmd[i]);
       end;
  1:   begin
         cmd[i] := 'U' + chr(Random(unum) + 49);
         k := Ord(cmd[i][2])-48;
         uc := uc + 1;
         b := true;
         for j := undoind downto undoind - k + 1 do
         begin
           if j = 0 then break;
           UnExec(undocmd[j]);
           Dec(undoInd);
         end;
       end;
  2:   if b then
       begin
         cmd[i] := 'R' + chr(Random(rnum) + 49);
         k := Ord(cmd[i][2])-48;
         for j := undoind+1 to undoind + k do
         begin
           if j > undocount then break;
           Exec(undocmd[j]);
           Inc(undoInd);
         end;
         rc := rc + 1;
       end
       else
       begin
         cmd[i] := 'U' + chr(Random(unum) + 49);
         k := Ord(cmd[i][2])-48;
         uc := uc + 1;
         b := true;
         for j := undoind downto undoind - k + 1 do
         begin
           if j = 0 then break;
           UnExec(undocmd[j]);
           Dec(undoInd);
         end;
       end;
  end;
end;
until (rc > rmax) and (uc > umax) and (cc > cmax);
DataN('N = ', n, 0, 2, 2);
datadiv := n div 10;
datamod := n mod 10;
k := 2;
for j := 0 to datadiv-1 do
begin
  inc(k);
  for i := 1 to 10 do
    DataS('', cmd[i + j * 10], Center(i, 10, 4, 2), k);
end;
if datamod > 0 then
  inc(k);
for i := 1 to datamod do
    DataS('', cmd[i + datadiv * 10], Center(i, 10, 4, 2), k);
{
for i := 1 to 10 do
  DataS('', cmd[i], Center(i, 10, 4, 2), 3);
for i := 1 to 10 do
  DataS('', cmd[i+10], Center(i, 10, 4, 2), 4);
for i := 1 to 10 do
  DataS('', cmd[i+20], Center(i, 10, 4, 2), 5);
for i := 1 to n-30 do
  DataS('', cmd[i+30], Center(i, 10, 4, 2), 6);
}

//ResultN('', rescount, 0, 1, 1);
  resdiv := rescount div 10;
resmod := rescount mod 10;
k := 0;
for j := 0 to resdiv-1 do
begin
  inc(k);
  for i := 1 to 10 do
    ResultS('', res[i + j * 10], Center(i, 10, 4, 2), k);
end;
if resmod > 0 then
  inc(k);
for i := 1 to resmod do
    ResultS('', res[i + resdiv * 10], Center(i, 10, 4, 2), k);

SetTestCount(9);
end;

procedure Pat9;
var i, k, j, y: integer;
    s, s0: string;
    tok: array[1..100] of string;
    cnt, pos: integer;
    state: string;
    isQuote: boolean;
    ncnt, scnt, ccnt, qcnt, eccnt, escnt, ecmin, esmin: integer;
begin
  CreateTask(Subgroup2);
TaskText(
'\G<Graph\OOPState.png>\BState\b (\BСостояние\b)~\= паттерн поведения.'#13+
'\P\SЧастота использования\s: средняя.'#13+
'\P\SНазначение\s: позволяет объекту варьировать свое поведение в зависимости'#13+
'от внутреннего состояния, которое определяется одним из нескольких объектов,'#13+
'связанных с конкретными состояниями и имеющими одинаковый интерфейс.'#13+
'Извне создается впечатление, что изменился класс объекта.'#13+
'\P\SУчастники\s: \P\X~\IContext\i (\IКонтекст\i)~\= определяет интерфейс, представляющий интерес'#13+
'для клиентов; хранит экземпляр подкласса ConcreteState, которым определяется'#13+
'текущее состояние; \P\X~\IState\i (\IСостояние\i)~\= определяет интерфейс для инкапсуляции'#13+
'поведения, ассоциированного с конкретным состоянием контекста Context;'#13+
'\P\X~\IConcreteStateA\i, \IConcreteStateB\i (\IКонкретные состояния\i)~\= реализуют поведение,'#13+
'ассоциированное с некоторым состоянием контекста Context.'#13+
'\P\SЗадание 1\s. Реализовать набор классов, связанных с разбором текста на основе'#13+
'паттерна State. Предполагается, что обрабатываемый текст включает обычное'#13+
'содержимое (токен Normal), строковые литералы, заключенные в двойные кавычки'#13+
'(токен String), и комментарии, заключенные в фигурные скобки (токен Comm).'#13+
'Фигурные скобки в строковых литералах считаются обычными символами,'#13+
'как и двойные кавычки в комментариях. Если в строковом литерале встречаются'#13+
'две двойных кавычки подряд, то они рассматриваются как обычный символ'#13+
'\<двойная кавычка\>, входящий в строковый литерал. Комментарии не являются'#13+
'вложенными; открывающая фигурная скобка внутри комментария рассматривается'#13+
'как обычный символ.'#13+
'\PПризнаком конца разбираемого текста является наличие точки, которая'#13+
'не считается входящей в сам текст. В токены String не включаются обрамляющие'#13+
'кавычки, в токены Comm не включаются обрамляющие фигурные скобки.'#13+
'Если последний строковый литерал или комментарий не заканчивается требуемым'#13+
'символом (кавычкой или фигурной скобкой соответственно), то подобный фрагмент'#13+
'текста считается \Iошибочным токеном\i ErrString или ErrComm соответственно;'#13+
'такой токен должен содержать символы от начала строкового литерала'#13+
'или комментария вплоть до завершающей точки (не включая эту точку).'#13+
'\PЛюбые виды токенов могут быть пустыми; в начале и конце текста, а также между'#13+
'специальными токенами String и Comm обязательно присутствует токен'#13+
'Normal (возможно, пустой). Исключением являются ошибочные токены ErrString'#13+
'и ErrComm, после которых разбор текста завершается.'#13+
'\PИерархия классов-\Iсостояний\i включает абстрактный класс \MState\m с абстрактным'#13+
'методом \MHandle\m (не имеет параметров, возвращает строку с описанием очередного'#13+
'токена разбираемого текста) и классы \MConcreteStateNormal\m, \MConcreteStateString\m,'#13+
'\MConcreteStateComm\m и \MConcreteStateFinal\m. Каждый конкретный класс, кроме класса'#13+
'\MConcreteStateFinal\m, содержит поле \Mct\m~\= ссылку на объект \MContext\m~\= и поле \Mind\m'#13+
'целого типа, которые инициализируются в конструкторе с использованием'#13+
'соответствующих параметров. Поле \Mct\m определяет объект, содержащий разбираемый'#13+
'текст, а поле \Mind\m определяет индекс позиции, начиная с которой'#13+
'требуется продолжить разбор текста.'#13+
'\PМетод \MHandle\m возвращает строку, содержащую полученный токен (возможно,'#13+
'пустой), перед которым указывается его тип и двоеточие (например,'#13+
'\<Normal:abc\>, \<ErrString:mn2\>, \<Comm:\>). Класс \MConcreteStateFinal\m не содержит'#13+
'полей, его конструктор не выполняет дополнительных действий, а метод \MHandle\m'#13+
'всегда возвращает пустую строку.'#13+
'\PПосле определения текущего токена Normal метод \MHandle\m класса'#13+
'\MConcreteStateNormal\m вызывает метод \MSetState\m контекста \Mct\m, указывая в качестве'#13+
'параметра экземпляр класса \MConcreteStateString\m (если обнаружен символ'#13+
'\<двойная кавычка\>), \MConcreteStateComm\m (если обнаружен символ \<\{\>)'#13+
'или \MConcreteStateFinal\m (если обнаружен символ \<точка\>).'#13+
'\PПосле определения текущего \Iправильного\i токена String или Comm метод'#13+
'\MHandle\m классов \MConcreteStateString\m и \MConcreteStateComm\m вызывает'#13+
'метод \MSetState\m контекста \Mct\m, указывая в качестве параметра экземпляр класса'#13+
'\MConcreteStateNormal\m. \PПосле определения \Iошибочного\i токена ErrString'#13+
'или ErrComm метод \MHandle\m классов \MConcreteStateString\m и \MConcreteStateComm\m'#13+
'вызывает метод \MSetState\m контекста \Mct\m с экземпляром класса \MConcreteStateFinal\m.'#13+
'\PКласс-\Iконтекст\i Context содержит строковое поле \Mtxt\m с разбираемым текстом'#13+
'и поле-ссылку \Mst\m типа \MState\m. Конструктор класса имеет параметр \Mtxt\m,'#13+
'используемый для инициализации поля \Mtxt\m; поле \Mst\m инициализируется'#13+
'объектом типа \MConcreteStateNormal\m. Класс \MContext\m имеет методы'#13+
'\MGetCharAt(ind)\m, \MSetState(st)\m и \MRequest\m: \P\X метод \MGetCharAt\m возвращает'#13+
'символ поля \Mtxt\m с индексом \Mind\m (предполагается, что индекс находится'#13+
'в допустимом диапазоне); \P\X метод \MSetState\m изменяет поле \Mst\m, присваивая ему'#13+
'значение параметра \Mst\m (этот метод, наряду с методом \MGetCharAt\m, используется'#13+
'в методах классов-состояний); \P\X метод \MRequest\m возвращает очередной токен'#13+
'разбираемого текста, вызывая метод \MHandle\m объекта \Mst\m.'#13+
TestHeader+
'Дана строка, которая оканчивается точкой. Используя объект \Mct\m типа \MContext\m,'#13+
'выполнить разбор данной строки, вызывая метод \MRequest\m объекта \Mct\m и выводя'#13+
'его возвращаемый результат, пока очередной вызов не вернет'#13+
'пустую строку (пустую строку выводить не следует).'
);

ecmin := 0;
esmin := 0;
case CurrentTest of
3: ecmin := 1;
6: esmin := 1;
end;

y := 0;
repeat
  s := '';
  ncnt := 0;
  scnt := 0;
  ccnt := 0;
  escnt := 0;
  eccnt := 0;
  qcnt := 0;
  for i := 1 to Random(10)+20 do
    if random(4) <> 0 then
    s := s + chr(Random(26)+97)
    else
    s := s + chr(Random(10)+ 48);
  for i := 1 to Random(6) + 22 do
  begin
    k := Random(length(s))+1;
    case Random(5) of
    0, 1: s0 := '"';
    2:    s0 := '""';
    3: s0 := '{';
    4: s0 := '}';
    end;
    case Random(5) of
    1: s := s0 + s;
    2..5: Insert(s0, s, k);
    6: s := s + s0;
    end;
  end;
  s := s + '.';
  cnt := 0;
  pos := 1;
  state := 'Normal';
  s0 := '';
  isQuote := false;
  for i := 1 to length(s) do
  begin
    if state = 'Normal' then
      case s[i] of
      '{': begin
             inc(cnt);
             tok[cnt] := state + ':' + s0;
             if s0 <> '' then
               inc(ncnt);
             s0 := '';
             state := 'Comm';
           end;
      '"': begin
             inc(cnt);
             tok[cnt] := state + ':' + s0;
             if s0 <> '' then
               inc(ncnt);
             s0 := '';
             state := 'String';
           end;
      '.': begin
             inc(cnt);
             tok[cnt] := state + ':' + s0;
             s0 := '';
             state := 'Fin';
           end;
       else s0 := s0 + s[i];
       end
    else if state = 'String' then
      case s[i] of
      '"': if isQuote then
           begin
             s0 := s0 + '"';
             inc(qcnt);
             isQuote := false;
           end
           else
           if s[i+1] = '"' then
             isQuote := true
           else
           begin
             inc(cnt);
             tok[cnt] := state + ':' + s0;
             if s0 <> '' then
               inc(scnt);
             s0 := '';
             state := 'Normal';
           end;
      '.': begin
             inc(cnt);
             tok[cnt] := 'Err'+state + ':' + s0;
             if s0 <> '' then
               inc(scnt);
             inc(escnt);
             s0 := '';
             state := 'Fin';
           end;
       else s0 := s0 + s[i];
       end
    else if state = 'Comm' then
      case s[i] of
      '}': begin
             inc(cnt);
             tok[cnt] := state + ':' + s0;
             if s0 <> '' then
               inc(ccnt);
             s0 := '';
             state := 'Normal';
           end;
      '.': begin
             inc(cnt);
             tok[cnt] := 'Err'+state + ':' + s0;
             if s0 <> '' then
               inc(ccnt);
             inc(eccnt);
             s0 := '';
             state := 'Fin';
           end;
       else s0 := s0 + s[i];
       end;
 end;
until (ncnt * scnt * ccnt * qcnt > 0) and (escnt >= esmin) and (eccnt >= ecmin);
DataS('', s, 0, 1);
for i := 1 to cnt do
begin
  inc(y);
  ResultS('', tok[i], 0, y);
end;

end;

(*
procedure Pat10a;
var i, j: integer;
    bcount: integer;
    s: string;
    state: string;
    res: array[1..100] of string;
    b: array[1..10] of integer;
    bres: boolean;
begin
  CreateTask(Subgroup2);
TaskText(
'\BState\b (\BСостояние\b)~\= паттерн поведения.'#13+
'\P\SЗадание 2\s. Реализовать набор классов, связанных с упрощенной моделью'#13+
'автомата по продаже шариков (balls).'#13+
'\PИерархия классов-состояний включает абстрактный класс State с абстрактными'#13+
'методами, описывающими возможные действия с автоматом~\= InsertCoin (вложить'#13+
'монетку), GetBall (получить шарик), AddBall (добавить шарик в автомат)~\='#13+
'и набор конкретных классов, соответствующих различным возможным состояниям'#13+
'автомата: ReadyState (автомат содержит шарики и готов к приему монетки),'#13+
'HasPayedState (автомат получил монетку и готов выдать шарик), NoBallState'#13+
'(в автомате отсутствуют шарики).'#13+
'\PКаждый конкретный класс содержит поле machine~\= ссылку на объект типа'#13+
'BallMachine; это поле инициализируется в конструкторе, имеющем одноименный'#13+
'параметр. Все переопределенные методы в каждом конкретном классе выводят,'#13+
'как правило, соответствующее текстовое сообщение и, возможно, изменяют'#13+
'состояние автомата, вызывая для объекта machine его метод SetState'#13+
'с подходящим параметром. Исключение составляет метод AddBall, для которого'#13+
'вывод сообщения выполняется в одноименном методе самого класса BallMachine.'#13+
'Ниже перечисляются действия всех методов для конкретных классов-состояний.'#13+
'\PКласс ReadyState: \P\X~метод InsertCoin выводит текст \<Coin is inserted\> (монетка'#13+
'получена) и переводит автомат в состояние HasPayedState; \P\X~метод GetBall'#13+
'выводит текст \<You need to pay first\> (вначале заплатите); \P\X~метод AddBall'#13+
'не выполняет никаких действий.'#13+
'\PКласс HasPayedState: \P\X~метод InsertCoin выводит текст \<You have already paid\>'#13+
'(вы уже заплатили); \P\X~метод AddBall, как и для предыдущего класса,'#13+
'не выполняет никаких действий; \P\X~метод GetBall выводит текст \<Take your ball\>'#13+
'(получите ваш шарик) и, кроме того, вызывает метод DecreaseBallCount объекта'#13+
'machine и анализирует его возвращаемое значение (равное оставшемуся количеству'#13+
'шариков): если это значение больше нуля, то автомат переводится в состояние'#13+
'ReadyState, в противном случае автомат переводится в состояние NoBallState.'#13+
'\PКласс NoBallState: \P\X~методы InsertCoin и GetBall выводят текст \<Sorry,'#13+
'balls are over\> (извините, шарики закончились); \P\X~метод AddBall переводит'#13+
'автомат в состояние ReadyState и не выводит сообщений.'#13+
'\PКласс BallMachine содержит поле ballCount целого типа (равное текущему'#13+
'количеству шариков), поля ready, hasPayed и noBall типа State (в которых'#13+
'содержатся ссылки на соответствующие объекты-состояния), а также поле'#13+
'currentState типа State (в котором содержится ссылка на текущее состояние).'#13+
'Поля инициализируются в конструкторе без параметров; полю ballCount'#13+
'присваивается значение 3, а для полей ready, hasPayed и noBall вызываются'#13+
'конструкторы с параметром~\= ссылкой на создаваемый объект типа BallMachine.'#13+
'Кроме того, в конструкторе выполняется присваивание полю currentState'#13+
'значения ready.'#13+
'\PКласс BallMachine содержит методы InsertCoin, GetBall, AddBall, в которых'#13+
'выполняется вызов одноименных методов объекта currentState; в методе AddBall'#13+
'дополнительно выводится текст \<Ball is added\> (шарик добавлен) и выполняется'#13+
'увеличение на~1 поля ballCount. В классе также реализован метод'#13+
'DecreaseBallCount без параметров, который уменьшает на~1 поле ballCount'#13+
'и возвращает новое значение этого поля (метод DecreaseBallCount используется'#13+
'в методе GetBall класса HasPayedState), и метод SetState(newState), который'#13+
'присваивает полю currentState значение параметра newState. Для доступа'#13+
'на чтение к полям ready, hasPayed и noBall реализованы методы GetReadyState,'#13+
'GetHasPayedState и GetNoBallState, возвращающие ссылки на эти поля'#13+
'(данные методы, совместно с методом SetState, используются в методах'#13+
'классов-состояний для изменения состояния объекта BallMachine).'#13+
TestHeader+
'Дана строка S, содержащая только символы \<I\>, \<G\>, \<A\>; каждый символ'#13+
'соответствует одной из команд автомата BallMachine: \<I\>~\= InsertCoin,'#13+
'\<G\>~\= GetBall, \<A\>~\= AddBall. Создать объект типа BallMachine и вызвать'#13+
'для него набор команд, соответствующий символам исходной строки S в порядке'#13+
'их следования в строке. Выводить какие-либо результаты не требуется,'#13+
'так как вывод осуществляется в методах, реализующих команды автомата.'
);

repeat
for j := 1 to 10 do
  b[j] := 0;
s := '';
bcount := 3;
for i := 1 to Random(11)+60 do
  case Random(3) of
  0: s := s + 'I';
  1: s := s + 'G';
  2: s := s + 'A';
  end;
state := 'Ready';
for i := 1 to Length(s) do
begin
  if state = 'Ready' then
    case s[i] of
    'I': begin
           res[i] := 'Coin is inserted';
           state := 'HasPayed';
           Inc(b[1]);
         end;
    'G': begin
           res[i] := 'You need to pay first';
           Inc(b[2]);
         end;
    'A': begin
           Inc(bcount);
           res[i] := 'Ball is added';
           Inc(b[3]);
         end;
    end
  else if state = 'HasPayed' then
    case s[i] of
    'I': begin
           res[i] := 'You have already paid';
           Inc(b[4]);
         end;
    'G': begin
           res[i] := 'Take your ball';
           Dec(bcount);
           if bcount = 0 then
           begin
             state := 'NoBalls';
             Inc(b[5]);
           end
           else
           begin
             state := 'Ready';
             Inc(b[6]);
           end;
         end;
    'A': begin
           Inc(bcount);
           res[i] := 'Ball is added';
           Inc(b[7]);
         end;
    end
  else
    case s[i] of
    'I': begin
           res[i] := 'Sorry, balls are over';
           Inc(b[8]);
         end;
    'G': begin
           res[i] := 'Sorry, balls are over';
           Inc(b[9]);
         end;
    'A': begin
           Inc(bcount);
           res[i] := 'Ball is added';
           state := 'Ready';
           Inc(b[10]);
         end;
    end
end;
bres := true;
for j := 1 to 10 do
  if b[j] = 0 then
  begin
    bres := false;
    break;
  end;
until bres;

DataS('S: ', s, 0, 1);
for i := 1 to length(s) do
  ResultS('', res[i], 0, i);


end;
*)


procedure Pat10;
var i, j: integer;
    bcount: integer;
    s: string;
    state: string;
    res: array[1..100] of string;
    b: array[1..13] of integer;
    bres: boolean;
begin
  CreateTask(Subgroup2);
TaskText(
'\BState\b (\BСостояние\b)~\= паттерн поведения.'#13+
'\P\SЗадание 2\s. Реализовать набор классов, связанных с моделированием'#13+
'работы автомата по продаже шариков (ball machine).'#13+
'\PИерархия классов-состояний включает абстрактный класс \MState\m с абстрактными'#13+
'методами, описывающими возможные действия с автоматом~\= \MInsertCoin\m (вложить'#13+
'монетку), \MGetBall\m (получить шарик), \MReturnCoin\m (вернуть монетку), \MAddBall\m'#13+
'(добавить шарик в автомат)~\= и набор конкретных классов, соответствующих'#13+
'различным возможным состояниям автомата: \MReadyState\m (автомат содержит шарики'#13+
'и готов к приему монетки), \MHasPayedState\m (автомат получил монетку и готов'#13+
'выдать шарик или вернуть монетку), \MNoBallState\m (в автомате нет шариков).'#13+
'Все методы не имеют параметров и не возвращают значения.'#13+
'\PКаждый конкретный класс содержит поле \Mmachine\m~\= ссылку на объект типа'#13+
'\MBallMachine\m; это поле инициализируется в конструкторе, имеющем одноименный'#13+
'параметр. Все переопределенные методы в каждом конкретном классе могут'#13+
'выводить соответствующее текстовое сообщение, изменять состояние автомата,'#13+
'вызывая для объекта \Mmachine\m его метод \MSetState\m с подходящим параметром,'#13+
'и выполнять другие действия. Ниже перечисляются действия всех методов'#13+
'для конкретных классов-состояний.'#13+
'\PКласс \MReadyState\m: \P\X~метод \MInsertCoin\m выводит текст \<Coin is inserted\> (монетка'#13+
'получена) и переводит автомат в состояние \MHasPayedState\m; \P\X~методы \MGetBall\m'#13+
'и \MReturnCoin\m выводят текст \<You need to pay first\> (вначале заплатите);'#13+
'\P\X~метод \MAddBall\m не выполняет никаких действий.'#13+
'\PКласс \MHasPayedState\m: \P\X~метод \MInsertCoin\m выводит текст \<You have already paid\>'#13+
'(вы уже заплатили); \P\X~метод \MReturnCoin\m выводит текст \<Take your coin\>'#13+
'(получите вашу монетку) и переводит автомат в состояние \MReadyState\m;'#13+
'\P\X~метод \MAddBall\m, как и для предыдущего класса, не выполняет никаких действий;'#13+
'\P\X~метод \MGetBall\m выводит текст \<Take your ball\> (получите ваш шарик)'#13+
'и, кроме того, вызывает метод \MDecreaseBallCount\m объекта \Mmachine\m и анализирует'#13+
'его возвращаемое значение (равное оставшемуся количеству шариков):'#13+
'если это значение больше нуля, то автомат переводится в состояние \MReadyState\m,'#13+
'в противном случае автомат переводится в состояние \MNoBallState\m.'#13+
'\PКласс \MNoBallState\m: \P\X~методы \MInsertCoin\m, \MGetBall\m и \MReturnCoin\m выводят текст'#13+
'\<Sorry, balls are over\> (извините, шарики закончились); \P\X~метод \MAddBall\m'#13+
'переводит автомат в состояние \MReadyState\m и не выводит сообщений.'#13+
'\PКласс \MBallMachine\m содержит поле \MballCount\m целого типа (равное текущему'#13+
'количеству шариков), поля \Mready\m, \MhasPayed\m и \MnoBall\m типа \MState\m (в которых'#13+
'содержатся ссылки на соответствующие объекты-состояния), а также поле'#13+
'\McurrentState\m типа \MState\m (в котором содержится ссылка на текущее состояние).'#13+
'Поля инициализируются в конструкторе без параметров; полю \MballCount\m'#13+
'присваивается значение~3, а для инициализации полей \Mready\m, \MhasPayed\m и \MnoBall\m'#13+
'используются конструкторы соответствующих классов с параметром~\= ссылкой'#13+
'на создаваемый объект типа \MBallMachine\m. Кроме того, в конструкторе выполняется'#13+
'присваивание полю \McurrentState\m значения \Mready\m.'#13+
'\PКласс \MBallMachine\m содержит методы \MInsertCoin\m, \MGetBall\m, \MReturnCoin\m, \MAddBall\m,'#13+
'в которых выполняется вызов одноименных методов объекта \McurrentState\m;'#13+
'в методе \MAddBall\m дополнительно выводится текст \<Ball is added\> (шарик'#13+
'добавлен) и выполняется увеличение на~1 поля \MballCount\m. В классе также надо'#13+
'реализовать метод \MDecreaseBallCount\m без параметров, который уменьшает на~1'#13+
'поле \MballCount\m и возвращает новое значение этого поля (метод \MDecreaseBallCount\m'#13+
'используется в методе \MGetBall\m класса \MHasPayedState\m), и метод'#13+
'\MSetState(newState)\m, который присваивает полю \McurrentState\m значение параметра'#13+
'\MnewState\m. Для доступа на чтение к полям \Mready\m, \MhasPayed\m и \MnoBall\m надо'#13+
'предусмотреть методы \MGetReadyState\m, \MGetHasPayedState\m и \MGetNoBallState\m'#13+
'(эти методы, совместно с методом \MSetState\m, используются в методах'#13+
'классов-состояний для изменения состояния объекта \MBallMachine\m).'#13+
TestHeader+
'Дана строка {S}, содержащая только символы \<I\>, \<G\>, \<R\>, \<A\>; каждый символ'#13+
'соответствует одной из команд автомата \MBallMachine\m: \<I\>~\= \MInsertCoin\m,'#13+
'\<G\>~\= \MGetBall\m, \<R\>~\= \MReturnCoin\m, \<A\>~\= \MAddBall\m. Создать объект'#13+
'типа \MBallMachine\m и вызвать для него набор команд, соответствующий символам'#13+
'исходной строки S в порядке их следования в строке. Выводить какие-либо'#13+
'результаты не требуется, так как вывод осуществляется'#13+
'в методах, реализующих команды автомата.'
);

repeat
for j := 1 to 13 do
  b[j] := 0;
s := '';
bcount := 3;
for i := 1 to Random(11)+60 do
  case Random(4) of
  0: s := s + 'I';
  1: s := s + 'G';
  2: s := s + 'A';
  3: s := s + 'R';
  end;
//  s := 'IRR';
state := 'Ready';
for i := 1 to Length(s) do
begin
  if state = 'Ready' then
    case s[i] of
    'I': begin
           res[i] := 'Coin is inserted';
           state := 'HasPayed';
           Inc(b[1]);
         end;
    'G': begin
           res[i] := 'You need to pay first';
           Inc(b[2]);
         end;
    'R': begin
           res[i] := 'You need to pay first';
           Inc(b[11]);
         end;
    'A': begin
           Inc(bcount);
           res[i] := 'Ball is added';
           Inc(b[3]);
         end;
    end
  else if state = 'HasPayed' then
    case s[i] of
    'I': begin
           res[i] := 'You have already paid';
           Inc(b[4]);
         end;
    'R': begin
           res[i] := 'Take your coin';
           state := 'Ready';
           Inc(b[12]);
         end;
    'G': begin
           res[i] := 'Take your ball';
           Dec(bcount);
           if bcount = 0 then
           begin
             state := 'NoBalls';
             Inc(b[5]);
           end
           else
           begin
             state := 'Ready';
             Inc(b[6]);
           end;
         end;
    'A': begin
           Inc(bcount);
           res[i] := 'Ball is added';
           Inc(b[7]);
         end;
    end
  else
    case s[i] of
    'I': begin
           res[i] := 'Sorry, balls are over';
           Inc(b[8]);
         end;
    'R': begin
           res[i] := 'Sorry, balls are over';
           Inc(b[13]);
         end;
    'G': begin
           res[i] := 'Sorry, balls are over';
           Inc(b[9]);
         end;
    'A': begin
           Inc(bcount);
           res[i] := 'Ball is added';
           state := 'Ready';
           Inc(b[10]);
         end;
    end
end;
bres := true;
for j := 1 to 13 do
  if b[j] = 0 then
  begin
    bres := false;
    break;
  end;
until bres;

DataS('S: ', s, 0, 1);
for i := 1 to length(s) do
  ResultS('', res[i], 0, i);


end;

procedure Pat11;
var n, i, j: integer;
    b: array[1..10] of char;
    int: array[1..10] of integer;
    str: array[1..10] of string;
    knum: array[1..10] of integer;
    num: array[1..10,1..10] of integer;
procedure ProcessData(p: integer);
var sum, j, i: integer;
    x: integer;
    a: array [1..50] of integer;
    na: integer;
begin
  sum := 0;
  na := 0;
  case b[p] of
  'A':
  begin
    x := abs(int[p]);
    if x = 0 then
    begin
      na := 1;
      a[1] := 0;
    end
    else
    while x > 0 do
    begin
      inc(na);
      a[na] := x mod 10;
      sum := sum + a[na];
      x := x div 10;
    end;
  end;
  'B':
  begin
    for j := length(str[p]) downto 1 do
      if str[p][j] in ['0'..'9'] then
      begin
        inc(na);
        a[na] := ord(str[p][j]) - 48;
        sum := sum + a[na];
      end;
  end;
  'C':
  begin
    for i := knum[p] downto 1 do
    begin
      x := abs(num[p,i]);
      if x = 0 then
      begin
        inc(na);
        a[na] := 0;
      end
      else
        while x > 0 do
        begin
          inc(na);
          a[na] := x mod 10;
          sum := sum + a[na];
          x := x div 10;
        end;
    end;
  end;
  end;
  ResultN('Сумма: ', sum, 3, n-p+1, 3);
  ResultComment('Цифры: ', 17, n-p+1);
  for j := 1 to na do
    ResultN('', a[j], 22+j*2, n-p+1, 1);
end;
begin
  CreateTask(Subgroup2);
TaskText(
'\G<Graph\OOPIterator.png>\BIterator\b (\BИтератор\b)~\= паттерн поведения.'#13+
'\PИзвестен также под именем \BCursor\b (\BКурсор\b).'#13+
'\P\SЧастота использования\s: высокая.'#13+
'\P\SНазначение\s: предоставляет способ последовательного доступа ко всем элементам'#13+
'составного объекта, не раскрывая его внутреннего представления.'#13+
'\P\SУчастники\s: \P\X~\IIterator\i (\IИтератор\i)~\= определяет интерфейс для доступа и обхода'#13+
'элементов; \P\X~\IConcreteIterator\i (\IКонкретный итератор\i)~\= реализует интерфейс'#13+
'класса Iterator; следит за текущей позицией при обходе агрегата;'#13+
'\P\X~\IAggregate\i (\IАгрегат\i)~\= определяет интерфейс для создания объекта-итератора;'#13+
'\P\X~\IConcreteAggregate\i (\IКонкретный агрегат\i)~\= реализует интерфейс создания'#13+
'итератора и возвращает экземпляр подходящего класса ConcreteIterator.'#13+
'\PВо многих современных языках программирования итераторы реализованы'#13+
'в стандартных библиотеках или даже на уровне языковых конструкций.'#13+
'Данное задание можно выполнять, используя либо базовые средства ООП,'#13+
'либо специализированные средства выбранного языка.'#13+
'\P\SЗадание 1\s. Реализовать две иерархии классов, связанные с применением'#13+
'паттерна Iterator. Первая иерархия является иерархией классов-\Iагрегатов\i'#13+
'и включает абстрактный класс \MAggregate\m, содержащий абстрактный метод'#13+
'\MCreateIterator\m (не имеет параметров, возвращает ссылку на объект \MIterator\m),'#13+
'и классы \MConcreteAggregateA\m, \MConcreteAggregateB\m и \MConcreteAggregateC\m. Каждый'#13+
'из конкретных классов содержит поле \Mdata\m; для класса \MConcreteAggregateA\m оно'#13+
'целочисленное, для класса \MConcreteAggregateB\m оно строковое, для класса'#13+
'\MConcreteAggregateC\m оно представляет собой структуру данных с целочисленными'#13+
'элементами (например, массив; можно считать, что число элементов структуры'#13+
'не превосходит~10). Поле \Mdata\m инициализируется в конструкторе класса с помощью'#13+
'параметра \Mdata\m того же типа, что и инициализируемое поле. \PКонкретные'#13+
'классы-агрегаты~A,~B и~C реализуют метод \MCreateIterator\m возвращающий итератор,'#13+
'тип которого определяется типом класса-агрегата: для агрегата~A это'#13+
'\MConcreteIteratorA\m, для агрегата~B~\= \MConcreteIteratorB\m, для агрегата~C~\='#13+
'\MConcreteIteratorC\m. При создании итератора в методе \MCreateIterator\m'#13+
'конструктору итератора передается параметр, являющийся ссылкой'#13+
'на объект-агрегат, вызвавший метод \MCreateIterator\m. Классы-агрегаты также'#13+
'имеют метод \MGetData\m без параметров, возвращающий поле \Mdata\m.'#13+
'\PВторая иерархия является иерархией классов-\Iитераторов\i; она включает'#13+
'абстрактный класс \MIterator\m и классы \MConcreteIteratorA\m, \MConcreteIteratorB\m'#13+
'и \MConcreteIteratorC\m. Класс \MIterator\m содержит четыре абстрактных метода'#13+
'без параметров: \MFirst\m и \MNext\m (не возвращают значений), \MIsDone\m (возвращает'#13+
'логическое значение), \MCurrentItem\m (возвращает целочисленное значение):'#13+
'\P\X метод \MFirst\m устанавливает итератор на первый элемент перебираемого набора'#13+
'данных; \P\X метод \MNext\m переводит итератор на следующий элемент (или за конец'#13+
'набора); \P\X метод \MIsDone\m возвращает значение \M\t\m, если итератор указывает'#13+
'на позицию за концом набора, и \M\f\m, если итератор указывает на некоторый'#13+
'элемент набора; \P\X метод \MCurrentItem\m возвращает элемент набора, на который'#13+
'указывает итератор, или~\-1, если итератор находится за последним элементом'#13+
'набора (возможен также вариант, когда в последней ситуации возбуждается'#13+
'исключение, поскольку в программе такая ситуация обычно свидетельствует'#13+
'об ошибке). \PДля пустого набора метод \MFirst\m сразу устанавливает итератор'#13+
'за конец набора; при нахождении итератора за концом набора метод \MNext\m'#13+
'не выполняет никаких действий.'#13+
'\PКонкретные классы-итераторы~A, B,~C связаны с ранее описанными'#13+
'классами-агрегатами~A, B,~C и обеспечивают особый способ перебора содержащихся'#13+
'в них данных: \P\X итератор~A перебирает все \Iцифры\i целочисленного поля \Mdata\m'#13+
'агрегата~A \Iв обратном порядке\i (знак числа игнорируется); для числа~0'#13+
'возвращается цифра~0 (это единственная ситуация, когда последним элементом'#13+
'набора является цифра~0); \P\X итератор~B перебирает все \Iцифровые символы\i'#13+
'строкового поля \Mdata\m агрегата B \Iв обратном порядке\i; \P\X итератор C перебирает'#13+
'все цифры всех элементов структуры \Mdata\m агрегата~C, причем как сами элементы,'#13+
'так и их цифры должны перебираться \Iв обратном порядке\i. \PДля итераторов~B и~C'#13+
'возможна ситуация, когда перебираемый набор является пустым (если строковое'#13+
'поле \Mdata\m не содержит цифровых символов или структура \Mdata\m не содержит'#13+
'ни одного элемента с цифровыми символами). Каждый конкретный итератор содержит'#13+
'поле \Maggr\m, которое является ссылкой на связанный с ним объект-агрегат;'#13+
'это поле инициализируется в конструкторе итератора с помощью соответствующего'#13+
'параметра. Кроме того, итераторы содержат вспомогательные поля, используемые'#13+
'при реализации методов \MFirst\m, \MNext\m, \MIsDone\m и \MCurrentItem\m.'#13+
TestHeader+
'Дано целое число~{N} (\l\,10) и {N}~наборов элементов. Первый элемент каждого'#13+
'набора представляет собой символ \<A\>, \<B\> или \<C\>; он определяет тип'#13+
'создаваемого объекта-агрегата (A,~B или~C). Следующие элементы каждого набора'#13+
'определяют поле \Mdata\m создаваемого агрегата: для агрегата~A это одно целое'#13+
'число, для агрегата~B~\= одна строка, для агрегата~C~\= целое число~{K} (\l\,10),'#13+
'определяющее размер структуры данных \Mdata\m, и {К}~целых чисел~\='#13+
'элементов этой структуры (число~{K} может быть равно~0).'#13+
'\PСоздать коллекцию (например, массив) из {N}~элементов-ссылок типа \MAggregate\m,'#13+
'сохранить в ней исходные объекты-агрегаты и выполнить обработку этих объектов,'#13+
'перебирая их \Iв обратном порядке\i. Обработка каждого объекта-агрегата состоит'#13+
'из двух этапов и выполняется с применением соответствующего итератора: вначале'#13+
'требуется вывести сумму цифр, возвращаемых итератором (или~0, если итератор'#13+
'ничего не возвращает), а затем~\= сами цифры, возвращаемые итератором.'#13+
'\P\SПримечание\s. В языках с С-подобным синтаксисом (в частности, C++, C#, Java)'#13+
'для перебора элементов с применением итератора \Mit\m, имеющего описанный выше'#13+
'набор методов, можно использовать следующий вариант цикла \Mfor\m:'#13+
'\P\Mfor (it.First(); !it.IsDone(); it.Next()) <обработка it.CurrentItem()>\m'
);
n := Random(5) + 6;
b[1] := 'A';
b[2] := 'B';
b[3] := 'C';
for i := 4 to n do
  b[i] := chr(Random(3)+65);
for i := 1 to n do
  SwapC(b[Random(n) + 1],b[Random(n) + 1]);
for i := 1 to n do
begin
  case Random(3) of
  0: int[i] := 0;
  1: int[i] := Random(100);
  2: int[i] := Random(1000000000);
  end;
  if Random(2) = 0 then
    int[i] := -int[i];
  str[i] := '';
  for j := 1 to Random(7) + 7 do
    str[i] := str[i] + chr(Random(26) + 97);
  case Random(3) of
  1,2: begin
         for j := 1 to Random(4) + 2 do
           insert(chr(Random(10) + 48), str[i], Random(length(str[i])) + 1);
       end;
  end;     
  case Random(3) of
  0: knum[i] := 0;
  1,2: knum[i] := Random(6) + 4;
  end;
  for j := 1 to knum[i] do
  begin
    case Random(4) of
    0: num[i,j] := 0;
    1,2: num[i,j] := Random(1000);
    3:   num[i,j] := -Random(100);
    end;
  end;
end;
DataN('N = ', n, 0, 1, 1);
for i := 1 to n do
begin
  DataC('', b[i], 20, i+1);
  case b[i] of
  'A': DataN('', int[i], 25, i+1, 1);
  'B': DataS('', str[i], 25, i+1);
  'C': begin
         DataN('K = ', knum[i], 25, i + 1, 1);
         for j := 1 to knum[i] do
           DataN('', num[i,j], 28 + j*5, i+1, 3);
       end;
  end;
end;
for i := n downto 1 do
begin
  ProcessData(i);
end;


end;



procedure Pat12;
var n, i, j, sum, y: integer;
    b: array[1..10] of char;
    int: array[1..10] of integer;
    str: array[1..10] of string;
    dbl: array[1..10] of real;
    resa: integer;
    resb: string;
    resc: real;
procedure ProcessData(y: integer);
var i: integer;
begin
  for i := 1 to n do
  case b[i] of
  'A':  ResultN('', int[i], Center(i, n, 6, 1), y, 6);
  'B':  ResultS('', str[i], Center(i, n, 6, 1), y);
  'C':  ResultR('', dbl[i], Center(i, n, 6, 1), y, 6);
  end;
end;
function Rev(s: string): string;
var i: integer;
begin
  result := '';
  for i := length(s) downto 1 do
    result := result + s[i];
end;
begin
  CreateTask(Subgroup3);
TaskText(
'\G<Graph\OOPVisitor.png>\BVisitor\b (\BПосетитель\b)~\= паттерн поведения.'#13+
'\P\SЧастота использования\s: низкая.'#13+
'\P\SНазначение\s: описывает операцию, выполняемую с каждым объектом из некоторой'#13+
'структуры. Паттерн Visitor позволяет определить новую операцию, не изменяя'#13+
'классы этих объектов и используя различные варианты операции для объектов'#13+
'различных типов, входящих в одну структуру.'#13+
'\P\SУчастники\s: \P\X~\IVisitor\i (\IПосетитель\i)~\= объявляет группу методов Visit,'#13+
'в которой для каждого класса ConcreteElement в структуре объектов предусмотрен'#13+
'свой метод; имя метода (например, VisitConcreteElementA) и его параметр'#13+
'идентифицируют объект, который вызывает данный метод для отправки посетителю'#13+
'соответствующего запроса (это позволяет посетителю определить, элемент какого'#13+
'конкретного класса он посещает, и обращаться к элементу напрямую через'#13+
'его интерфейс); \P\X~\IConcreteVisitor1\i, \IConcreteVisitor2\i (\IКонкретные посетители\i)~\='#13+
'реализуют все операции, объявленные в классе Visitor и связанные с обработкой'#13+
'объектов различных типов, содержащихся в обрабатываемой структуре;'#13+
'\P\X~\IElement\i (\IЭлемент\i)~\= определяет метод Accept, который принимает посетителя'#13+
'в качестве аргумента; \P\X~\IConcreteElementA\i, \IConcreteElementB\i (\IКонкретные\i'#13+
'\Iэлементы\i)~\= реализуют метод Accept, принимающий посетителя как аргумент (как'#13+
'правило, в этом методе происходит вызов того метода из группы методов Visit'#13+
'указанного посетителя, который соответствует данному конкретному элементу);'#13+
'\P\X~\IObjectStructure\i (\IСтруктура объектов\i)~\= может перечислять свои элементы,'#13+
'а также предоставлять посетителю высокоуровневый интерфейс'#13+
'для посещения своих элементов.'#13+
'\PСовместное использование методов Accept и группы методов Visit в паттерне'#13+
'Visitor обеспечивает \Iдвойную диспетчеризацию\i запросов, при которой'#13+
'характер запроса определяется двумя объектами: конкретным посетителем'#13+
'и конкретным элементом. Двойная диспетчеризация позволяет посетителю'#13+
'по-разному обрабатывать элементы различных классов.'#13+
'\PПрименение паттерна Visitor оправдано, если иерархия классов-элементов'#13+
'является стабильной (т.\,е. в нее редко добавляются новые классы) и при этом'#13+
'часто возникает необходимость в новых операциях, которые требуется по-разному'#13+
'выполнять для элементов различных типов.'#13+
'\P\SЗадание 1\s. Реализовать две иерархии классов, связанные с применением'#13+
'паттерна Visitor. Первая иерархия является иерархией классов-\Iэлементов\i'#13+
'и включает абстрактный класс \MElement\m, содержащий абстрактный метод \MAccept\m'#13+
'с параметром-ссылкой типа \MVisitor\m (не возвращает результата), и конкретные'#13+
'классы \MConcreteElementA\m, \MConcreteElementB\m, \MConcreteElementC\m. Каждый конкретный'#13+
'класс содержит поле \Mdata\m; для класса \MConcreteElementA\m оно целочисленное,'#13+
'для класса \MConcreteElementB\m оно строковое, для класса \MConcreteElementC\m оно'#13+
'является вещественным числом. Поле \Mdata\m инициализируется в конструкторе класса'#13+
'с помощью параметра \Mdata\m того же типа, что и инициализируемое поле. Конкретные'#13+
'классы-элементы~A,~B и~C реализуют метод \MAccept(v)\m, в котором для параметра~\Mv\m'#13+
'типа \MVisitor\m выполняется вызов соответствующего метода класса \MVisitor\m,'#13+
'определяемого типом класса-элемента: для элемента~A это \MVisitConcreteElementA\m,'#13+
'для элемента~B~\= \MVisitConcreteElementB\m, для элемента C~\= \MVisitConcreteElementC\m'#13+
'(параметром методов \MVisit\m является ссылка на объект,'#13+
'вызвавший метод \MAccept\m).'#13+
'\PКроме того, классы-элементы имеют методы для доступа на чтение и запись'#13+
'к полю \Mdata\m: метод \MGetData\m без параметров возвращает значение поля \Mdata\m,'#13+
'метод \MSetData\m с параметром \MnewData\m изменяет значение поля \Mdata\m на значение'#13+
'параметра \MnewData\m. Следует подчеркнуть, что методы \MGetData\m и \MSetData\m являются'#13+
'\Iспецифическими\i для каждого конкретного класса-элемента (в данном случае'#13+
'это аналоги специфических методов OperationA и OperationB,'#13+
'приведенных на диаграмме классов).'#13+
'\PС иерархией классов-элементов также связан класс \MObjectStructure\m.'#13+
'Поле \Mstruc\m этого класса является структурой данных (например, массивом)'#13+
'с элементами-ссылками на объекты типа \MElement\m (можно считать, что число'#13+
'элементов структуры \Mstruc\m не превосходит~10). Поле \Mstruc\m инициализируется'#13+
'в конструкторе с помощью параметра \Mstruc\m того же типа. Класс \MObjectStructure\m'#13+
'содержит метод \MAccept(v)\m с параметром-ссылкой типа \MVisitor\m. Этот метод'#13+
'перебирает все элементы структуры \Mstruc\m и для каждого элемента'#13+
'вызывает его метод \MAccept\m с параметром \Mv\m.'#13+
'\PВторая иерархия является иерархией классов-\Iпосетителей\i, связанных с ранее'#13+
'описанными конкретными классами. Она включает абстрактный класс \MVisitor\m'#13+
'и конкретные классы \MConcreteVisitor1\m, \MConcreteVisitor2\m и \MConcreteVisitor3\m.'#13+
'Класс \MVisitor\m содержит три абстрактных метода: \MVisitConcreteElementA(e)\m,'#13+
'\MVisitConcreteElementB(e)\m, \MVisitConcreteElementC(e)\m. Эти методы не возвращают'#13+
'значений; их параметрами являются ссылки на соответствующие объекты-элементы'#13+
'(например, \MVisitConcreteElementA\m имеет параметр типа \MConcreteElementA\m).'#13+
'Напомним, что именно эти методы должны вызываться в методе \MAccept\m'#13+
'каждого конкретного класса-элемента.'#13+
'\PКонкретные классы-посетители~1, 2,~3 реализуют различные наборы'#13+
'операций, связанных с классами-элементами~A, B,~C, определяя методы'#13+
'\MVisitConcreteElementA(e)\m, \MVisitConcreteElementB(e)\m, \MVisitConcreteElementC(e)\m:'#13+
'\P\X класс \MConcreteVisitor1\m \Iвыводит\i поля \Mdata\m в окно задачника, вызывая'#13+
'в каждом из указанных методов соответствующую команду вывода для значения'#13+
'\MGetData\m элемента~\Me\m; \P\X класс \MConcreteVisitor2\m \Iпреобразует\i поле \Mdata\m различным'#13+
'образом для разных элементов, используя методы \MGetData\m и \MSetData\m элемента~\Me\m:'#13+
'для элементов типа~A он изменяет знак целого числа \Mdata\m на противоположный,'#13+
'для элементов типа~B он изменяет порядок следования символов строки \Mdata\m'#13+
'на противоположный, для элементов типа~C он изменяет любое ненулевое'#13+
'вещественное число \Mdata\m на обратное к нему (равное \M1/data\m); \P\X класс'#13+
'\MConcreteVisitor3\m определяет некоторую \Iобщую характеристику\i для всех однотипных'#13+
'элементов обрабатываемой структуры: для элементов типа~A определяется сумма'#13+
'их целочисленных полей \Mdata\m, для элементов типа~B находится строка, получаемая'#13+
'сцеплением всех строковых полей \Mdata\m, для элементов типа~C находится'#13+
'произведение вещественных полей \Mdata\m. \PВ классе \MConcreteVisitor3\m надо'#13+
'предусмотреть дополнительные поля \MresultA\m, \MresultB\m, \MresultC\m для хранения'#13+
'полученных характеристик и методы \MGetResultA\m, \MGetResultB\m, \MGetResultC\m,'#13+
'возвращающие значения этих полей. Конструкторы объектов-посетителей'#13+
'не имеют параметров и не выполняют дополнительных действий.'#13+
TestHeader+
'Дано целое число~{N} (\l\,10) и набор из {N}~пар значений. Первое поле каждой пары'#13+
'является символом \<A\>, \<B\> или \<C\>; оно определяет тип создаваемого'#13+
'объекта-элемента (A,~B или~C). Второе поле каждой пары определяет значение'#13+
'поля \Mdata\m создаваемого элемента: для элемента типа~A это целое число,'#13+
'для элемента типа~B~\= строка, для элемента типа~C~\= вещественное число.'#13+
'\PСоздать объект~\Ms\m типа \MObjectStructure\m и поместить в него все исходные'#13+
'элементы. Также создать три объекта-посетителя~\Mv1\m, \Mv2\m,~\Mv3\m типа'#13+
'\MConcreteVisitor1\m, \MConcreteVisitor2\m, \MConcreteVisitor3\m соответственно.'#13+
'Вывести содержимое объекта-структуры~\Ms\m, используя вызов его метода \MAccept(v1)\m,'#13+
'после чего преобразовать это содержимое, используя вызов \MAccept(v2)\m,'#13+
'и вывести преобразованное содержимое с помощью еще одного вызова \MAccept(v1)\m.'#13+
'Затем вызвать метод \MAccept(v3)\m и вывести найденные в нем характеристики'#13+
'элементов структуры~\Ms\m с помощью методов \MGetResultA\m, \MGetResultB\m'#13+
'и \MGetResultC\m объекта~\Mv3\m.'
);

n := 10;//Random(5) + 6;
repeat
sum := 0;
b[1] := 'A';
b[2] := 'B';
b[3] := 'C';
for i := 4 to n do
  b[i] := chr(Random(3)+65);
for i := 1 to n do
  SwapC(b[Random(n) + 1],b[Random(n) + 1]);
for i := 1 to n do
begin
  int[i] := Random(100);
  if Random(2) = 0 then
    int[i] := -int[i];
  str[i] := '';
  for j := 1 to Random(3) + 3 do
    str[i] := str[i] + chr(Random(26) + 97);
  if b[i] = 'B' then
    sum := sum + length(str[i]);
  dbl[i] := Random*9 + 1;
  if Random(2) = 0 then
    dbl[i] := -dbl[i];
end;
until sum <= 30;
DataN('N = ', n, 0, 1, 1);
for i := 1 to n do
begin
  DataC('', b[i], 37, i+1);
  case b[i] of
  'A': DataN('', int[i], 41, i+1, 3);
  'B': DataS('', str[i], 41, i+1);
  'C': DataR('', dbl[i], 41, i+1, 5);
  end;
end;
ProcessData(1);
resa := 0;
resb := '';
resc := 1;
for i := 1 to n do
begin
  int[i] := - int[i];
  str[i] := Rev(str[i]);
  dbl[i] := 1/dbl[i];
  case b[i] of
  'A': resa := resa + int[i];
  'B': resb := resb + str[i];
  'C': resc := resc * dbl[i];
  end;
end;
ProcessData(2);
y := length(resb) div 2;
ResultN('', resa, 39-y-8, 3, 4);
ResultS('', resb, 0, 3);
SetPrecision(6);
ResultR('', resc, 41+y+4, 3, 9);
end;

procedure Pat13;
var n, i, k: integer;
    ac1, bc1a, bc1b: integer;
    ac2, bc2: string;

procedure SetCount(c: string; var a, b: integer);
var i: integer;
begin
  a := 0;
  b := 0;
  for i := 1 to Length(c) do
    if c[i] = 'a' then
      inc(a)
    else if c[i] = 'b' then
      inc(b);
end;

begin
  CreateTask(Subgroup3);
TaskText(
'\G<Graph\OOPMediator.png>\BMediator\b (\BПосредник\b)~\= паттерн поведения.'#13+
'\P\SЧастота использования\s: ниже средней.'#13+
'\P\SНазначение\s: определяет объект, инкапсулирующий способ взаимодействия множества'#13+
'объектов. Посредник обеспечивает слабую связанность системы, избавляя объекты'#13+
'от необходимости явно ссылаться друг на друга и позволяя тем самым независимо'#13+
'изменять способы взаимодействия между ними.'#13+
'\P\SУчастники\s: \P\X~\IMediator\i (\IПосредник\i)~\= определяет интерфейс для обмена'#13+
'информацией с объектами Colleague; \P\X~\IConcreteMediator\i (\IКонкретный посредник\i)~\='#13+
'реализует кооперативное поведение, координируя действия объектов Colleague;'#13+
'владеет информацией о коллегах; \P\X~\IColleague\i (\IКоллега\i)~\= определяет интерфейс'#13+
'для взаимодействия с посредником; \P\X~\IConcreteColleague1\i, \IConcreteColleague2\i'#13+
'(\IКонкретные коллеги\i)~\= знают о своем объекте Mediator; обмениваются'#13+
'информацией только с посредником (вместо того, чтобы общаться'#13+
'между собой напрямую).'#13+
'\PПосредник реализует кооперативное поведение путем переадресации каждого'#13+
'запроса, посланного ему каким-либо коллегой, подходящему коллеге'#13+
'(одному или нескольким).'#13+
'\P\SЗадание 1\s. Реализовать две иерархии классов, связанные с применением'#13+
'паттерна Mediator. Первая иерархия является иерархией классов-\Iколлег\i'#13+
'и включает абстрактный класс \MColleague\m и конкретные классы'#13+
'\MConcreteColleague1\m и \MConcreteColleague2\m.'#13+
'\PКласс \MColleague\m содержит поле \Mm\m, являющееся ссылкой на связанный с данным'#13+
'коллегой объект \MMediator\m, и методы \MSetMediator(m)\m (не возвращает значения,'#13+
'инициализирует поле~\Mm\m одноименным параметром метода, также имеющим тип'#13+
'\MMediator\m) и \MNotify\m (не имеет параметров и не возвращает значения, извещает'#13+
'посредник~\Mm\m о наступлении события путем вызова метода \MNotifyFrom\m объекта~\Mm\m,'#13+
'причем в качестве параметра метода \MNotifyFrom\m передается ссылка на объект,'#13+
'вызвавший метод \MNotify\m). В методе \MNotify\m перед вызовом метода \MNotifyFrom\m'#13+
'можно проверять, что поле~\Mm\m не является пустой ссылкой, хотя при согласованной'#13+
'работе коллег и посредников такая ситуация не должна возникать. Методы'#13+
'\MSetMediator\m и \MNotify\m не являются абстрактными, они реализуются в классе'#13+
'\MColleague\m и наследуются всеми подклассами без каких-либо изменений.'#13+
'\PКласс \MConcreteColleague1\m дополнительно содержит целочисленное поле \Mdata\m'#13+
'(инициализируется в конструкторе значением~1), класс \MConcreteColleague2\m'#13+
'содержит строковое поле \Mdata\m (инициализируется в конструкторе строкой~\<ab\>).'#13+
'Конкретные классы также содержат методы \MGetData\m и \MSetData\m, позволяющие'#13+
'обращаться к полю \Mdata\m на чтение и запись соответственно. Конструкторы классов'#13+
'\MConcreteColleague1\m и \MConcreteColleague2\m не имеют параметров.'#13+
'\PВторая иерархия является иерархией классов-\Iпосредников\i, связанных с ранее'#13+
'описанными классами-коллегами. Она включает абстрактный класс \MMediator\m'#13+
'и конкретные классы \MConcreteMediatorA\m и \MConcreteMediatorB\m. Класс \MMediator\m'#13+
'содержит абстрактный метод \MNotifyFrom(coll)\m, имеющий параметр-ссылку типа'#13+
'\MColleague\m и не возвращающий значений. Этот метод информирует посредник'#13+
'о событии, наступившем в объекте \Mcoll\m. Напомним, что именно этот метод'#13+
'должен вызываться в методе \MNotify\m каждого конкретного класса-коллеги.'#13+
'\PКлассы \MConcreteMediatorA\m и \MConcreteMediatorB\m реализуют два различных сценария'#13+
'взаимодействия объектов типа \MConcreteColleague1\m и \MConcreteColleague2\m. Они'#13+
'создают набор взаимодействующих коллег, позволяют получать ссылки на них'#13+
'и обрабатывают связанные с ними события, изменяя состояние других коллег.'#13+
'Конструкторы классов \MConcreteMediatorA\m и \MConcreteMediatorB\m'#13+
'не имеют параметров.'#13+
'\PКласс \MConcreteMediatorA\m содержит поля \Mc1\m (типа \MConcreteColleague1\m) и \Mc2\m'#13+
'(типа \MConcreteColleague2\m). Объекты \Mс1\m и \Mc2\m создаются в конструкторе класса'#13+
'\MConcreteMediatorA\m и связываются с объектом-посредником путем вызова методов'#13+
'\MSetMediator\m (с параметром, являющимся ссылкой на создаваемый объект'#13+
'\MConcreteMediatorA\m). Для доступа к объектам \Mc1\m и \Mc2\m предусмотрены методы \MGetC1\m'#13+
'и \MGetC2\m, возвращающие ссылки на соответствующие объекты, приведенные к типу'#13+
'\MColleague\m. Метод \MNotifyFrom(coll)\m класса \MConcreteMediatorA\m выполняет следующие'#13+
'действия: \P\X~если параметр \Mcoll\m является ссылкой на поле \Mc1\m, то к строковому'#13+
'полю \Mdata\m объекта \Mc2\m добавляется пробел и строковое представление поля \Mdata\m'#13+
'объекта \Mc1\m; \P\X~если параметр \Mcoll\m является ссылкой на поле \Mc2\m, то числовое'#13+
'поле \Mdata\m объекта \Mс1\m увеличивается на текущую длину строкового поля \Mdata\m'#13+
'объекта \Mc2\m. \PВ конце своей работы метод \MNotifyFrom\m выводит на экран текущие'#13+
'значения полей \Mdata\m объектов \Mc1\m и \Mc2\m.'#13+
'\PКласс \MConcreteMediatorB\m содержит поля \Mc1a\m и \Mc1b\m (типа \MConcreteColleague1\m) и \Mc2\m'#13+
'(типа \MConcreteColleague2\m). Объекты \Mс1a\m, \Mc1b\m и \Mc2\m создаются в конструкторе'#13+
'класса \MConcreteMediatorB\m (действия при их создании аналогичны действиям,'#13+
'описанным для класса \MConcreteMediatorA\m). Для доступа к объектам предусмотрены'#13+
'методы \MGetC1a\m, \MGetC1b\m и \MGetC2\m, возвращающие ссылки на соответствующие объекты,'#13+
'приведенные к типу \MColleague\m. Метод \MNotifyFrom(coll)\m класса \MConcreteMediatorB\m'#13+
'выполняет следующие действия: \P\X~если параметр \Mcoll\m является ссылкой'#13+
'на поле \Mc1a\m, то числовое поле data объекта \Mc1b\m увеличивается на значение поля'#13+
'\Mdata\m объекта \Mc1a\m, а к строковому полю \Mdata\m объекта \Mc2\m добавляется символ \<a\>;'#13+
'\P\X~если параметр \Mcoll\m является ссылкой на поле \Mc1b\m, то числовое поле \Mdata\m'#13+
'объекта \Mc1a\m увеличивается на значение поля \Mdata\m объекта \Mc1b\m, а к строковому'#13+
'полю \Mdata\m объекта \Mc2\m добавляется символ \<b\>; \P\X~если параметр \Mcoll\m является'#13+
'ссылкой на поле \Mc2\m, то в поля \Mdata\m объектов \Mc1a\m и \Mc1b\m записываются числа,'#13+
'равные количеству символов \<a\> и \<b\> в строке \Mdata\m объекта \Mc2\m (например, если'#13+
'строка равна \<abaab\>, то в поле \Mdata\m объекта \Mс1a\m записывается число~3,'#13+
'а в поле \Mdata\m объекта \Mc1b\m записывается число~2). \PВ конце своей работы метод'#13+
'\MNotifyFrom\m выводит на экран текущие значения полей \Mdata\m'#13+
'объектов \Mc1a\m, \Mc1b\m и \Mc2\m.'#13+
TestHeader+
'Создать объекты-посредники \Mma\m (типа \MConcreteMediatorA\m) и \Mmb\m (типа'#13+
'\MConcreteMediatorB\m). Также создать структуру данных \Mcoll\m (например, массив)'#13+
'из 5 ссылок на элементы типа \MColleague\m и записать в нее ссылки, возвращаемые'#13+
'следующими методами (в указанном порядке): \Mma.GetC1\m, \Mma.GetC2\m, \Mmb.GetC1a\m,'#13+
'\Mmb.GetC1b\m, \Mmb.GetC2\m. Дано целое число {N} (\l\,20) и набор из {N} целых чисел'#13+
'в диапазоне от~0 до~4, определяющих индексы элементов структуры \Mcoll\m.'#13+
'Для каждого числа~{K} из данного набора выполнить вызов метода \MNotify\m'#13+
'для элемента структуры \Mcoll\m с индексом~{K}. Выводить какие-либо'#13+
'результаты не требуется, так как вывод осуществляется'#13+
'в методах \MNotifyFrom\m объектов-посредников.'
);
n := Random(6)+ 15;
DataN('N = ', n, 0, 1, 2);
ac1 := 1; bc1a := 1; bc1b := 1;
ac2 := 'ab'; bc2 := 'ab';
for i := 1 to n do
begin
  k := Random(5);
  DataN('', k, Center(i, n, 1, 2), 2, 1);
  case k of
  0: ac2 := ac2 + ' ' + IntToStr(ac1);
  1: ac1 := ac1 + length(ac2);
  2: begin
       bc1b := bc1b + bc1a;
       bc2 := bc2 + 'a';
     end;
  3: begin
       bc1a := bc1b + bc1a;
       bc2 := bc2 + 'b';
     end;
  4: begin
       SetCount(bc2, bc1a, bc1b);
     end;
  end;
  if k in [0..1] then
  begin
    ResultN('', ac1, 26, i, 4);
    ResultS('', ac2, 52 - (length(ac2)+1) div 2, i);
  end
  else
  begin
    ResultN2('', bc1a, bc1b, 24, i, 4);
    ResultS('', bc2, 52 - (length(bc2)+1) div 2, i);
  end;
end;
end;

type pair1 = record
   r1, r2: integer;
   end;

type pair2 = record
   r1, r2: string;
   end;

type triple = record
   c: char;
   p1: integer;
   p2: string;
   name: string;
   end;


procedure SwapP1(var a: pair1; var b: pair1);
var x : pair1;
begin
  x := a;
  a := b;
  b := x;
end;

procedure SwapP2(var a: pair2; var b: pair2);
var x : pair2;
begin
  x := a;
  a := b;
  b := x;
end;

procedure Pat14;
var n, i, k, j, min, max, id: integer;
    p: array[1..10] of pair1;
    r: array[1..20] of integer;
    b: boolean;
    s: string;
begin
    CreateTask(Subgroup3);
    TaskText(
'\G<Graph\OOPChain.png>\BChain of Responsibility\b (\BЦепочка обязанностей\b)~\= паттерн поведения.'#13+
'\P\SЧастота использования\s: ниже средней.'#13+
'\P\SНазначение\s: позволяет избежать привязки отправителя запроса к его получателю,'#13+
'давая шанс обработать запрос нескольким объектам. Связывает объекты-получатели'#13+
'в \Iцепочку\i и передает запрос вдоль этой цепочки, пока его не обработают.'#13+
'\P\SУчастники\s: \P\X~\IHandler\i (\IОбработчик\i)~\= определяет интерфейс для обработки'#13+
'запросов; может (но не обязан) реализовывать связь с преемником;'#13+
'\P\X~\IConcreteHandler\i (\IКонкретный обработчик\i)~\= обрабатывает запрос, за который'#13+
'отвечает; имеет доступ к своему преемнику, которому направляет запрос, если'#13+
'не может его обработать самостоятельно; \P\X~\IClient\i (\IКлиент\i)~\= отправляет запрос'#13+
'некоторому объекту ConcreteHandler в цепочке.'#13+
'\P\SЗадание 1\s. Реализовать иерархию классов-\Iобработчиков\i, включающую'#13+
'абстрактный класс \MHandler\m и два конкретных класса \MConcreteHandler1\m'#13+
'и \MConcreteHandler2\m. Класс \MHandler\m содержит абстрактный метод'#13+
'\MHandleRequest(req)\m (не возвращает значений, имеет параметр \Mreq\m целого типа,'#13+
'определяющий номер запроса).'#13+
'\PКласс \MConcreteHandler1\m имеет поле \Msuccessor\m~\= ссылку на объект \MHandler\m и три'#13+
'целочисленных поля: \Mid\m (целочисленный идентификатор обработчика), \Mreq1\m и \Mreq2\m'#13+
'(определяют диапазон номеров запросов, которые может обработать данный'#13+
'обработчик). Все эти поля инициализируются в конструкторе с использованием'#13+
'параметров конструктора \Msuccessor\m, \Mid\m, \Mreq1\m, \Mreq2\m. Метод \MHandleRequest(req)\m'#13+
'класса \MConcreteHandler1\m выполняет следующие действия: \P\X если его параметр \Mreq\m'#13+
'лежит в диапазоне от \Mreq1\m до \Mreq2\m (включая граничные значения \Mreq1\m и \Mreq2\m),'#13+
'то запрос обрабатывается путем вывода текста \<Request <req> processed'#13+
'by handler <id>\> (запрос <req> обработан обработчиком <id>),'#13+
'где <req> и <id>~\= значения параметра \Mreq\m и поля \Mid\m;'#13+
'\P\X в противном случае выполняется вызов метода \MHandleRequest(req)\m для объекта'#13+
'\Msuccessor\m (перед этим вызовом можно проверять, что поле \Msuccessor\m не является'#13+
'пустой ссылкой, хотя при правильном построении цепочки обработчиков'#13+
'такая ситуация не должна возникать).'#13+
'\PКласс \MConcreteHandler2\m является особым \Iтерминальным\i обработчиком, который'#13+
'должен находиться в конце цепочки обработчиков и к которому, таким образом,'#13+
'поступают все необработанные запросы. Он не имеет полей, его конструктор'#13+
'не выполняет дополнительных действий, а метод \MHandleRequest(req)\m выводит'#13+
'на экран текст \<Request <req> not processed\> (запрос <req> не обработан),'#13+
'где <req>~\= значение параметра \Mreq\m.'#13+
'\PВспомогательный класс \MClient\m содержит поле \Mh\m~\= ссылку типа \MHandler\m'#13+
'на обработчик, являющийся первым в ранее сформированной цепочке обработчиков.'#13+
'Поле~\Mh\m инициализируется в конструкторе с помощью одноименного параметра.'#13+
'Класс \MClient\m также содержит метод \MSendRequest(req)\m, имеющий целочисленный'#13+
'параметр \Mreq\m и не возвращающий значения; в этом методе выполняется'#13+
'вызов метода \MHandleRequest(req)\m для объекта~\Mh\m.'#13+
TestHeader+
'Дано целое число {N} (\l\,10) и набор из {N} пар целых чисел ({r}_1,~{r}_2) (для любой'#13+
'пары выполняется неравенство {r}_1~\l~{r}_2). Используя переменную~\Mh\m~\= ссылку'#13+
'на объект \MHandler\m, последовательно создать один объект типа \MConcreteHandler2\m'#13+
'и {N}~объектов типа \MConcreteHandler1\m. Ссылки на создаваемые объекты сохраняются'#13+
'\Iв одной и той же\i переменной~\Mh\m; параметрами конструктора для объектов'#13+
'\MConcreteHandler1\m должны быть значения~\Mh\m, {i}, {r}_1, {r}_2, где~{i}~\= индекс пары'#13+
'из исходного набора (пары индексируются от~0), а~{r}_1 и~{r}_2~\= первый и второй'#13+
'элемент этой пары. В результате будет создана цепочка из {N}\,+\,1 обработчика,'#13+
'причем первым элементом этой цепочки (ссылка на который будет храниться'#13+
'в переменной~\Mh\m) будет обработчик типа \MConcreteHandler1\m с идентификатором~{N}\,\-\,1,'#13+
'предпоследним~\= обработчик типа \MConcreteHandler1\m с идентификатором~0,'#13+
'а последним~\= обработчик типа \MConcreteHandler2\m. Создать объект \Mcli\m типа'#13+
'\MClient\m, указав в качестве параметра его конструктора значение ссылки~\Mh\m.'#13+
'\PТакже дано целое число {K} (\l\,20) и набор из {K} различных целых чисел~\= номеров'#13+
'запросов. Для каждого запроса \Mreq\m из данного набора выполнить вызов метода'#13+
'\MSendRequest(req)\m объекта \Mcli\m. Выводить какие-либо результаты не требуется,'#13+
'так как вывод осуществляется в методах \MHandleRequest\m объектов-обработчиков.'
);

n := Random(5) + 6;
repeat
r[1] := Random(10) + 10;
for i := 2 to 2*n do
  r[i] := r[i-1]+ 1 + Random(5);
min := r[1] - 5;
max := r[2*n]+ 5;
until max < 100;
for i := 1 to n do
begin
  p[i].r1 := r[2*i-1];
  p[i].r2 := r[2*i];
end;
for i := 1 to n do
  SwapP1(p[Random(n)+1], p[Random(n)+1]);
DataN('N = ', n, 0, 1, 1);
for i := 1 to n do
  DataN2('', p[i].r1, p[i].r2, Center(i, n, 6, 2), 2, 3);


k := Random(6) + 15;

for i := 1 to k do
begin
  repeat
    b := true;
    r[i] := Random(max-min+1) + min;
    for j := 1 to i-1 do
      if r[i] = r[j] then
      begin
        b := false;
        break;
      end;
  until b;
end;
DataN('K = ', k, 0, 3, 1);
for i := 1 to k do
begin
  DataN('', r[i], Center(i, k, 2, 2), 4, 2);
  id := 0;
  for j := n downto 1 do
    if (p[j].r1 <= r[i]) and (r[i] <= p[j].r2) then
    begin
      id := j;
      break;
    end;
  if id > 0 then
    s := 'Request '+IntToStr(r[i])+' processed by handler '+IntToStr(id-1)
  else
    s := 'Request '+IntToStr(r[i])+' not processed';
  ResultS('', s, 0,i);
end;
end;

procedure Pat15;
var n, i, k, j, min, max, id: integer;
    p1: array[1..10] of pair1;
    p2: array[1..10] of pair2;
    id1: array[1..10] of integer;
    id2: array[1..10] of integer;
    r1: array[1..20] of integer;
    r2: array[1..20] of string;
    t: array[1..10] of char;
    t1: array[1..20] of char;
    rr: array[1..20] of triple;
    b: boolean;
    s: string;
    smin, smax: integer;
    na, nb, ka, kb, ia, ib: integer;
begin
    CreateTask(Subgroup3);
TaskText(
'\BChain of Responsibility\b (\BЦепочка обязанностей\b)~\= паттерн поведения.'#13+
'\PВ данном задании рассматривается вариант иерархии классов обработчиков,'#13+
'в которой базовый класс обеспечивает в методе HandleRequest всю необходимую'#13+
'функциональность для передачи запроса по цепочке обработчиков, а подклассы'#13+
'расширяют эту функциональность. Кроме того, в задании рассматривается'#13+
'вариант представления запросов в виде иерархии классов,'#13+
'инкапсулирующих параметры запроса.'#13+
'\P\SЗадание 2\s. Реализовать две иерархии классов, связанные с применением'#13+
'паттерна Chain of Responsibility. Первая иерархия является'#13+
'иерархией классов-\Iзапросов\i и включает абстрактный класс \MRequest\m и два'#13+
'конкретных класса \MRequestA\m и \MRequestB\m. Класс \MRequest\m содержит абстрактный'#13+
'метод \MToStr\m без параметров, возвращающий строковое описание запроса. В классах'#13+
'\MRequestA\m и \MRequestB\m определено поле \Mparam\m, задающее параметр запроса, причем'#13+
'для класса~A параметр является целочисленным, а для класса~B~\= строковым.'#13+
'Поле \Mparam\m инициализируется в конструкторе с помощью одноименного параметра.'#13+
'Также в этих классах определен метод \MGetParam\m, который возвращает значение'#13+
'поля \Mparam\m, и метод \MToStr\m, который возвращает описание запроса, включающее'#13+
'тип запроса (букву \<A\> или \<B\>), двоеточие и параметр запроса (целое число'#13+
'для запроса~A и строку для запроса~B), например, \<A:12\>, \<B:abc\>.'#13+
'\PВторая иерархия является иерархией классов-\Iобработчиков\i и включает конкретный'#13+
'базовый класс \MHandler\m и классы-потомки \MHandlerA\m и \MHandlerB\m. Класс \MHandler\m'#13+
'содержит поле \Msuccessor\m (ссылку на объект \MHandler\m) и метод \MHandleRequest(req)\m'#13+
'(не возвращает значений, имеет параметр-ссылку \Mreq\m типа \MRequest\m, определяющий'#13+
'вид запроса). Метод \MHandleRequest\m работает следующим образом: если поле'#13+
'\Msuccessor\m не является пустой ссылкой, то вызывается метод \MHandleRequest(req)\m'#13+
'для объекта \Msuccessor\m, в противном случае выводится текст \<Request <req>'#13+
'not processed\> (запрос <req> не обработан), где <req>~\= значение,'#13+
'возвращаемое методом \MToStr\m параметра \Mreq\m. Класс \MHandler\m имеет конструктор'#13+
'с параметром-ссылкой \Msuccessor\m типа \MHandler\m, который инициализирует'#13+
'одноименное поле. Таким образом, данный класс обеспечивает всю необходимую'#13+
'функциональность для организации цепочки обработчиков.'#13+
'\PКлассы \MHandlerA\m и \MHandlerB\m предназначены для обработки запросов'#13+
'соответствующего типа (A или B) и имеют целочисленное поле \Mid\m (идентификатор'#13+
'обработчика) и поля \Mparam1\m и \Mparam2\m (определяют диапазон параметров запросов,'#13+
'которые может обработать данный обработчик). Тип полей \Mparam1\m и \Mparam2\m'#13+
'соответствует типу параметра обрабатываемого запроса: для класса \MHandlerA\m'#13+
'это целый тип, для класса \MHandlerB\m~\= строковый. Конструктор классов \MHandlerA\m'#13+
'и \MHandlerB\m имеет четыре параметра: \Msuccessor\m типа ссылки на \MHandler\m,'#13+
'\Mid\m целого типа, \Mparam1\m и \Mparam2\m типа, соответствующего типу одноименных полей.'#13+
'В конструкторе вызывается конструктор базового класса с параметром \Msuccessor\m'#13+
'и инициализируются поля \Mid\m, \Mparam1\m и \Mparam2\m.'#13+
'\PМетод \MHandleRequest(req)\m классов \MHandlerA\m и \MHandlerB\m выполняет следующие'#13+
'действия: \P\X вначале проверяется \Iтип времени выполнения\i параметра \Mreq\m,'#13+
'и в случае, если этот тип соответствует типу обрабатываемого запроса'#13+
'(\MRequestA\m для \MHandlerA\m, \MRequestB\m для \MHandlerB\m), проверяется, лежит ли'#13+
'параметр \Mparam\m запроса \Mreq\m в диапазоне от \Mparam1\m до \Mparam2\m, включая'#13+
'граничные значения \Mparam1\m и \Mparam2\m (строковые параметры для запроса'#13+
'\MRequestB\m сравниваются лексикографически); \P\X eсли обе проверки являются'#13+
'успешными, то запрос обрабатывается путем вывода текста \<Request <req>'#13+
'processed by handler <id>\> (запрос <req> обработан обработчиком <id>),'#13+
'где <req>~\= значение, возвращаемое методом \MToStr\m объекта \Mreq\m, а <id>~\='#13+
'значение поля \Mid\m обработчика; \P\X в противном случае выполняется вызов метода'#13+
'\MHandleRequest(req)\m базового класса (в котором либо происходит переход'#13+
'к следующему обработчику в цепочке, либо, при его отсутствии, выводится'#13+
'сообщение о невозможности обработать запрос).'#13+
'\PВспомогательный класс \MClient\m содержит поле~\Mh\m~\= ссылку типа \MHandler\m'#13+
'на обработчик, являющийся первым в ранее сформированной цепочке обработчиков.'#13+
'Поле~\Mh\m инициализируется в конструкторе с помощью одноименного параметра.'#13+
'Класс \MClient\m также содержит метод \MSendRequest(req)\m, имеющий параметр-ссылку'#13+
'типа \MRequest\m и не возвращающий значения; в этом методе выполняется вызов'#13+
'метода \MHandleRequest(req)\m для объекта~\Mh\m.'#13+
TestHeader+
'Дано целое число {N} (\l\,10) и набор из {N} троек элементов. В каждой тройке первый'#13+
'элемент является символом \<A\> или \<B\>, а тип остальных двух элементов {p}_1,~{p}_2'#13+
'зависит от символа: в случае символа \<A\> это целые числа, а в случае \<B\>~\='#13+
'строки. В любом случае выполняется неравенство {p}_1~\l~{p}_2, где для чисел'#13+
'используется обычное сравнение, а для строк~\= лексикографическое. Используя'#13+
'переменную \Mh\m~\= ссылку на объект \MHandler\m, последовательно создать один объект'#13+
'типа \MHandler\m (передав ему в качестве параметра пустую ссылку) и {N} объектов'#13+
'типа \MHandlerA\m или \MHandlerB\m (тип определяется первым элементом соответствующей'#13+
'тройки). Ссылки на создаваемые объекты записываются \Iв одну и ту же\i'#13+
'переменную~h; параметрами конструктора для объектов \MHandlerA\m и \MHandlerB\m должны'#13+
'быть значения~\Mh\m, {i}, {p}_1, {p}_2, где {i}~\= индекс очередной тройки из исходного'#13+
'набора (тройки индексируются от~0), а {p}_1 и {p}_2~\= второй и третий элемент этой'#13+
'тройки. В результате будет создана цепочка из {N}\,+\,1 обработчика, причем первым'#13+
'элементом этой цепочки (ссылка на который будет храниться в переменной~\Mh\m)'#13+
'будет обработчик типа \MHandlerA\m или \MHandlerB\m с идентификатором~{N}\,\-\,1,'#13+
'предпоследним~\= обработчик типа \MHandlerA\m или \MHandlerB\m с идентификатором~0,'#13+
'а последним~\= обработчик типа \MHandler\m (не имеющий идентификатора).'#13+
'Создать объект \Mcli\m типа \MClient\m, указав в качестве параметра'#13+
'его конструктора значение ссылки~\Mh\m.'#13+
'\PТакже дано целое число {K} (\l\,20) и набор из {K} различных запросов, определяемых'#13+
'парами элементов ({c}, {p}), где {c}~\= символ \<A\> или \<B\>, а {p}~\= параметр запроса'#13+
'(целочисленный в случае \<A\>, строковый в случае \<B\>). Для каждой пары создать'#13+
'запрос \Mreq\m соответствующего типа и выполнить вызов метода \MSendRequest(req)\m'#13+
'объекта \Mcli\m. Выводить какие-либо результаты не требуется, так как вывод'#13+
'осуществляется в методах \MHandleRequest\m объектов-обработчиков.'
);


n := Random(5) + 6;
repeat
na := 0;
nb := 0;
for i := 1 to n do
  if Random(2) = 0 then
  begin
    t[i] := 'A';
    inc(na);
  end
  else
  begin
    t[i] := 'B';
    inc(nb);
  end;
until (na > 2) and (nb > 2);

repeat
r1[1] := Random(10) + 10;
for i := 2 to 2*na do
  r1[i] := r1[i-1]+ 1 + Random(5);
min := r1[1] - 5;
max := r1[2*na]+ 5;
until max < 100;

repeat
r2[1] := chr(Random(5) + 100) + chr(Random(26)+97);
for i := 2 to 2*nb do
  r2[i] := chr(ord(r2[i-1][1]) + Random(4) + 1)+ chr(Random(26)+97);
smin := ord(r2[1][1])-1;
smax := ord(r2[2*nb][1])+1;
until smax <=ord('z');

for i := 1 to na do
begin
  p1[i].r1 := r1[2*i-1];
  p1[i].r2 := r1[2*i];
end;
for i := 1 to na do
  SwapP1(p1[Random(na)+1], p1[Random(na)+1]);

for i := 1 to nb do
begin
  p2[i].r1 := r2[2*i-1];
  p2[i].r2 := r2[2*i];
end;
for i := 1 to nb do
  SwapP2(p2[Random(nb)+1], p2[Random(nb)+1]);


DataN('N = ', n, 0, 1, 1);
ia := 0;
ib := 0;
for i := 1 to 5 do
begin
  DataC('', t[i], Center(i, 5, 13, 3), 2);
  if t[i] = 'A' then
  begin
    inc(ia);
    id1[ia] := i;
    DataN('', p1[ia].r1, Center(i, 5, 13, 3)+3, 2, 4);
    DataN('', p1[ia].r2, Center(i, 5, 13, 3)+8, 2, 4);
  end
  else
  begin
    inc(ib);
    id2[ib] := i;
    DataS('', p2[ib].r1, Center(i, 5, 13, 3)+4, 2);
    DataS('', p2[ib].r2, Center(i, 5, 13, 3)+9, 2);
  end;
end;

for i := 6 to n do
begin
  DataC('', t[i], Center(i-5, 5, 13, 3), 3);
  if t[i] = 'A' then
  begin
    inc(ia);
    id1[ia] := i;
    DataN('', p1[ia].r1, Center(i-5, 5, 13, 3)+3, 3, 4);
    DataN('', p1[ia].r2, Center(i-5, 5, 13, 3)+8, 3, 4);
  end
  else
  begin
    inc(ib);
    id2[ib] := i;
    DataS('', p2[ib].r1, Center(i-5, 5, 13, 3)+4, 3);
    DataS('', p2[ib].r2, Center(i-5, 5, 13, 3)+9, 3);
  end;
end;



k := Random(6) + 15;

repeat
ka := 0;
kb := 0;
for i := 1 to k do
  if Random(2) = 0 then
  begin
    t1[i] := 'A';
    inc(ka);
  end
  else
  begin
    t1[i] := 'B';
    inc(kb);
  end;
until (ka > 5) and (kb > 5);




for i := 1 to ka do
begin
  repeat
    b := true;
    r1[i] := Random(max-min+1) + min;
    for j := 1 to i-1 do
      if r1[i] = r1[j] then
      begin
        b := false;
        break;
      end;
  until b;
end;

for i := 1 to kb do
begin
  repeat
    b := true;
    r2[i] := chr(Random(smax-smin+1) + smin) + chr(Random(26)+97);
    for j := 1 to i-1 do
      if r2[i] = r2[j] then
      begin
        b := false;
        break;
      end;
  until b;
end;

ia := 0;
ib := 0;
for i := 1 to k do
begin
  rr[i].c := t1[i];
  if t1[i] = 'A' then
  begin
    inc(ia);
    rr[i].p1 := r1[ia];
    rr[i].name := 'A:' + IntToStr(r1[ia]);
  end
  else
  begin
    inc(ib);
    rr[i].p2 := r2[ib];
    rr[i].name := 'B:' + r2[ib];
  end
end;


DataN('K = ', k, 0, 4, 1);
for i := 1 to 7 do
begin
  DataC('', rr[i].c, Center(i, 7, 8, 3)+1, 5);
  if rr[i].c = 'A' then
    DataN('', rr[i].p1, Center(i, 7, 8, 3)+6, 5, 2)
  else
    DataS('', rr[i].p2, Center(i, 7, 8, 3)+5, 5);
end;
for i := 1 to 7 do
begin
  DataC('', rr[i+7].c, Center(i, 7, 8, 3)+1, 6);
  if rr[i+7].c = 'A' then
    DataN('', rr[i+7].p1, Center(i, 7, 8, 3)+6, 6, 2)
  else
    DataS('', rr[i+7].p2, Center(i, 7, 8, 3)+5, 6);
end;
for i := 1 to k-14 do
begin
  DataC('', rr[i+14].c, Center(i, 7, 8, 3)+1, 7);
  if rr[i+14].c = 'A' then
    DataN('', rr[i+14].p1, Center(i, 7, 8, 3)+6, 7, 2)
  else
    DataS('', rr[i+14].p2, Center(i, 7, 8, 3)+5, 7);
end;









for i := 1 to k do
begin

  id := 0;
  if rr[i].c = 'A' then
    begin
    for j := na downto 1 do
      if (p1[j].r1 <= rr[i].p1) and (rr[i].p1 <= p1[j].r2) then
      begin
        id := id1[j];
        break;
      end
    end
  else
    begin
    for j := nb downto 1 do
      if (p2[j].r1 <= rr[i].p2) and (rr[i].p2 <= p2[j].r2) then
      begin
        id := id2[j];
        break;
      end;
    end;

  if id > 0 then
    s := 'Request '+rr[i].name+' processed by handler '+IntToStr(id-1)
  else
    s := 'Request '+rr[i].name+' not processed';
  ResultS('', s, 0,i);
end;
SetTestCount(9);
end;


type IntRec = record
  t: char;
  node1, node2: integer;
  varind: integer;
  rval: real;
  s: string;
  op: char;
  nodes: array[1..4] of integer;
  end;

  RContext = record
  name: string;
  val: real;
  end;

  NContext = record
  name: string;
  val: integer;
  end;


procedure Pat16;
var nodes: array[0..30] of IntRec;
    avail: string;
    n, i, n1, n2, k, m: integer;
    b: boolean;
    cnt: array[1..7] of integer;
    cont: array[0..9] of RContext;
    res1, res2: string;
    check2, check7: integer;
    x, y, step: integer;
    ir: IntRec;
function InterpA(ind: integer): string;
begin
  case nodes[ind].t of
  'C': Str(nodes[ind].rval:0:2, result);
  'V': result := cont[nodes[ind].varind].name;
  'M': result := '(' + InterpA(nodes[ind].node1) +
         nodes[ind].op + InterpA(nodes[ind].node2) + ')';
  end;
end;

function InterpB(ind: integer): string;
begin
  case nodes[ind].t of
  'C': Str(nodes[ind].rval:0:2, result);
  'V': result := cont[nodes[ind].varind].name;
  'M': result := InterpB(nodes[ind].node1) + ' ' +
         InterpB(nodes[ind].node2) + ' ' + nodes[ind].op;
  end;
end;

function InterpC(ind: integer): real;
var a, b: real;
begin
  case nodes[ind].t of
  'C': result := nodes[ind].rval;
  'V': result := cont[nodes[ind].varind].val;
  'M': begin
         a := InterpC(nodes[ind].node1);
         b := InterpC(nodes[ind].node2);
         case nodes[ind].op of
         '+': result := a + b;
         '-': result := a - b;
         '*': result := a * b;
         '/': result := a / b;
         end;
       end;
  end;
end;


function randomavail: integer;
begin
  result := ord(avail[Random(length(avail))+1])-65;
end;
procedure removeavail(ind: integer);
var i: integer;
begin
  for i := length(avail) downto 1 do
    if ord(avail[i]) = ind+65 then
    begin
      delete(avail, i, 1);
      exit;
    end;
end;
procedure addavail(ind: integer);
begin
     avail := avail + chr(ind+65);
end;
begin
    CreateTask(Subgroup3);
TaskText(
'\G<Graph\OOPInterpreter.png>\BInterpreter\b (\BИнтерпретатор\b)~\= паттерн поведения.'#13+
'\P\SЧастота использования\s: низкая.'#13+
'\P\SНазначение\s: для заданного языка определяет представление его грамматики,'#13+
'а также интерпретатор предложений этого языка.'#13+
'\P\SУчастники\s: \P\X~\IAbstractExpression\i (\IАбстрактное выражение\i)~\= объявляет'#13+
'абстрактную операцию Interpret, общую для всех узлов в абстрактном'#13+
'синтаксическом дереве; \P\X~\ITerminalExpression\i (\IТерминальное выражение\i)~\='#13+
'реализует операцию Interpret для терминальных символов грамматики; необходим'#13+
'отдельный экземпляр для каждого терминального символа в предложении;'#13+
'\P\X~\INonterminalExpression\i (\IНетерминальное выражение\i)~\= по одному такому классу'#13+
'требуется для каждого грамматического правила вида {R}~::=~{R}_1~{R}_2~\.~{R}_n;'#13+
'хранит переменные экземпляра типа AbstractExpression для каждого символа'#13+
'от~{R}_1 до~{R}_n; реализует операцию Interpret для нетерминальных символов'#13+
'грамматики (эта операция рекурсивно вызывает себя же для переменных,'#13+
'представляющих {R}_1,~\., {R}_n); \P\X~\IContext\i (\IКонтекст\i)~\= содержит информацию,'#13+
'глобальную по отношению к интерпретатору; \P\X~\IClient\i (\IКлиент\i)~\= строит'#13+
'(или получает в готовом виде) абстрактное синтаксическое дерево разбора,'#13+
'представляющее отдельное предложение на языке с данной грамматикой'#13+
'(дерево составлено из экземпляров классов NonterminalExpression'#13+
'и TerminalExpression); вызывает операцию Interpret.'#13+
'\PПоскольку разбор выражения не входит в задачу паттерна Interpreter'#13+
'(это может быть, например, задачей класса Client), в заданиях, связанных'#13+
'с этим паттерном, синтаксическое дерево разбора выражения предлагается'#13+
'в качестве одного из элементов исходных данных (что позволяет, в частности,'#13+
'рассмотреть вариант операции Interpret, обеспечивающий \Iвосстановление\i'#13+
'исходного выражения по его дереву разбора).'#13+
'\P\SЗадание 1\s. Реализовать иерархию классов, которая определяет'#13+
'следующую грамматику арифметического выражения:'#13+
'\[\Jlcl&<expr>  & \M::=\m & <const> | <var> | <math>    &'#13+
'<math>  & \M::=\m & (<expr><op><expr>)          &'#13+
'<op>    & \M::=\m & + | \- | * | /               &'#13+
'<const> & \M::=\m & <вещественное число>        &'#13+
'<var>   & \M::=\m & <имя вещественной переменной>\j\]'#13+
'\PИерархия классов содержит абстрактный класс \MAbstractExpression\m,'#13+
'класс \MNontermMath\m (\Iматематическая операция\i), определяющий нетерминальное'#13+
'выражение, и два класса, определяющих терминальные выражения: \MTermConst\m'#13+
'(\Iконстанта\i) и \MTermVar\m (\Iпеременная\i). Класс \MAbstractExpression\m содержит'#13+
'абстрактные методы \MInterpretA(ct)\m, \MInterpretB(ct)\m, \MInterpretC(ct)\m,'#13+
'определяющие три варианта интерпретации выражения (параметр-ссылка \Mct\m'#13+
'имеет тип \MContext\m, описываемый далее). Методы \MInterpretA\m и \MInterpretB\m'#13+
'возвращают строковое значение, метод \MInterpretC\m~\= вещественное число.'#13+
'В каждом конкретном классе (\MNontermMath\m, \MTermConst\m и \MTermVar\m) требуется'#13+
'переопределить эти абстрактные методы.'#13+
'\P\X Интерпретация A состоит в \Iвосстановлении\i строкового представления'#13+
'арифметического выражения, удовлетворяющего приведенной выше грамматике,'#13+
'по его синтаксическому дереву разбора. \P\X Интерпретация B состоит'#13+
'в \Iконструировании\i строкового представления для эквивалентного выражения,'#13+
'записанного в \Iбесскобочном формате\i, в котором терминальные выражения const'#13+
'и var остаются прежними, а нетерминальная операция math принимает вид'#13+
'<math>~\M::=\m~<expr>~<expr>~<op> (между каждым элементом в правой части'#13+
'располагается пробел). Имена переменных для интерпретаций A и B берутся'#13+
'из контекста (экземпляра класса \MContext\m). \P\X Интерпретация C состоит'#13+
'в \Iвычислении\i арифметического выражения, представленного синтаксическим'#13+
'деревом разбора; при этом значения переменных также берутся из контекста.'#13+
'\PПримеры интерпретаций A, B, C для одного и того же синтаксического дерева:'#13+
'строка \<(10.50\-((var1+6.00)*a))\>, строка \<10.50 var1 6.00 + a * \-\>, число \-9.5'#13+
'(при условии, что контекст содержит переменные var1~=~4 и a~=~2).'#13+
'\PКласс \MContext\m содержит два набора элементов размера~10: строковый набор'#13+
'\Mnames\m с именами доступных переменных и набор вещественных чисел \Mvalues\m'#13+
'со значениями соответствующих переменных (для хранения наборов можно'#13+
'использовать массивы или другие структуры данных). Конструктор класса \MContext\m'#13+
'не имеет параметров; он заносит в набор \Mnames\m односимвольные имена переменных'#13+
'от~\<a\> до~\<j\> (в алфавитном порядке), а в набор \Mvalues\m~\= значения 1.0.'#13+
'Класс \MContext\m включает три метода: \MSetVar(ind, name, value)\m, \MGetName(ind)\m,'#13+
'\MGetValue(ind)\m. Параметр \Mind\m во всех методах определяет индекс обрабатываемой'#13+
'переменной (число от~0 до~9). Метод \MSetVar\m задает для переменной'#13+
'с индексом \Mind\m имя (строку \Mname\m) и значение (вещественное число \Mvalue\m).'#13+
'Метод \MGetName\m возвращает имя переменной с индексом \Mind\m, метод \MGetValue\m'#13+
'возвращает значение переменной с индексом \Mind\m. При реализации этих методов'#13+
'можно не проверять допустимость значений параметра \Mind\m, а также'#13+
'не контролировать возможную ошибочную ситуацию, когда два элемента набора'#13+
'\Mnames\m совпадают (т.\,е. когда две разные переменные имеют одинаковые имена).'#13+
'\PКласс \MNontermMath\m содержит поля \Mexpr1\m и \Mexpr2\m~\= ссылки на объекты типа'#13+
'\MAbstractExpression\m (первый и второй операнд математической операции)~\='#13+
'и поле \Mop\m символьного типа (знак операции). Поля инициализируются'#13+
'в конструкторе с помощью одноименных параметров.'#13+
'\PКласс \MTermConst\m содержит вещественное поле \Mvalue\m, задаваемое в конструкторе,'#13+
'имеющем параметр \Mvalue\m. В методах \MInterpretA\m и \MInterpretB\m этого класса'#13+
'должно возвращаться строковое представление поля \Mvalue\m с двумя дробными'#13+
'знаками и точкой в качестве десятичного разделителя.'#13+
'\PКласс \MTermVar\m содержит целочисленное поле \Mind\m~\= индекс переменной в некотором'#13+
'объекте-контексте. Это поле инициализируется в конструкторе с помощью'#13+
'параметра \Mind\m. Напомним, что контекст передается в качестве параметра во всех'#13+
'методах, выполняющих интерпретацию выражения (\MInterpretA\m,'#13+
'\MInterpretB\m и \MInterpretC\m).'#13+
'\PТакже определить класс \MClient\m, содержащий поля \Mexpr\m и \Mct\m~\= ссылки'#13+
'на объекты \MAbstractExpression\m и \MContext\m, которые инициализируются'#13+
'в конструкторе с помощью соответствующих параметров. Класс \MClient\m включает'#13+
'три метода без параметров: \MInterpretA\m, \MInterpretB\m и \MInterpretC\m, в которых'#13+
'вызывается метод объекта \Mexpr\m с тем же именем и параметром \Mct\m'#13+
'и возвращается результат, полученный этим методом.'#13+
TestHeader+
'Дано целое число {N} (\l\,30) и {N} наборов значений, каждый из которых определяет'#13+
'один узел синтаксического дерева разбора. Последующие узлы могут содержать'#13+
'ссылки на предыдущие узлы, поэтому все узлы следует сохранять в коллекции'#13+
'\Mnodes\m (например, массиве) с элементами-ссылками типа \MAbstractExpression\m.'#13+
'Каждый набор, соответствующий узлу синтаксического дерева, начинается'#13+
'с символа \<M\>, \<C\> или \<V\>. Объекту класса \MNontermMath\m соответствует'#13+
'символ \<M\>, за которым следуют три значения: индексы первого и второго'#13+
'операнда в уже заполненной части коллекции \Mnodes\m и символ операции (один'#13+
'из символов \<+\>, \<\-\>, \<*\>, \</\>). Индексирование элементов коллекции \Mnodes\m'#13+
'ведется от~0. Объекту класса \MTermConst\m соответствует символ \<C\>, за которым '#13+
'следует вещественное число~\= значение константы. Объекту класса \MTermVar\m'#13+
'соответствует символ \<V\>, за которым следует индекс переменной в некотором'#13+
'контексте (целое число в диапазоне от~0 до~9).'#13+
'\PТакже дан набор значений, определяющих контекст: целое число {M} (\l\,10)'#13+
'и {M} наборов троек ({ind}, {name}, {val}), в котором {ind} определяет индекс'#13+
'переменной в контексте, {name} определяет имя переменной, а {val}~\= ее значение'#13+
'(для остальных переменных контекста сохраняются имена'#13+
'и значения по умолчанию).'#13+
'\PИспользуя исходные данные, сформировать элементы синтаксического дерева'#13+
'разбора и сохранить их в коллекции \Mnodes\m, создать объект \Mct\m типа \MContext\m'#13+
'и настроить его содержимое. После этого создать объект \Mcli\m типа \MClient\m,'#13+
'передав его конструктору последний элемент коллекции \Mnodes\m и объект \Mct\m.'#13+
'Для объекта \Mcli\m вызвать методы \MInterpretA\m, \MInterpretB\m и \MInterpretC\m'#13+
'и вывести их возвращаемые значения.'
);
repeat
    m := 0;
    b := false;
    n1 := Random(8)+8;
    check2 := 6;
    check7 := 2;
    if CurrentTest = 1 then
    begin
      n1 := 5;
      check2 := 1;
      check7 := 1;
    end;
    avail := '';
    for i := 1 to 7 do
      cnt[i] := 0;
    for i := 0 to 9 do
    begin
      cont[i].name := chr(97+i);
      cont[i].val := 1.0;
    end;

    for i := 0 to n1-1 do
    begin
     case Random(4) of
     0: begin
          nodes[i].t := 'C';
          nodes[i].rval := Random*8.99+1;
          inc(cnt[1]);
        end;
     else
        begin
          nodes[i].t := 'V';
          nodes[i].varind := Random(10);
          inc(cnt[2]);
          if (Random(3) <> 2) and (cont[nodes[i].varind].name[1] <> 'v') then
          begin
            cont[nodes[i].varind].name := 'v' + Inttostr(nodes[i].varind);
            cont[nodes[i].varind].val := Random*8.99+1;
            inc(cnt[7]);
            inc(m);
          end;
        end;
     end;
     addavail(i);
    end;
    for i := n1 to 30 do
    begin
     if length(avail) = 1 then
     begin
       b := true;
       break;
     end;
       nodes[i].t := 'M';
       repeat
         nodes[i].node1 := randomavail;
         nodes[i].node2 := randomavail;
       until (nodes[i].node1 <> nodes[i].node2);
       removeavail(nodes[i].node1);
       removeavail(nodes[i].node2);
       k := Random(4);
       case k of
       0: nodes[i].op := '+';
       1: nodes[i].op := '-';
       2: nodes[i].op := '*';
       3: nodes[i].op := '/';
       end;
       inc(cnt[3+k]);
    addavail(i);
    n := i+1;
  end;
  if b then
  begin
  res1 := InterpA(n-1);
  res2 := InterpB(n-1);
  end;
until b and (cnt[1] * cnt[2] * cnt[3] * cnt[4] * cnt[5] * cnt[6] > 0)
     and (cnt[2] > check2) and (cnt[7] > check7) and (cnt[7] < cnt[2])
     and (length(res1) < 76);
    DataN('N = ', n, 0,1,1);
    y := 1;
    step := 16;
    for i := 0 to n - 1 do
    begin
      if i mod 5 = 0 then
        y := y + 1;
      x := 2 + step * (i mod 5);
      ir := nodes[i];
      DataC('', ir.t, x, y);
      case ir.t of
      'C': DataR('', ir.rval, x + 4, y, 5);
      'V': DataN('', ir.varind, x + 4, y, 2);
      'M': begin
             DataN('', ir.node1, x + 4, y, 2);
             DataN('', ir.node2, x + 7, y, 2);
             DataC('', ir.op, x + 10, y);
           end;
      end;
    end;
    y := y + 1;
    DataN('M = ', m, 0,y,1);
    step := 16;
    k := -1;
    for i := 0 to 9 do
    begin
      if cont[i].name[1] = 'v' then
        k := k + 1
      else
        continue;
      if k mod 5 = 0 then
        y := y + 1;
      x := 3 + step * (k mod 5);
      DataN('', i, x, y, 1);
      DataS('', cont[i].name, x + 3, y);
      DataR('', cont[i].val, x + 8, y, 4);
    end;
    ResultS('', res1, 0,1);
    ResultS('', res2, 0,2);
    ResultR('', InterpC(n-1), 0,3, 6);
end;

procedure Pat17;
var nodes: array[0..30] of IntRec;
    avail: string;
    n, i, n1, n2, k, m, k1, k2: integer;
    b: boolean;
    cnt: array[1..7] of integer;
    cont: array[0..9] of NContext;
    res: array[1..3] of string;
    check2, check7: integer;
    x, y, step: integer;
    ir: IntRec;
    c1: char;
function InterpA(ind: integer): string;
var i: integer;
begin
  case nodes[ind].t of
  'S': result := nodes[ind].s;
  'C': begin
         result := '';
         for i := 1 to nodes[ind].varind do
           result := result +  InterpA(nodes[ind].nodes[i]);
       end;
  'I': result := '(' + cont[nodes[ind].varind].name + '?' +
         InterpA(nodes[ind].node1) + ':' + InterpA(nodes[ind].node2)  + ')';
  'L': result := '(' + cont[nodes[ind].varind].name +  ':' +
         InterpA(nodes[ind].node1) + ')';
  end;
end;


function InterpB(ind: integer): string;
var i: integer;
begin
  case nodes[ind].t of
  'S': result := nodes[ind].s;
  'C': begin
         result := '';
         for i := 1 to nodes[ind].varind do
           result := result +  InterpB(nodes[ind].nodes[i]);
       end;
  'I': if cont[nodes[ind].varind].val <> 0 then
         result := InterpB(nodes[ind].node1)
       else
         result := InterpB(nodes[ind].node2);
  'L': begin
         result := '';
         for i := 1 to cont[nodes[ind].varind].val do
            result := result + InterpB(nodes[ind].node1);
       end;
  end;
end;


{function InterpB(ind: integer): string;
begin
  case nodes[ind].t of
  'C': Str(nodes[ind].rval:0:2, result);
  'V': result := cont[nodes[ind].varind].name;
  'M': result := InterpB(nodes[ind].node1) + ' ' +
         InterpB(nodes[ind].node2) + ' ' + nodes[ind].op;
  end;
end;}



function randomavail: integer;
begin
  result := ord(avail[Random(length(avail))+1])-65;
end;
procedure removeavail(ind: integer);
var i: integer;
begin
  for i := length(avail) downto 1 do
    if ord(avail[i]) = ind+65 then
    begin
      delete(avail, i, 1);
      exit;
    end;
end;
procedure addavail(ind: integer);
begin
     avail := avail + chr(ind+65);
end;
begin
    CreateTask(Subgroup3);
TaskText(
'\BInterpreter\b (\BИнтерпретатор\b)~\= паттерн поведения.'#13+
'\P\SЗадание 2\s. Реализовать иерархию классов, которая определяет'#13+
'следующую грамматику строкового выражения:'#13+
'\[\Jlcl&<expr>   & \M::=\m & <concat> | <if> | <loop> | <str>        &'#13+
'<concat> & \M::=\m & <expr><expr> | <concat><expr>          &'#13+
'<if>     & \M::=\m & (var?<expr>:<expr>)                    &'#13+
'<loop>   & \M::=\m & (var:<expr>)                           &'#13+
'<str>    & \M::=\m & <строка без символов \<(\>, \<)\>, \<?\>, \<:\>>&'#13+
'<var>    & \M::=\m & <имя целочисленной переменной>         \j\]'#13+
'\PВыражение concat возвращает конкатенацию нескольких выражений expr (двух'#13+
'или более); выражение if анализирует значение переменной var, и если var~\n~0,'#13+
'то возвращает первое из указанных выражений expr, в противном случае'#13+
'возвращает второе из указанных выражений; выражение loop возвращает выражение'#13+
'expr, повторенное столько раз, каково значение переменной var'#13+
'(или пустую строку, если var~\l~0).'#13+
'\PИерархия классов содержит абстрактный класс \MAbstractExpression\m, классы'#13+
'\MNontermConcat\m, \MNontermIf\m и \MNontermLoop\m, определяющие нетерминальные выражения'#13+
'concat, if, loop соответственно, и класс \MTermStr\m, определяющий терминальное'#13+
'выражение str. Класс \MAbstractExpression\m содержит два абстрактных метода'#13+
'\MInterpretA(ct)\m и \MInterpretB(ct)\m, возвращающих строковое значение'#13+
'и определяющих два варианта интерпретации выражения (параметр-ссылка \Mct\m'#13+
'имеет тип \MContext\m, описываемый далее). В каждом конкретном классе'#13+
'(\MNontermConcat\m, \MNontermIf\m, \MNontermLoop\m и \MTermStr\m) требуется'#13+
'переопределить эти абстрактные методы.'#13+
'\P\X Интерпретация A состоит в \Iвосстановлении\i строкового представления выражения,'#13+
'удовлетворяющего приведенной выше грамматике, по его синтаксическому дереву'#13+
'разбора; при этом имена переменных берутся из контекста (экземпляра класса'#13+
'\MContext\m). \P\X Интерпретация B состоит в \Iпостроении\i конкретной строки'#13+
'по выражению, представленному синтаксическим деревом разбора; при этом'#13+
'значения переменных также берутся из контекста.'#13+
'\PПримеры интерпретаций A и B для одного и того же синтаксического дерева'#13+
'разбора: строка \<abc(var1?(n:x):dd)yz\> и строка \<abcxxxxyz\> (при условии,'#13+
'что контекст содержит переменные var1~=~1 и n~=~4).'#13+
'\PКласс \MContext\m содержит два набора элементов размера~10: строковый набор'#13+
'\Mnames\m с именами доступных переменных и набор целых чисел \Mvalues\m'#13+
'со значениями соответствующих переменных (для хранения наборов можно'#13+
'использовать массивы или другие структуры данных). Конструктор класса \MContext\m'#13+
'не имеет параметров; он заносит в набор \Mnames\m односимвольные имена переменных'#13+
'от~\<a\> до~\<j\> (в алфавитном порядке), а в набор \Mvalues\m~\= нулевые значения.'#13+
'Класс \MContext\m включает три метода: \MSetVar(ind, name, value)\m, \MGetName(ind)\m,'#13+
'\MGetValue(ind)\m. Параметр \Mind\m во всех методах определяет индекс обрабатываемой'#13+
'переменной (число от~0 до~9). Метод \MSetVar\m задает для переменной'#13+
'с индексом \Mind\m имя (строку \Mname\m) и значение (целое число \Mvalue\m).'#13+
'Метод \MGetName\m возвращает имя переменной с индексом \Mind\m, метод \MGetValue\m'#13+
'возвращает значение переменной с индексом \Mind\m. При реализации этих методов'#13+
'можно не проверять допустимость значений параметра \Mind\m, а также'#13+
'не контролировать возможную ошибочную ситуацию, когда два элемента набора'#13+
'\Mnames\m совпадают (т.\,е. когда две разные переменные имеют одинаковые имена).'#13+
'\PКласс \MNontermConcat\m содержит структуру данных \Mexprs\m (например, массив)'#13+
'с элементами-ссылками типа \MAbstractExpression\m, которая инициализируется'#13+
'в конструкторе, имеющем соответствующий параметр-структуру. Можно считать,'#13+
'что выражение concat содержит не более 5 выражений expr.'#13+
'\PКласс \MNontermIf\m содержит поля \Mexpr1\m и \Mexpr2\m~\= ссылки на объекты'#13+
'\MAbstractExpression\m (первое и второе выражение expr в правой части определения'#13+
'выражения if)~\= и целочисленное поле \Mind\m (индекс переменной var'#13+
'в некотором объекте-контексте). Класс \MNontermLoop\m содержит поле \Mexpr\m~\='#13+
'ссылку на объект \MAbstractExpression\m (выражение expr в правой части определения'#13+
'выражения loop)~\= и целочисленное поле \Mind\m (индекс переменной var в некотором'#13+
'объекте-контексте). Значения полей классов \MNontermIf\m и \MNontermLoop\m задаются'#13+
'в их конструкторах с помощью одноименных параметров.'#13+
'\PКласс \MTermStr\m содержит строковое поле \Ms\m, задаваемое в конструкторе'#13+
'с помощью строкового параметра. В методах \MInterpretA\m и \MInterpretB\m этого класса'#13+
'должно возвращаться значение поля~\Ms\m без каких-либо изменений.'#13+
TestHeader+
'Дано целое число {N} (\l\,30) и {N} наборов значений, каждый из которых определяет'#13+
'один узел синтаксического дерева разбора. Последующие узлы могут содержать'#13+
'ссылки на предыдущие, поэтому все узлы следует сохранять в коллекции \Mnodes\m'#13+
'(например, массиве) с элементами-ссылками типа \MAbstractExpression\m. Каждый'#13+
'набор, соответствующий узлу синтаксического дерева, начинается с символа \<C\>,'#13+
'\<I\>, \<L\> или \<S\>. Объекту класса \MNontermConcat\m соответствует символ \<C\>,'#13+
'за которым следует целое число {K} (2~\l~{K}~\l~5) и {K} индексов узлов'#13+
'из уже заполненной части коллекции \Mnodes\m (индексирование элементов коллекции'#13+
'\Mnodes\m ведется от~0); все узлы в указанном порядке должны входить в структуру'#13+
'\Mexprs\m объекта \MNontermConcat\m. Объекту класса \MNontermIf\m соответствует'#13+
'символ \<I\>, за которым следует индекс~{V} переменной в некотором'#13+
'контексте (целое число в диапазоне от~0 до~9) и индексы двух узлов'#13+
'из уже заполненной части коллекции \Mnodes\m. Объекту класса \MNontermLoop\m'#13+
'соответствует символ \<L\>, за которым следует индекс~{V} переменной в некотором'#13+
'контексте и индекс некоторого узла из уже заполненной части коллекции \Mnodes\m.'#13+
'Наконец, объекту класса \MTermStr\m соответствует символ \<S\>, за которым'#13+
'следует строка~\= значение выражения str.'#13+
'\PТакже даны три набора значений, определяющих три различных контекста.'#13+
'Определение каждого контекста содержит целое число {M} (\l\,10) и {M} наборов троек'#13+
'({ind}, {name}, {val}), в которых {ind} определяет индекс переменной в контексте,'#13+
'{name} определяет имя переменной, а {val}~\= ее значение (для остальных переменных'#13+
'контекста сохраняются имена и значения по умолчанию).'#13+
'\PИспользуя исходные данные, сформировать элементы синтаксического дерева'#13+
'разбора и сохранить их в коллекции \Mnodes\m, а также создать и настроить'#13+
'три объекта типа \MContext\m. Для последнего элемента коллекции \Mnodes\m вызвать'#13+
'методы \MInterpretA\m и \MInterpretB\m, указав в качестве параметра каждый'#13+
'из созданных контекстов, и вывести их возвращаемые значения (вначале выводятся'#13+
'значения, соответствующие первому контексту, затем второму, затем третьему).'
);
repeat
    m := 0;
    n := 0;
    b := false;
    n1 := Random(4)+4;
    check2 := 6;
    check7 := 2;
    if CurrentTest = 1 then
    begin
      n1 := 4;
      check2 := 1;
      check7 := 1;
    end;
    avail := '';
    for i := 1 to 7 do
      cnt[i] := 0;

    for i := 0 to n1-1 do
    begin
          nodes[i].t := 'S';
          nodes[i].s := '';
          for k := 1 to Random(3) + 1 do
            nodes[i].s := nodes[i].s + chr(Random(26)+65);
          inc(cnt[1]);
          addavail(i);
    end;
    for i := n1 to 30 do
    begin
     if length(avail) = 1 then
     begin
       b := true;
       break;
     end;
     case Random(3) of
     0:
     begin
       nodes[i].t := 'C';
       nodes[i].varind := random(3) + 2;
       if length(avail) < nodes[i].varind then
         nodes[i].varind := length(avail);
       for k := 1 to nodes[i].varind do
       begin
         nodes[i].nodes[k] := randomavail;
         removeavail(nodes[i].nodes[k]);
       end;
       inc(cnt[2]);
       end;
     1: begin
          nodes[i].t := 'I';
          nodes[i].varind := random(10);
          nodes[i].node1 := randomavail;
          removeavail(nodes[i].node1);
          nodes[i].node2 := randomavail;
          removeavail(nodes[i].node2);
          inc(cnt[3]);
        end;
     2: begin
          nodes[i].t := 'L';
          nodes[i].varind := random(10);
          nodes[i].node1 := randomavail;
          removeavail(nodes[i].node1);
          inc(cnt[4]);
        end;
     end;
    addavail(i);
    n := i+1;
  end;
  if b then
  begin
//  res1 := InterpA(n-1);
//  res2 := InterpB(n-1);
  end;
until b and (cnt[1] * cnt[2] * cnt[3] * cnt[4] > 0) and
      (length(InterpA(n-1)) < 60);
{     b and (cnt[1] * cnt[2] * cnt[3] * cnt[4] * cnt[5] * cnt[6] > 0)
     and (cnt[2] > check2) and (cnt[7] > check7) and (cnt[7] < cnt[2])
     and (length(res1) < 76);}
    DataN('N = ', n, 0,1,1);
    y := 1;
    step := 19;
    for i := 0 to n - 1 do
    begin
      if i mod 4 = 0 then
        y := y + 1;
      x := 2 + step * (i mod 4);
      ir := nodes[i];
      DataC('', ir.t, x, y);
      case ir.t of
      'S': DataS('', ir.s, x + 4, y);
      'I': begin
             DataN('V=', ir.varind, x + 4, y, 1);
             DataN('', ir.node1, x + 8, y, 2);
             DataN('', ir.node2, x + 11, y, 2);
           end;
      'L': begin
             DataN('V=', ir.varind, x + 4, y, 1);
             DataN('', ir.node1, x + 8, y, 2);
           end;
      'C': begin
             DataN('', ir.varind, x + 4, y, 1);
             DataComment(':', x+5, y);
             for k := 1 to ir.varind do
               DataN('', ir.nodes[k], x + 4 + 3*k, y, 2);
           end;
      end;
    end;
for k := 1 to 3 do
begin
    k2 := 0;
    repeat
    k2 := k2 + 1;
    m := Random(3) + 3;
    for i := 0 to 9 do
    begin
      cont[i].name := chr(97+i);
      cont[i].val := 0;
    end;
    for i := 0 to m-1 do
    begin
          k1 := Random(10);
          while not (cont[k1].name[1] in ['a'..'j']) do
            k1 := Random(10);
          cont[k1].name := chr(10 + Random(16)+ 97) + Inttostr(k1);
          cont[k1].val := Random(3) + 2;
    end;
    res[k] := InterpB(n-1);
    until (length(res[k]) < 75) and (res[k] <> '') and
    ((k=1) or (k=2) and (res[2] <> res[1]) or
    (k=3) and (res[3] <> res[2]) and (res[3] <> res[1]) or (k2 > 100));

        y := y + 1;
    DataComment('Контекст '+IntToStr(k) + ':', 2, y);
    DataN('M = ', m, 0,y,1);
    step := 27;
    k1 := -1;
    for i := 0 to 9 do
    begin
      if not (cont[i].name[1] in ['a'..'j']) then
        k1 := k1 + 1
      else
        continue;
      if k1 mod 3 = 0 then
        y := y + 1;
      x := 3 + step * (k1 mod 3);
      DataN('ind=', i, x, y, 1);
      DataS('name=', cont[i].name, x + 6, y);
      DataN('val=', cont[i].val, x + 16, y, 1);
    end;




    ResultComment('Результаты, соответствующие контексту '+IntToStr(k) + ':', 0, 3*k-2);
    ResultS('', InterpA(n-1), 0, 3*k-1);
    ResultS('', res[k], 0, 3*k);
    end;

SetTestCount(9);
end;




procedure InitTask(num: integer); stdcall;
begin
  case num of
  1: Pat5;
  2: Pat6;
  3: Pat1;
  4: Pat2;
  5: Pat3;
  6: Pat4;
  7: Pat11;
  8: Pat7;
  9: Pat8;
  10: Pat9;
  11: Pat10;
  12: Pat13;
  13: Pat14;
  14: Pat15;
  15: Pat12;
  16: Pat16;
  17: Pat17;
  end;
end;

procedure inittaskgroup;
begin
  // процедура inittaskgroup должна быть оформлена как экспортируемая
  // процедура данной библиотеки; в ней выполняется вызов стартовой
  // процедуры CreateGroup и могут вызываться процедуры, связанные
  // с добавлением комментариев (преамбул) для группы и ее подгрупп
  if CurrentLanguage = lgC then
    exit;
  CreateGroup('OOP3Behav', 'Паттерны поведения',
    'М. Э. Абрамян, 2022', 'qwке657#EnTopic<Behavioral patterns>#777785ьdfttd', 17, InitTask);
end;

//exports inittaskgroup, activate;

begin
end.
