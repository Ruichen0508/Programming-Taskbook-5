{$A+,B-,D-,E+,F-,G-,I+,L-,N+,O-,P-,Q-,R-,S-,T-,V+,X+,Y-}

//---------------------------------
unit PT4MPI8Inter_ru;

{$MODE Delphi}

interface


procedure InitTask(num: integer); stdcall;
procedure inittaskgroup;


implementation


uses PT5TaskMaker, SysUtils;

//-----------------------------------

const
  alphabet = '0123456789abcdefghijklmnopqrstuvwxyz';
  prcname = 'Процесс %d: ';
  title1 = 'Создание интеркоммуникаторов';
  title2 = 'Коллективные операции для интеркоммуникаторов';
  title3 = 'Динамическое создание процессов';

  DebugSec = 'Содержимое раздела отладки должно быть следующим:';
  DebugSec1 = 'Возможные варианты содержимого раздела отладки в случае верного решения:';


function RandomName(len: integer): string;
var i: integer;
begin
  result := '';
  for i := 1 to len do
    result := result + alphabet[Random(length(alphabet))+1];
end;

function Prc(n: integer): string;
begin
  result := Format(prcname, [n]);
end;

function PrcLong(n, nmax: integer): string;
begin
  result := Format(prcname, [n]);
  if (nmax > 10) and (n < 10) then
    result := result + ' ';
end;

procedure SwapN(var a,b: integer);
var c: integer;
begin
  c := a;
  a := b;
  b := c;
end;

procedure SwapR(var a,b: real);
var c: real;
begin
  c := a;
  a := b;
  b := c;
end;

var a: array[0..64] of integer;
    b, b1: array[0..64] of real;
    n, m, k: integer;

procedure MPIInter1;
var
  i, j, k0, x1, x2, y1, y2, l: integer;
begin
  n := 2*RandomN(3,6);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дано целое число~{X}.'#13#10
+'Используя функции MPI\_Comm\_group, MPI\_Group\_range\_incl и MPI\_Comm\_create,'#13#10
+'создать коммуникаторы, первый из которых содержит процессы четного ранга'#13#10
+'в том же порядке (0, 2,~\., {K}/2~\-~2), а второй \= процессы нечетного ранга'#13#10
+'в том же порядке (1, 3,~\., {K}/2~\-~1). Вывести ранги процессов {R} в созданных'#13#10
+'коммуникаторах. Затем объединить созданные коммуникаторы в интеркоммуникатор'#13#10
+'с помощью функции MPI\_Intercomm\_create. Используя функции MPI\_Send и MPI\_Recv'#13#10
+'для созданного интеркоммуникатора, получить для каждого процесса число {X}'#13#10
+'из процесса того же ранга, входящего в другую группу этого же'#13#10
+'интеркоммуникатора, и вывести полученные числа.'
);
  l := length(prclong(1,n));
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    a[i] := RandomN(10,99);
    x1 := 1 + 40 * ((i) mod 2);
{    if not Odd(i) then
    begin
      x1 := 1;
    end
    else
    begin
      x1 := 40;
    end;}
    y1 := (i) div 2 + 1;
    DataN(prclong(i,n)+ 'X = ', a[i], x1, y1, 2);
  end;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
    if not Odd(i) then
    begin
//      x1 := 1;
      k0 := a[i+1];
    end
    else
    begin
//      x1 := 40;
      k0 := a[i-1];
    end;
//    x1 := x1 + l;
    y1 := (i) div 2 + 1;
    ResultN(prclong(i,n) + 'R = ', y1-1, x1, y1, 1);
    x1 := x1 + l + 7;
    ResultN('X = ', k0, x1, y1, 2);
  end;
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);

end;

procedure MPIInter2;
var
  i, j, x1, x2, y1, y2, l: integer;
  c: array[0..50] of integer;
  k0, k1: integer;
begin
  n := 2*RandomN(3,6);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дано целое число {C}'#13#10
+'и вещественное число {X}. Числа {C} равны либо 0, либо 1, количество значений 1'#13#10
+'равно количеству значений 0, причем в процессе ранга 0 дано {C}, равное 0,'#13#10
+'а в процессе ранга {K}~\-~1 дано {C}, равное 1. Используя один вызов функции'#13#10
+'MPI\_Comm\_split, создать коммуникаторы, первый из которых содержит процессы'#13#10
+'со значениями {C}~=~0 в том же порядке, а второй \= процессы со значениями {C}~=~1'#13#10
+'в обратном порядке. Вывести ранги процессов {R} в созданных коммуникаторах'#13#10
+'(при этом значение {R}~=~0 получат первый и последний процессы исходного'#13#10
+'коммуникатора MPI\_COMM\_WORLD). Затем объединить созданные коммуникаторы'#13#10
+'в интеркоммуникатор с помощью функции MPI\_Intercomm\_create. Используя функции'#13#10
+'MPI\_Send и MPI\_Recv для созданного интеркоммуникатора, получить для каждого'#13#10
+'процесса число {X} из процесса того же ранга, входящего в другую группу этого'#13#10
+'интеркоммуникатора, и вывести полученные числа.'
);
  l := length(prclong(1,n));
  for i := 1 to n - 2 do
    a[i] := i;
  for i := 1 to 2 * n do
    SwapN(a[RandomN(1, n-2)], a[RandomN(1, n-2)]);
  c[0] := 0;
  c[n-1] := 1;
  for i := 1 to n  div 2 - 1 do
    c[a[i]] := 0;
  for i := n div 2 to n-2 do
    c[a[i]] := 1;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    b[i] := RandomR(1.0,9.9);
    x1 := 1 + 40 * ((i) mod 2);
{    if not Odd(i) then
    begin
      x1 := 1;
    end
    else
    begin
      x1 := 40;
    end;}
    y1 := (i) div 2 + 1;
    DataN(prclong(i,n)+'C = ', c[i], x1, y1, 1);
    x1 := x1 + l + 7;
    DataR('X = ', b[i], x1, y1, 4);
  end;

  k0 := 0;
  k1 := n-1;
  for i := 1 to n div 2 do
  begin
    while c[k0] = 1 do
      k0 := k0 + 1;
    while c[k1] = 0 do
      k1 := k1 - 1;
    a[k0] := i-1;
    a[k1] := i-1;
    SwapR(b[k0], b[k1]);
    k0 := k0 + 1;
    k1 := k1 - 1;
  end;


  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
    y1 := (i) div 2 + 1;
    ResultN(prclong(i,n)+'R = ', a[i], x1, y1, 1);
    x1 := x1 + l + 7;
    ResultR('X = ', b[i], x1, y1, 4);
  end;
//  DataComment(prc(0)+'--', xLeft, 10);
//  DataComment(prc(1)+'--', xRight, 10);

end;

procedure MPIInter3;
var
  i, j, x1, x2, y1, y2, l: integer;
  c: array[0..30] of real;
  k: array[0..2] of integer;
begin
  n := 3*RandomN(2,4);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} кратно 3. В процессах ранга 3{N} ({N}~=~0,~\., 3{K}~\-~3)'#13#10
+'дано вещественное число {X}, в процессах ранга 3{N}~+~1 даны вещественные числа {X}'#13#10
+'и {Y}, в процессах ранга 3{N}~+~2 дано вещественное число {Y}. Используя функции'#13#10
+'MPI\_Comm\_group, MPI\_Group\_range\_incl и MPI\_Comm\_create, создать коммуникаторы,'#13#10
+'первый из которых содержит группу процессов ранга 3{N} в том же порядке'#13#10
+'(0, 3,~\., {K}~\-~3), второй \= группу процессов ранга 3{N}~+~1 в обратном порядке'#13#10
+'({K}~\-~2, {K}~\-~5,~\., 1), а третий \= группу процессов ранга 3{N}~+~2 в том же'#13#10
+'порядке (2, 5,~\., {K}~\-~1). Вывести ранги процессов {R} в созданных'#13#10
+'коммуникаторах. Затем, используя функцию MPI\_Intercomm\_create, объединить'#13#10
+'созданные коммуникаторы в два интеркоммуникатора: первый должен содержать'#13#10
+'первую и вторую группы процессов, а второй \= вторую и третью группы. Используя'#13#10
+'функции MPI\_Send и MPI\_Recv для созданных интеркоммуникаторов, поменять'#13#10
+'числа {X} для процессов одинакового ранга, входящих в первую и вторую группу,'#13#10
+'и числа {Y} для процессов одинакового ранга, входящих во вторую и третью группу.'#13#10
+'Вывести в каждом процессе полученные числа.'#13#10
+'\P\SУказание.\s Следует обратить внимание на то, что функция MPI\_Intercomm\_create'#13#10
+'должна вызываться один раз для процессов, входящих в первую и третью группы,'#13#10
+'и два раза для процессов, входящих во вторую группу, и такое же количество'#13#10
+'вызовов должно быть для функций MPI\_Send и MPI\_Recv.'
);
  l := length(prclong(1,n));
  for i := 0 to n - 1 do
  begin
    b[i] := RandomR(1.0,9.9);
    c[i] := RandomR(1.,9.9);
  end;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    j := i div 3;
    y1 := (i) div 3 + 1;
    case i mod 3 of
    0: begin
         x1 := 1;
         DataR(prc(i)+ 'X = ', b[3*j], x1, y1, 4);
       end;
    1: begin
         x1 := 25;
         DataR(prclong(i,n)+ 'X = ', b[n-3*j-2], x1, y1, 4);
         x1 := x1 + l + 9;
         DataR('Y = ', c[n-3*j-2], x1, y1, 4);
       end;
    2: begin
         x1 := 57;
         DataR(prclong(i,n)+ 'Y = ', c[3*j+2], x1, y1, 4);
       end;
    end;
{    if not Odd(i) then
    begin
      x1 := 1;
    end
    else
    begin
      x1 := 40;
    end;}
  end;
  k[0] := 0;
  k[1] := n div 3 - 1;
  k[2] := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    j := i div 3;
    y1 := (i) div 3 + 1;
    case i mod 3 of
    0: begin
         x1 := 1;
         ResultN(prc(i) + 'R=', k[0], x1, y1, 1);
         k[0] := k[0] + 1;
         x1 := x1 + 10 + 5;
         ResultR('X=', b[3*j+1], x1, y1, 4);
       end;
    1: begin
         x1 := 25;
         ResultN(prclong(i,n) + 'R=', k[1], x1, y1, 1);
         k[1] := k[1] - 1;
         x1 := x1 + l + 4;
         ResultR('X=', b[n-3*j-3], x1, y1, 4);
         x1 := x1 + 7;
         ResultR('Y=', c[n-3*j-1], x1, y1, 4);
       end;
    2: begin
         x1 := 57;
         ResultN(prclong(i,n) + 'R=', k[2], x1, y1, 1);
         k[2] := k[2] + 1;
         x1 := x1 + l + 4;
         ResultR('Y=', c[3*j+1], x1, y1, 4);
       end;
    end;
  end;
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);

end;

procedure MPIInter4;
var
  i, j, jj, x1, x2, y1, y2, l: integer;
  col: array[0..30] of integer;
  a, b: array[0..30,0..2] of integer;
  k: array[0..2] of integer;
  a0, b0: integer;
  tita, titb: string;

begin
  n := 3*RandomN(2,4);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} кратно 3. В каждом процессе даны три целых числа.'#13#10
+'Первое число (обозначаемое буквой {C}) лежит в диапазоне от 0 до 2, причем'#13#10
+'каждое из значений 0, 1, 2 встречается одинаковое число раз (равное {K}/3)'#13#10
+'и при этом в процессах ранга 0, 1, 2 значения {C} совпадают с рангами этих'#13#10
+'процессов. Используя один вызов функции MPI\_Comm\_split, создать коммуникаторы,'#13#10
+'первый из которых содержит процессы со значениями {C}~=~0 в том же порядке,'#13#10
+'второй \= процессы со значениями {C}~=~1 в том же порядке, а третий \= процессы'#13#10
+'со значениями {C}~=~2 в том же порядке. Вывести ранги процессов {R} в созданных'#13#10
+'коммуникаторах (при этом значение {R}~=~0 получат первые три процесса исходного'#13#10
+'коммуникатора MPI\_COMM\_WORLD). Затем, используя по два вызова функции'#13#10
+'MPI\_Intercomm\_create в каждом процессе, объединить созданные коммуникаторы'#13#10
+'в три интеркоммуникатора: первый должен содержать группы процессов'#13#10
+'со значениями {C}, равными 0 и 1, второй \= группы со значениями 1 и 2,'#13#10
+'третий \= группы со значениями 0 и 2 (таким образом, созданные'#13#10
+'интеркоммуникаторы будут образовывать \Iкольцо\i, связывающее все три ранее'#13#10
+'созданные группы). Считая, что в первой группе процессов два следующих'#13#10
+'исходных числа обозначаются буквами {X} и {Y}, во второй группе \= {Y} и {Z},'#13#10
+'а в третьей \= {Z} и {X} (в указанном порядке) и используя в каждом процессе'#13#10
+'по два вызова функций MPI\_Send и MPI\_Recv для созданных интеркоммуникаторов,'#13#10
+'поменять числа {X} для процессов одинакового ранга, входящих в первую и вторую'#13#10
+'группу, числа {Y} \= для процессов одинакового ранга, входящих во вторую'#13#10
+'и третью группу, и числа {Z} \= для процессов одинакового ранга, входящих'#13#10
+'в первую и третью группу. Вывести в каждом процессе полученные числа.'
);
  l := length(prclong(1,n));
  for i := 0 to n - 1 do
  for j := 0 to 2 do
  begin
    a[i,j] := RandomN(10,99);
    b[i,j] := RandomN(10,99);
  end;
  col[0] := 0;
  col[1] := 1;
  col[2] := 2;
  for i := 1 to n div 3 - 1 do
  begin
    col[3*i] := 0;
    col[3*i+1] := 1;
    col[3*i+2] := 2;
  end;
  for i := 1 to 2 * n do
    SwapN(col[RandomN(3, n-1)], col[RandomN(3, n-1)]);
  for i := 0 to 2 do
    k[i] := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    a0 := a[k[col[i]], col[i]];
    b0 := b[k[col[i]], col[i]];
    k[col[i]] := k[col[i]] + 1;
    j := i div 3;
    y1 := (i) div 3 + 1;
    case col[i] of
    0: begin
         tita := 'X=';
         titb := 'Y=';
       end;
    1: begin
         tita := 'Y=';
         titb := 'Z=';
       end;
    2: begin
         tita := 'Z=';
         titb := 'X=';
       end;
    end;
    case i mod 3 of
    0: begin
         x1 := 1;
         DataN(prc(i) + 'C=', col[i], x1, y1, 1);
         x1 := x1 + 11 + 4;
         DataN(tita, a0, x1, y1, 2);
         x1 := x1 + 5;
         DataN(titb, b0, x1, y1, 2);
       end;
    1: begin
         x1 := 27;
         DataN(prclong(i,n) + 'C=', col[i], x1, y1, 1);
         x1 := x1 + l + 4;
         DataN(tita, a0, x1, y1, 2);
         x1 := x1 + 5;
         DataN(titb, b0, x1, y1, 2);
       end;
    2: begin
         x1 := 54;
         DataN(prclong(i,n) + 'C=', col[i], x1, y1, 1);
         x1 := x1 + l + 4;
         DataN(tita, a0, x1, y1, 2);
         x1 := x1 + 5;
         DataN(titb, b0, x1, y1, 2);
       end;
    end;
{    if not Odd(i) then
    begin
      x1 := 1;
    end
    else
    begin
      x1 := 40;
    end;}
  end;
  for i := 0 to n div 3 - 1 do
  begin
    swapN(b[i,0], a[i, 1]);
    swapN(a[i,0], b[i, 2]);
    swapN(b[i,1], a[i, 2]);
  end;
  for i := 0 to 2 do
    k[i] := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);

    a0 := a[k[col[i]], col[i]];
    b0 := b[k[col[i]], col[i]];
    j := i div 3;
    y1 := (i) div 3 + 1;
    case col[i] of
    0: begin
         tita := 'X=';
         titb := 'Y=';
       end;
    1: begin
         tita := 'Y=';
         titb := 'Z=';
       end;
    2: begin
         tita := 'Z=';
         titb := 'X=';
       end;
    end;
    case i mod 3 of
    0: begin
         x1 := 1;
         ResultN(prc(i) + 'R=', k[col[i]], x1, y1, 1);
         x1 := x1 + 11 + 4;
         ResultN(tita, a0, x1, y1, 2);
         x1 := x1 + 5;
         ResultN(titb, b0, x1, y1, 2);
       end;
    1: begin
         x1 := 27;
         ResultN(prclong(i,n) + 'R=', k[col[i]], x1, y1, 1);
         x1 := x1 + l + 4;
         ResultN(tita, a0, x1, y1, 2);
         x1 := x1 + 5;
         ResultN(titb, b0, x1, y1, 2);
       end;
    2: begin
         x1 := 54;
         ResultN(prclong(i,n) + 'R=', k[col[i]], x1, y1, 1);
         x1 := x1 + l + 4;
         ResultN(tita, a0, x1, y1, 2);
         x1 := x1 + 5;
         ResultN(titb, b0, x1, y1, 2);
       end;
    end;
    k[col[i]] := k[col[i]] + 1;
  end;
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);

end;

procedure MPIInter5;
var
  i, j, k0, k1, x1, x2, y1, y2, l: integer;
  a,b: array[0..20] of integer;
begin
  n := 4*RandomN(2,4);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} кратно 4. В каждом процессе дано целое число {X}.'#13#10
+'Используя функции MPI\_Comm\_group, MPI\_Group\_range\_incl и MPI\_Comm\_create,'#13#10
+'создать коммуникаторы, первый из которых содержит первую половину процессов'#13#10
+'(с рангами 0, 1,~\., {K}/2~\-~1 в указанном порядке), а второй \= вторую половину'#13#10
+'(с рангами {K}/2, {K}/2~+~1,~\., {K}~\-~1 в указанном порядке). Вывести ранги'#13#10
+'процессов {R}_1 в созданных коммуникаторах. Затем объединить созданные'#13#10
+'коммуникаторы в интеркоммуникатор с помощью функции MPI\_Intercomm\_create.'#13#10
+'После этого, используя функцию MPI\_Comm\_create для созданного'#13#10
+'интеркоммуникатора, получить новый интеркоммуникатор, первая группа которого'#13#10
+'содержит процессы из первой группы исходного интеркоммуникатора с четными'#13#10
+'рангами (в том же порядке), а вторая группа \= процессы из второй группы'#13#10
+'исходного интеркоммуникатора с нечетными рангами в обратном порядке (таким'#13#10
+'образом, в первую группу нового интеркоммуникатора будут входить процессы'#13#10
+'исходного коммуникатора MPI\_COMM\_WORLD с рангами 0, 2,~\., {K}/2~\-~2,'#13#10
+'а во вторую \= с рангами {K}~\-~1, {K}~\-~3,~\., {K}/2~+~1). Вывести ранги'#13#10
+'процессов {R}_2, входящих в новый интеркоммуникатор. Используя функции '#13#10
+'MPI\_Send и MPI\_Recv для нового интеркоммуникатора, получить для каждого'#13#10
+'процесса число {X} из процесса того же ранга, входящего в другую'#13#10
+'группу этого интеркоммуникатора, и вывести полученные числа.'
);
  l := length(prclong(1,n));
  for i := 0 to n div 2 - 1 do
  begin
    a[i] := RandomN(10,99);
    b[i] := RandomN(10,99);
  end;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    if not Odd(i) and (i < n div 2) then
    begin
      x1 := 1;
      y1 := (i {div 2}) + 1;
      k0 := a[i div 2];
    end
    else
    if Odd(i) and (i > n div 2) then
    begin
      x1 := 40;
      y1 := (i-n div 2) {div 2} + 1;
      k0 := b[(n - i-1) div 2];
    end
    else
    begin
        k0 := 0;
        if i < n div 2 then
        begin
          x1 := 1;
          y1 := (i {div 2}) + 1;
        end
        else
        begin
          x1 := 40;
          y1 := (i-n div 2) {div 2 } + 1;
        end;  
    end;
//      continue;
//    y1 := (i) div 2 + 1;
    DataN(prclong(i,n)+ 'X = ', k0, x1, y1, 2);
  end;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
    if i < n div 2 then
    begin
      x1 := 1;
      y1 := i + 1;
    end
    else
    begin
      x1 := 40;
      y1 := i-n div 2 + 1;
    end;
//    x1 := x1 + l;
    ResultN(prclong(i,n) + 'R_1 = ', y1-1, x1, y1, 1);
    x1 := x1 + l + 8;
    if not Odd(i) and (i < n div 2) then
    begin
      k0 := i div 2;
      k1 := b[k0];
    end
    else
    if Odd(i) and (i > n div 2) then
    begin
      k0 := (n-i-1) div 2;
      k1 := a[k0];
    end
    else
      continue;
    ResultN('R_2 = ', k0, x1, y1, 1);
    x1 := x1 + 8;
    ResultN('X = ', k1, x1, y1, 2);
  end;

//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);

end;


procedure MPIInter6;
var
  i, j, k0, x1, x2, y1, y2, l: integer;
  k1: real;
  a,b: array[0..20] of real;
begin
  n := 4*RandomN(2,4);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} кратно 4. В каждом процессе дано вещественное число {X}.'#13#10
+'Используя функции MPI\_Comm\_group, MPI\_Group\_range\_incl и MPI\_Comm\_create,'#13#10
+'создать коммуникаторы, первый из которых содержит первую половину процессов'#13#10
+'(с рангами 0, 1,~\., {K}/2~\-~1 в указанном порядке), а второй \= вторую половину'#13#10
+'(с рангами {K}/2, {K}/2~+~1,~\., {K}~\-~1 в указанном порядке). Вывести ранги'#13#10
+'процессов {R}_1 в созданных коммуникаторах. Затем объединить созданные'#13#10
+'коммуникаторы в интеркоммуникатор с помощью функции MPI\_Intercomm\_create.'#13#10
+'После этого, используя один вызов функции MPI\_Comm\_split для созданного'#13#10
+'интеркоммуникатора, получить два новых интеркоммуникатора. Первый из новых'#13#10
+'интеркоммуникаторов содержит процессы исходного интеркоммуникатора с четными'#13#10
+'рангами, а второй \= с нечетными, причем процессы во второй группе каждого из'#13#10
+'новых интеркоммуникаторов должны располагаться в обратном порядке (таким'#13#10
+'образом, если использовать ранги процессов для исходного коммуникатора'#13#10
+'MPI\_COMM\_WORLD, то первый интеркоммуникатор содержит группы процессов'#13#10
+'ранга 0, 2,~\., {K}/2~\-~2 и {K}~\-~2, {K}~\-~4,~\., {K}/2, а второй \= группы'#13#10
+'процессов ранга 1, 3,~\., {K}/2~\-~1 и {K}~\-~1, {K}~\-~3,~\., {K}/2~+~1). Вывести'#13#10
+'ранги процессов {R}_2, входящих в новые интеркоммуникаторы. Используя функции'#13#10
+'MPI\_Send и MPI\_Recv для новых интеркоммуникаторов, получить для каждого'#13#10
+'процесса число {X} из процесса того же ранга, входящего в другую группу этого'#13#10
+'интеркоммуникатора, и вывести полученные числа.'
);
  l := length(prclong(1,n));
  for i := 0 to n div 2 - 1 do
  begin
    a[i] := RandomR(1.0,9.9);
    b[i] := RandomR(1.0,9.9);
  end;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      k1 := a[i];
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      k1 := b[i-n div 2];
    end;;
//    else
//      continue;
//    y1 := (i) div 2 + 1;
    DataR(prclong(i,n)+ 'X = ', k1, x1, y1, 4);
  end;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
    if i < n div 2 then
    begin
      x1 := 1;
      y1 := i + 1;
    end
    else
    begin
      x1 := 40;
      y1 := i-n div 2 + 1;
    end;
//    x1 := x1 + l;
    ResultN(prclong(i,n) + 'R_1 = ', y1-1, x1, y1, 1);
    x1 := x1 + l + 8;
    if (i < n div 2) then
    begin
      k0 := i div 2;
      if i mod 2 = 0 then
        k1 := b[n div 2 -i  - 2]
      else
        k1 := b[n div 2 - i]
    end
    else
    begin
      k0 := (n-i-1) div 2;
      if i mod 2 = 0 then
        k1 := a[n -i  - 2]
      else
        k1 := a[n - i]
    end;
    ResultN('R_2 = ', k0, x1, y1, 1);
    x1 := x1 + 8;
    ResultR('X = ', k1, x1, y1, 4);
  end;

//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);

end;



// Проблемная задача - выявлена ошибка в MPICH
procedure MPIInter7;
var
  i, j, k0, k00, k01, k02, k1, k2, x1, x2, y1, y2, l, c1, c2, l0: integer;
  a,b: array[0..20] of integer;
  a1,b1: array[0..20] of integer;
  tit: string;
begin
  n := 2*RandomN(5,7);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дано целое число {C},'#13#10
+'равное либо 0, либо 1, причем известно, что в первой половине процессов дано'#13#10
+'единственное значение {C}~=~1, а во второй половине количество значений {C}~=~1'#13#10
+'больше одного и, кроме того, имеется хотя бы одно значение {C}~=~0. Используя'#13#10
+'функцию MPI\_Comm\_split, создать коммуникаторы, первый из которых содержит'#13#10
+'первую половину процессов (с рангами 0, 1,~\., {K}/2~\-~1 в указанном порядке),'#13#10
+'а второй \= вторую половину (с рангами {K}/2, {K}/2~+~1,~\., {K}~\-~1 в указанном'#13#10
+'порядке). Вывести ранги процессов {R}_1 в созданных коммуникаторах. Затем'#13#10
+'объединить созданные коммуникаторы в интеркоммуникатор с помощью функции'#13#10
+'MPI\_Intercomm\_create. После этого, используя функцию MPI\_Comm\_split'#13#10
+'для созданного интеркоммуникатора, получить новый интеркоммуникатор, группы'#13#10
+'которого содержат процессы из соответствующих групп исходного'#13#10
+'интеркоммуникатора со значениями {C}~=~1, взятые в обратном порядке (таким'#13#10
+'образом, в первую группу нового интеркоммуникатора будет входить единственный'#13#10
+'процесс, а количество процессов во второй группе будет лежать в диапазоне'#13#10
+'от 2 до {K}/2~\-~1). Вывести ранги процессов {R}_2, входящих в ту группу нового'#13#10
+'интеркоммуникатора, которая содержит более одного процесса. В единственном'#13#10
+'процессе первой группы нового интеркоммуникатора ввести массив {Y} из {K}_2 целых'#13#10
+'чисел, где {K}_2 \= количество процессов во второй группе; в каждом процессе'#13#10
+'второй группы этого же интеркоммуникатора ввести по одному целому числу {X}.'#13#10
+'Используя требуемое количество вызовов функций MPI\_Send и MPI\_Recv для всех'#13#10
+'процессов нового интеркоммуникатора, получить в процессе первой группы все'#13#10
+'числа {X} из процессов второй группы (в порядке возрастания рангов этих'#13#10
+'процессов), а в каждом процессе второй группы ранга {R}_2 (0, 1,~\., {K}_2~\-~1) \='#13#10
+'элемент с индексом {R}_2 из массива {Y}, данного в процессе первой группы.'#13#10
+'Вывести полученные числа.'#13#10
+'\P\SПримечание.\s В реализации MPIСH 2 версии 1.3, используемой в задачнике, функция'#13#10
+'MPI\_Comm\_split приводит к ошибочной программе, если она применяется'#13#10
+'к интеркоммуникатору и при этом какие-либо из значений ее параметра color'#13#10
+'равны MPI\_UNDEFINED. Таким образом, для корректной работы программ необходимо'#13#10
+'использовать только \Iнеотрицательные\i значения color. Кроме того, программа'#13#10
+'в дальнейшем может вести себя некорректно, если в результате применения'#13#10
+'функции MPI\_Comm\_split к интеркоммуникатору создаются \Iпустые группы\i'#13#10
+'(это возможно, если для некоторых процессов одной из групп исходного'#13#10
+'интеркоммуникатора указываются значения color, отличные от всех'#13#10
+'значений color для процессов другой группы).'
);
  l := length(prclong(1,n));

  k00 := RandomN(2, n div 2 - 2);
  // если положить k00 := n div 2 - 1, то с помощью MPI_Comm_split для интеркоммуникаторов задачу
  // решить не удастся! (не сработает правильное расщепление, так как в одной группе не будет элементов
  // с c=0).
  k1 := 1;
  k2 := k00;
  k0 := RandomN(0,1);
  if k0 = 1 then
    SwapN(k1, k2);
  for i := 0 to n div 2 - 1 do
  begin
    a[i] := 0;
    b[i] := 0;
  end;
  a[0] := 1;
  b[0] := 1;
  for i := 0 to k00 do
  begin
    if k0 = 0 then
      b[i] := 1
    else
      a[i] := 1;
    a1[i] := RandomN(10,99);
    b1[i] := RandomN(10,99);
  end;
  for i := 1 to 2 * n do
  begin
    SwapN(a[RandomN(0, n div 2-1)], a[RandomN(0, n div 2-1)]);
    SwapN(b[RandomN(0, n div 2-1)], b[RandomN(0, n div 2-1)]);
  end;

  k01 := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      c1 := a[i];
      k02 := k1;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      c1 := b[i-n div 2];
      k02 := k2;
    end;;
//    else
//      continue;
//    y1 := (i) div 2 + 1;
    DataN(prclong(i,n)+ 'C=', c1, x1, y1, 1);
    if c1 = 1 then
      if k02 = 1 then
      begin
        x1 := x1 + l + 6;
        DataComment('Y: ', x1, y1);
        for j := 0 to k00 do
        begin
           x1 := x1 + 3;
           DataN(b1[k00-j], x1, y1, 2);
        end;
      end
      else
      begin
        x1 := x1 + l + 6;
        DataN('X=', a1[k00-k01], x1, y1, 2);
        k01 := k01 + 1;
      end;
//    DataR(prclong(i,n)+ 'X=', k1, x1, y1, 4);
  end;


  k01 := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      c1 := a[i];
      k02 := k1;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      c1 := b[i-n div 2];
      k02 := k2;
    end;;
//    else
//      continue;
//    y1 := (i) div 2 + 1;
//    DataN(prclong(i,n)+ 'C=', c1, x1, y1, 1);
    ResultN(prclong(i,n) + 'R_1=', y1-1, x1, y1, 1);

    if c1 = 1 then
      if k02 = 1 then
      begin
        x1 := x1 + l + 6;
//        ResultN('R_2=', 0, x1, y1,1);
//        x1 := x1 + 5;
        ResultComment('X: ', x1, y1);
        for j := 0 to k00 do
        begin
           x1 := x1 + 3;
           ResultN(a1[j], x1, y1, 2);
        end;
      end
      else
      begin
        x1 := x1 + l + 6;
        ResultN('R_2=', k00-k01, x1, y1, 1);
        x1 := x1 + 6;
        ResultN('Y=', b1[k01], x1, y1, 2);
        k01 := k01 + 1;
      end;
//    DataR(prclong(i,n)+ 'X=', k1, x1, y1, 4);
  end;

  {
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
    if i < n div 2 then
    begin
      x1 := 1;
      y1 := i + 1;
    end
    else
    begin
      x1 := 40;
      y1 := i-n div 2 + 1;
    end;
//    x1 := x1 + l;
    ResultN(prclong(i,n) + 'R_1 = ', y1-1, x1, y1, 1);
    x1 := x1 + l + 8;
    if (i < n div 2) then
    begin
      k0 := i div 2;
      if i mod 2 = 0 then
        k1 := b[n div 2 -i  - 2]
      else
        k1 := b[n div 2 - i]
    end
    else
    begin
      k0 := (n-i-1) div 2;
      if i mod 2 = 0 then
        k1 := a[n -i  - 2]
      else
        k1 := a[n - i]
    end;
    ResultN('R_2 = ', k0, x1, y1, 1);
    x1 := x1 + 8;
    ResultR('X = ', k1, x1, y1, 4);
  end;
}
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);

end;

// Проблемная задача - выявлена ошибка в MPICH
procedure MPIInter8;
var
  i, j, k0, k00, k01, k02, k1, k2, x1, x2, y1, y2, l, c1, c2, l0: integer;
  a,b,c: array[0..20] of integer;
  a1,b1,cc: array[0..20] of integer;
  ka, kb: array[0..2] of integer;
  tit: string;
  f: boolean;
begin
  n := 2*RandomN(5,7);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дано целое число {C}, лежащее в диапазоне от 0 до 2, причем'#13#10
+'известно, что и у процессов четного ранга, и у процессов нечетного ранга'#13#10
+'имеется хотя бы по одному из значений 0, 1, 2. Используя один вызов функции'#13#10
+'MPI\_Comm\_split, создать коммуникаторы, первый из которых содержит процессы'#13#10
+'с четными рангами (в порядке возрастания рангов), а второй \= процессы'#13#10
+'с нечетными рангами (также в порядке возрастания рангов). Вывести ранги'#13#10
+'процессов {R}_1 в созданных коммуникаторах. Затем объединить созданные'#13#10
+'коммуникаторы в интеркоммуникатор с помощью функции MPI\_Intercomm\_create.'#13#10
+'После этого, используя один вызов функции MPI\_Comm\_split для созданного'#13#10
+'интеркоммуникатора, получить три новых интеркоммуникатора, группы которых'#13#10
+'содержат процессы из соответствующих групп исходного интеркоммуникатора'#13#10
+'с одинаковыми значениями {C}, взятые в том же порядке (таким образом, в первую'#13#10
+'группу первого интеркоммуникатора будут входить процессы четного ранга'#13#10
+'со значениями {C}~=~0, а, например, во вторую группу третьего интеркоммуникатора'#13#10
+'будут входить процессы нечетного ранга со значениями {C}~=~2). Вывести ранги'#13#10
+'процессов {R}_2 в новых интеркоммуникаторах. В процессах из первых групп'#13#10
+'созданных интеркоммуникаторов ввести по одному целому числу {X}, а в процессах'#13#10
+'из вторых групп \= по одному целому числу {Y}. Используя требуемое количество'#13#10
+'вызовов функций MPI\_Send и MPI\_Recv для всех процессов новых'#13#10
+'интеркоммуникаторов, переслать все числа {X} каждому из процессов второй группы'#13#10
+'этого же коммуникатора, а все числа {Y} \= каждому из процессов первой группы'#13#10
+'и вывести полученные числа в порядке возрастания рангов'#13#10
+'переславших их процессов.'
);
  l := length(prclong(1,n));

//  k00 := RandomN(2, n div 2 - 2);
  // если положить k00 := n div 2 - 1, то с помощью MPI_Comm_split для интеркоммуникаторов задачу
  // решить не удастся! (не сработает правильное расщепление, так как в одной группе не будет элементов
  // с c=0).
//  k1 := 1;
//  k2 := k00;
//  k0 := RandomN(0,1);
//  if k0 = 1 then
//    SwapN(k1, k2);
  for i := 0 to n div 2 - 1 do
  begin
    a1[i] := RandomN(10,99);
    b1[i] := RandomN(10,99);
  end;
  a[0] := 0;
  a[1] := 1;
  a[2] := 2;
  b[0] := 0;
  b[1] := 1;
  b[2] := 2;
  repeat
  f := true;
  for i := 0 to 2 do
  begin
    ka[i] := 1;
    kb[i] := 1;
  end;

  for i := 3 to n div 2 - 1 do
  begin
    a[i] := RandomN(0,2);
    Inc(ka[a[i]]);
    b[i] := RandomN(0,2);
    Inc(kb[b[i]]);
    if (ka[a[i]] > 4) or (kb[b[i]] > 4) then
    begin
      f := false;
      break;
    end;
  end;
  until f;
  for i := 1 to 2 * n do
  begin
    SwapN(a[RandomN(0, n div 2-1)], a[RandomN(0, n div 2-1)]);
    SwapN(b[RandomN(0, n div 2-1)], b[RandomN(0, n div 2-1)]);
  end;

  k01 := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    if not Odd(i) then
    begin
      x1 := 1;
      y1 := i div 2 + 1;
      c1 := a[i div 2];
      c2 := a1[i div 2];
      tit := 'X=';
    end
    else
    begin
      x1 := 40;
      y1 := (i div 2) + 1;
      c1 := b[i div 2];
      c2 := b1[i div 2];
      tit := 'Y=';
    end;;
//    else
//      continue;
//    y1 := (i) div 2 + 1;
    DataN(prclong(i,n)+ 'C=', c1, x1, y1, 1);
     x1 := x1 + l + 6;
     DataN(tit, c2, x1, y1, 2);
//    DataR(prclong(i,n)+ 'X=', k1, x1, y1, 4);
  end;


  for i := 0 to 2 do
  begin
    ka[i] := 0;
    kb[i] := 0;
  end;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    if not Odd(i) then
    begin
      x1 := 1;
      y1 := i div 2 + 1;
      c1 := a[i div 2];
      k0 := ka[c1];
      Inc(ka[c1]);
      tit := 'Y: ';
      c := b;
      cc := b1;
    end
    else
    begin
      x1 := 40;
      y1 := (i div 2) + 1;
      c1 := b[i div 2];
      k0 := kb[c1];
      Inc(kb[c1]);
      tit := 'X: ';
      c := a;
      cc := a1;
    end;;
//    else
//      continue;
//    y1 := (i) div 2 + 1;
//    DataN(prclong(i,n)+ 'C=', c1, x1, y1, 1);
    ResultN(prclong(i,n) + 'R_1=', y1-1, x1, y1, 1);

       x1 := x1 + l + 6;
        ResultN('R_2=', k0, x1, y1, 1);
        x1 := x1 + 6;
        ResultComment(tit, x1, y1);
//        x1 := x1 + 1;
        for j := 0 to n div 2 - 1 do
          if c[j] = c1 then
          begin
          x1 := x1 + 3;
          ResultN(cc[j], x1, y1, 2);
          end;
//        k01 := k01 + 1;
//    DataR(prclong(i,n)+ 'X=', k1, x1, y1, 4);
  end;

  {
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
    if i < n div 2 then
    begin
      x1 := 1;
      y1 := i + 1;
    end
    else
    begin
      x1 := 40;
      y1 := i-n div 2 + 1;
    end;
//    x1 := x1 + l;
    ResultN(prclong(i,n) + 'R_1 = ', y1-1, x1, y1, 1);
    x1 := x1 + l + 8;
    if (i < n div 2) then
    begin
      k0 := i div 2;
      if i mod 2 = 0 then
        k1 := b[n div 2 -i  - 2]
      else
        k1 := b[n div 2 - i]
    end
    else
    begin
      k0 := (n-i-1) div 2;
      if i mod 2 = 0 then
        k1 := a[n -i  - 2]
      else
        k1 := a[n - i]
    end;
    ResultN('R_2 = ', k0, x1, y1, 1);
    x1 := x1 + 8;
    ResultR('X = ', k1, x1, y1, 4);
  end;
}
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);

end;


procedure MPIInter9;
var
  i, j, k0, k00, k01, k02, k1, k2, x1, x2, y1, y2, l, c1, n0, l0: integer;
  a: array[1..20] of integer;
  a1,b1, a2, b2, c2: array[1..20] of integer;
  tit: string;
begin
  n := 2*RandomN(4,6);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дано целое число {C},'#13#10
+'лежащее в диапазоне от 0 до 2, причем известно, что в процессе ранга 0 дано'#13#10
+'число {C}~=~1, а первое из значений {C}~=~2 имеется у процесса ранга {K}/2.'#13#10
+'Используя функцию MPI\_Comm\_split, создать коммуникаторы, первый из которых'#13#10
+'содержит процессы со значениями {C}~=~1 в том же порядке, а второй \= процессы'#13#10
+'со значениями {C}~=~2 в том же порядке. Вывести ранги процессов {R} в созданных'#13#10
+'коммуникаторах (если процесс не входит ни в один из созданных коммуникаторов,'#13#10
+'то вывести для него число~\-1). Затем объединить созданные коммуникаторы'#13#10
+'в интеркоммуникатор с помощью функции MPI\_Intercomm\_create. После этого ввести'#13#10
+'в процессах первой группы созданного интеркоммуникатора (соответствующей'#13#10
+'значениям {C}~=~1) по одному целому числу {X}, а в процессах второй группы \='#13#10
+'по одному целому числу {Y}. Используя требуемое количество вызовов функций'#13#10
+'MPI\_Send и MPI\_Recv для всех процессов созданного интеркоммуникатора,'#13#10
+'переслать все числа {X} каждому из процессов второй группы этого коммуникатора,'#13#10
+'а все числа {Y} \= каждому из процессов первой группы и вывести полученные числа'#13#10
+'в порядке возрастания рангов переславших их процессов.'
);
  l := length(prclong(1,n));
  n0 := n div 2;
  for i := 1 to n do
  begin
    a[i] := 0;
    a1[i] := RandomN(10,99);
    b1[i] := RandomN(10,99);
  end;
  a[1] := 1;
  a[n0+1] := 2;
  k01 := 1;
  k02 := 1;
  for i := 2 to n0 do
    if RandomN(0,1) = 0 then
    begin
      a[i] := 1;
      k01 := k01 + 1;
    end;
  for i := n0 + 2 to n do
    if RandomN(0,1) = 0 then
    begin
      a[i] := 2;
      k02 := k02 + 1;
    end;
  k1 := 1;
  k2 := 1;
  for i := 1 to n do
  begin
    if a[i] = 1 then
    begin
      a2[k1] := a1[i];
      k1 := k1 + 1;
    end
    else
    if a[i] = 2 then
    begin
      b2[k2] := b1[i];
      k2 := k2 + 1;
    end
  end;



  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      c1 := a1[i+1];
      tit := 'X=';
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      c1 := b1[i+1];
      tit := 'Y=';
    end;
    DataN(prclong(i,n)+ 'C=', a[i+1], x1, y1, 1);
    x1 := x1 + l + 6;
    if a[i+1] <> 0 then
      DataN(tit, c1, x1, y1, 2);
  end;
  k1 := 0;
  k2 := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    c1 := -1;
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      if a[i+1] = 1 then
      begin
        c1 := k1;
        k1 := k1 + 1;
      end;
      tit := 'Y: ';
      k0 := k02;
      c2 := b2;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      if a[i+1] = 2 then
      begin
        c1 := k2;
        k2 := k2 + 1;
      end;
      tit := 'X: ';
      k0 := k01;
      c2 := a2;
    end;
    ResultN(prclong(i,n)+ 'R=', c1, x1, y1, 2);
    x1 := x1 + l + 6;
    if c1 <> -1 then
    begin
    ResultComment(tit, x1, y1);
    x1 := x1 + 3;
    for j := 1 to k0 do
    begin
      ResultN(c2[j], x1, y1, 2);
      x1 := x1 + 3;
    end;
    end;
  end;
end;


procedure MPIInter10;
var
  i, j, k0, k00, k01, k02, k11, k12, k1, k2, x1, x2, y1, y2, l, c1, c3, n0, l0, root1, root2, root0, root0a: integer;
  a: array[1..20] of integer;
  a1,b1, a2, b2, c2: array[1..20] of integer;
  tit: string;
begin
  n := 2*RandomN(4,6);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дано целое число {C},'#13#10
+'лежащее в диапазоне от 0 до 2, причем известно, что в процессе ранга 0 дано'#13#10
+'число {C}~=~1, а первое из значений {C}~=~2 имеется у процесса ранга {K}/2.'#13#10
+'Используя функцию MPI\_Comm\_split, создать коммуникаторы, первый из которых'#13#10
+'содержит процессы со значениями {C}~=~1 в том же порядке, а второй \= процессы'#13#10
+'со значениями {C}~=~2 в том же порядке. Вывести ранги процессов {R} в созданных'#13#10
+'коммуникаторах (если процесс не входит ни в один из созданных коммуникаторов,'#13#10
+'то вывести для него число~\-1). Затем объединить созданные коммуникаторы'#13#10
+'в интеркоммуникатор с помощью функции MPI\_Intercomm\_create (группа, содержащая'#13#10
+'процессы со значениями {C}~=~1, считается первой группой созданного'#13#10
+'интеркоммуникатора, а группа процессов со значениями {C}~=~2 \= второй).'#13#10
+'После этого ввести в процессах обеих групп созданного интеркоммуникатора целые'#13#10
+'числа {R}_1 и {R}_2. Значения чисел {R}_1 во всех процессах совпадают и указывают ранг'#13#10
+'выделенного процесса первой группы; значения чисел {R}_2 во всех процессах также'#13#10
+'совпадают и указывают ранг выделенного процесса второй группы. В выделенном'#13#10
+'процессе первой группы дан набор из трех целых чисел {X}, в выделенном процессе'#13#10
+'второй группы \= набор из трех целых чисел {Y}. Используя по два вызова'#13#10
+'коллективной функции MPI\_Bcast в каждом процессе созданного'#13#10
+'интеркоммуникатора, переслать набор чисел {X} во все процессы второй группы,'#13#10
+'а набор чисел {Y} во все процессы первой группы,'#13#10
+'после чего вывести полученные числа.'
);
  l := length(prclong(1,n));
  n0 := n div 2;
  for i := 1 to n do
  begin
    a[i] := 0;
    a1[i] := RandomN(10,99);
    b1[i] := RandomN(10,99);
  end;
  a[1] := 1;
  a[n0+1] := 2;
  k01 := 1;
  k02 := 1;
  for i := 2 to n0 do
    if RandomN(0,1) = 0 then
    begin
      a[i] := 1;
      k01 := k01 + 1;
    end;
  for i := n0 + 2 to n do
    if RandomN(0,1) = 0 then
    begin
      a[i] := 2;
      k02 := k02 + 1;
    end;
  k1 := 1;
  k2 := 1;
  for i := 1 to n do
  begin
    if a[i] = 1 then
    begin
      a2[k1] := a1[i];
      k1 := k1 + 1;
    end
    else
    if a[i] = 2 then
    begin
      b2[k2] := b1[i];
      k2 := k2 + 1;
    end
  end;
  root1 := RandomN(1, k01);
  root2 := RandomN(1, k02);

  k11 := 0;
  k12 := 0;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      c1 := a1[i+1];
      c3 := a[i+1];
      tit := 'X: ';
      root0 := root2 - 1;
      root0a := root1 - 1;
      k0 := 0;
      if a[i+1] = 1 then k11 := k11 + 1;
      if k11 = root1 then
      begin
        k0 := 1;
        c2 := a1;
//        c3 := -c3;

      end;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      c1 := b1[i+1];
      c3 := a[i+1];
      tit := 'Y: ';
      root0 := root1 - 1;
      root0a := root2 - 1;
      k0 := 0;
      if a[i+1] = 2 then k12 := k12 + 1;
      if k12 = root2 then
      begin
        k0 := 1;
        c2 := b1;
//        c3 := -c3;

      end;
    end;
    DataN(prclong(i,n)+ 'C=', c3, x1, y1, 1);
    x1 := x1 + l + 4;
    if a[i+1] <> 0 then
    begin
      DataN('R_1=', root1-1, x1, y1, 1);
      x1 := x1 + 5;
      DataN('R_2=', root2-1, x1, y1, 1);
      if k0 = 1 then
      begin
        x1 := x1 + 6;
        DataComment(tit, x1, y1);
        x1 := x1 + 3;
        for j := 1 to 3 do
        begin
           DataN(c2[j], x1, y1, 2);
           x1 := x1 + 3;
        end;
      end;
    end;
  end;
  k1 := 0;
  k2 := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    c1 := -1;
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      if a[i+1] = 1 then
      begin
        c1 := k1;
        k1 := k1 + 1;
      end;
      tit := 'Y: ';
      c2 := b1;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      if a[i+1] = 2 then
      begin
        c1 := k2;
        k2 := k2 + 1;
      end;
      tit := 'X: ';
      c2 := a1;
    end;
    ResultN(prclong(i,n)+ 'R=', c1, x1, y1, 2);
    x1 := x1 + l + 6;
    if c1 <> -1 then
    begin
    ResultComment(tit, x1, y1);
    x1 := x1 + 3;
    for j := 1 to 3 do
    begin
      ResultN(c2[j], x1, y1, 2);
      x1 := x1 + 3;
    end;
    end;
  end;
end;

procedure MPIInter11;
var
  i, j, k0, k00, k01, k02, k11, k12, k1, k2, x1, x2, y1, y2, l, c1, c3, n0, l0, root1, root2, root0, root0a: integer;
  a: array[1..20] of integer;
  a1,b1, a2, b2, c2: array[1..20] of integer;
  tit: string;
begin
  n := 2*RandomN(4,6);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дано целое число {C},'#13#10
+'лежащее в диапазоне от 0 до 2, причем известно, что в процессе ранга 0 дано'#13#10
+'число {C}~=~1, а первое из значений {C}~=~2 имеется у процесса ранга {K}/2.'#13#10
+'Используя функцию MPI\_Comm\_split, создать коммуникаторы, первый из которых'#13#10
+'содержит процессы со значениями {C}~=~1 в том же порядке, а второй \= процессы'#13#10
+'со значениями {C}~=~2 в том же порядке. Вывести ранги процессов {R} в созданных'#13#10
+'коммуникаторах (если процесс не входит ни в один из созданных коммуникаторов,'#13#10
+'то вывести для него число~\-1). Затем объединить созданные коммуникаторы'#13#10
+'в интеркоммуникатор с помощью функции MPI\_Intercomm\_create (группа, содержащая'#13#10
+'процессы со значениями {C}~=~1, считается первой группой созданного'#13#10
+'интеркоммуникатора, а группа процессов со значениями {C}~=~2 \= второй).'#13#10
+'После этого ввести в процессах обеих групп созданного интеркоммуникатора целое'#13#10
+'число {R}_1, которое совпадает во всех процессах и указывает ранг выделенного'#13#10
+'процесса первой группы. В выделенном процессе первой группы дан набор'#13#10
+'из {K}_2 целых чисел {X}, где {K}_2 \= количество процессов во второй группе. Используя'#13#10
+'один вызов коллективной функции MPI\_Scatter в каждом процессе созданного'#13#10
+'интеркоммуникатора, переслать по одному числу из набора {X} во все процессы'#13#10
+'второй группы (в порядке возрастания рангов процессов),'#13#10
+'после чего вывести полученные числа.'
);
  l := length(prclong(1,n));
  n0 := n div 2;
  for i := 1 to n do
  begin
    a[i] := 0;
    a1[i] := RandomN(10,99);
    b1[i] := RandomN(10,99);
  end;
  a[1] := 1;
  a[n0+1] := 2;
  k01 := 1;
  for i := 2 to n0 do
    if RandomN(0,1) = 0 then
    begin
      a[i] := 1;
      k01 := k01 + 1;
    end;
  repeat
  k02 := 1;
  for i := n0 + 2 to n do
  begin
    a[i] := 0;
    if RandomN(0,1) = 0 then
    begin
      a[i] := 2;
      k02 := k02 + 1;
    end;
  end;
  until k02 < 6;
  k1 := 1;
  k2 := 1;
  for i := 1 to n do
  begin
    if a[i] = 1 then
    begin
      a2[k1] := a1[i];
      k1 := k1 + 1;
    end
    else
    if a[i] = 2 then
    begin
      b2[k2] := b1[i];
      k2 := k2 + 1;
    end
  end;
  root1 := RandomN(1, k01);
  root2 := RandomN(1, k02);

  k11 := 0;
  k12 := 0;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
      tit := 'X: ';
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      c1 := a1[i+1];
      c3 := a[i+1];
      tit := 'X: ';
      k0 := 0;
      if a[i+1] = 1 then k11 := k11 + 1;
      if k11 = root1 then
      begin
        k0 := 1;
        c2 := a1;
//        c3 := -c3;

      end;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      c1 := b1[i+1];
      c3 := a[i+1];
//      tit := 'Y: ';
      k0 := 2;
      if a[i+1] = 2 then k12 := k12 + 1;

//      if k12 = root2 then
//      begin
//        k0 := 1;
//        c2 := b1;
//        c3 := -c3;
//      end;
    end;
    DataN(prclong(i,n)+ 'C=', c3, x1, y1, 1);
    x1 := x1 + l + 4;
    if a[i+1] <> 0 then
    begin
      DataN('R_1=', root1-1, x1, y1, 1);
      if k0 = 1 then
      begin
        x1 := x1 + 5;
        DataComment(tit, x1, y1);
        x1 := x1 + 3;
        for j := 1 to k02 do
        begin
           DataN(a1[j], x1, y1, 2);
           x1 := x1 + 3;
        end;
      end;
    end;
  end;

  k1 := 0;
  k2 := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    c1 := -1;
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      if a[i+1] = 1 then
      begin
        c1 := k1;
        k1 := k1 + 1;
      end;
      tit := 'Y: ';
      c2 := b1;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      if a[i+1] = 2 then
      begin
        c1 := k2;
        k2 := k2 + 1;
      end;
      tit := 'X: ';
      c2 := a1;
    end;
    ResultN(prclong(i,n)+ 'R=', c1, x1, y1, 2);
    x1 := x1 + l + 6;
    if a[i+1] = 2 then
    begin
//        x1 := x1 + 6;
        ResultN('X=', a1[c1+1], x1, y1, 2);
    end;
  end;
end;

procedure MPIInter12;
var
  i, j, k0, k00, k01, k02, k11, k12, k1, k2, x1, x2, y1, y2, l, c1, c3, n0, l0, root1, root2, root0, root0a: integer;
  a: array[1..20] of integer;
  a1,b1, a2, b2, c2: array[1..20] of integer;
  tit: string;
begin
  n := 2*RandomN(4,6);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дано целое число {C},'#13#10
+'лежащее в диапазоне от 0 до 2, причем известно, что в процессе ранга 0 дано'#13#10
+'число {C}~=~1, а первое из значений {C}~=~2 имеется у процесса ранга {K}/2.'#13#10
+'Используя функцию MPI\_Comm\_split, создать коммуникаторы, первый из которых'#13#10
+'содержит процессы со значениями {C}~=~1 в том же порядке, а второй \= процессы'#13#10
+'со значениями {C}~=~2 в том же порядке. Вывести ранги процессов {R} в созданных'#13#10
+'коммуникаторах (если процесс не входит ни в один из созданных коммуникаторов,'#13#10
+'то вывести для него число~\-1). Затем объединить созданные коммуникаторы'#13#10
+'в интеркоммуникатор с помощью функции MPI\_Intercomm\_create (группа, содержащая'#13#10
+'процессы со значениями {C}~=~1, считается первой группой созданного'#13#10
+'интеркоммуникатора, а группа процессов со значениями {C}~=~2 \= второй).'#13#10
+'После этого ввести в процессах обеих групп созданного интеркоммуникатора целое'#13#10
+'число {R}_2, которое совпадает во всех процессах и указывает ранг выделенного'#13#10
+'процесса второй группы. В каждом процессе первой группы дано по одному целому'#13#10
+'числу {X}. Используя один вызов коллективной функции MPI\_Gather в каждом'#13#10
+'процессе созданного интеркоммуникатора, переслать исходные числа {X}'#13#10
+'(в порядке возрастания рангов содержащих их процессов) в выделенный процесс'#13#10
+'второй группы, после чего вывести в этом процессе полученные числа.'
);
  l := length(prclong(1,n));
  n0 := n div 2;
  for i := 1 to n do
  begin
    a[i] := 0;
    a1[i] := RandomN(10,99);
    b1[i] := RandomN(10,99);
  end;
  a[1] := 1;
  a[n0+1] := 2;
  repeat
  k01 := 1;
  for i := 2 to n0 do
  begin
    a[i] := 0;
    if RandomN(0,1) = 0 then
    begin
      a[i] := 1;
      k01 := k01 + 1;
    end;
  end;
  until k01 < 6;
  k02 := 1;
  for i := n0 + 2 to n do
    if RandomN(0,1) = 0 then
    begin
      a[i] := 2;
      k02 := k02 + 1;
    end;
  k1 := 1;
  k2 := 1;
  for i := 1 to n do
  begin
    if a[i] = 1 then
    begin
      a2[k1] := a1[i];
      k1 := k1 + 1;
    end
    else
    if a[i] = 2 then
    begin
      b2[k2] := b1[i];
      k2 := k2 + 1;
    end
  end;
  root1 := RandomN(1, k01);
  root2 := RandomN(1, k02);

  k11 := 0;
  k12 := 0;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
      tit := 'X: ';
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      c1 := a1[i+1];
      c3 := a[i+1];
      tit := 'X: ';
      k0 := 0;
      if a[i+1] = 1 then
      begin
        k11 := k11 + 1;
        k0 := 1;
      end;
{      if k11 = root1 then
      begin
        k0 := 1;
        c2 := a1;
//        c3 := -c3;

      end;}
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      c1 := b1[i+1];
      c3 := a[i+1];
//      tit := 'Y: ';
      k0 := 2;
      if a[i+1] = 2 then k12 := k12 + 1;

//      if k12 = root2 then
//      begin
//        k0 := 1;
//        c2 := b1;
//        c3 := -c3;
//      end;
    end;
    DataN(prclong(i,n)+ 'C=', c3, x1, y1, 1);
    x1 := x1 + l + 4;
    if a[i+1] <> 0 then
    begin
      DataN('R_2=', root2-1, x1, y1, 1);
      if a[i+1] = 1 then
      begin
        x1 := x1 + 5;
        DataN('X=', a1[k11], x1, y1, 2);
      end;
    end;
  end;

  k1 := 0;
  k2 := 0;
  for i := 0 to n - 1 do
  begin
    k0 := 0;
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    c1 := -1;
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      if a[i+1] = 1 then
      begin
        c1 := k1;
        k1 := k1 + 1;
      end;
      tit := 'Y: ';
      c2 := b1;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      if a[i+1] = 2 then
      begin
        c1 := k2;
        k2 := k2 + 1;
      end;
      if c1 = root2-1 then
        k0 := 1;
      tit := 'X: ';
      c2 := a1;
    end;
    ResultN(prclong(i,n)+ 'R=', c1, x1, y1, 2);
    x1 := x1 + l + 6;
    if k0 = 1 then
    begin
//        x1 := x1 + 5;
        ResultComment('X: ', x1, y1);
        x1 := x1 + 3;
        for j := 1 to k01 do
        begin
           ResultN(a1[j], x1, y1, 2);
           x1 := x1 + 3;
        end;
    end;
  end;
end;

procedure MPIInter13;
var
  i, j, k0, k00, k01, k02, k11, k12, k1, k2, x1, x2, y1, y2, l, c1, c3, n0, l0, root1, root2, root0, root0a: integer;
  a: array[1..20] of integer;
  a1,b1,a2, b2, c2: array[1..20] of real;
  c4, min, max: real;
  tit: string;
begin
  n := 2*RandomN(4,6);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дано целое число {C},'#13#10
+'лежащее в диапазоне от 0 до 2, причем известно, что в процессе ранга 0 дано'#13#10
+'число {C}~=~1, а первое из значений {C}~=~2 имеется у процесса ранга {K}/2.'#13#10
+'Используя функцию MPI\_Comm\_split, создать коммуникаторы, первый из которых'#13#10
+'содержит процессы со значениями {C}~=~1 в том же порядке, а второй \= процессы'#13#10
+'со значениями {C}~=~2 в том же порядке. Вывести ранги процессов {R} в созданных'#13#10
+'коммуникаторах (если процесс не входит ни в один из созданных коммуникаторов,'#13#10
+'то вывести для него число~\-1). Затем объединить созданные коммуникаторы'#13#10
+'в интеркоммуникатор с помощью функции MPI\_Intercomm\_create (группа, содержащая'#13#10
+'процессы со значениями {C}~=~1, считается первой группой созданного'#13#10
+'интеркоммуникатора, а группа процессов со значениями {C}~=~2 \= второй).'#13#10
+'В каждом процессе первой группы дано по одному целому числу {X}, в каждом'#13#10
+'процессе второй группы дано по одному целому числу {Y}. Используя один вызов'#13#10
+'коллективной функции MPI\_Allreduce в каждом процессе созданного'#13#10
+'интеркоммуникатора, получить в каждом процессе первой группы число {Y}_{min} \='#13#10
+'минимальное из исходных чисел {Y}, а в каждом процессе второй группы'#13#10
+'число {X}_{max} \= максимальное из исходных чисел {X},'#13#10
+'после чего вывести полученные числа.'
);
  l := length(prclong(1,n));
  n0 := n div 2;
  for i := 1 to n do
  begin
    a[i] := 0;
    a1[i] := RandomR(1.0,9.9);
    b1[i] := RandomR(1.0,9.9);
  end;
  a[1] := 1;
  a[n0+1] := 2;
  k01 := 1;
  for i := 2 to n0 do
    if RandomN(0,1) = 0 then
    begin
      a[i] := 1;
      k01 := k01 + 1;
    end;
  k02 := 1;
  for i := n0 + 2 to n do
    if RandomN(0,1) = 0 then
    begin
      a[i] := 2;
      k02 := k02 + 1;
    end;
  k1 := 1;
  k2 := 1;
  min := 1000;
  max := -1000;
  for i := 1 to n do
  begin
    if a[i] = 1 then
    begin
      a2[k1] := a1[i];
      k1 := k1 + 1;
      if a1[i] > max then
        max := a1[i];
    end
    else
    if a[i] = 2 then
    begin
      b2[k2] := b1[i];
      k2 := k2 + 1;
      if b1[i] < min then
        min := b1[i];
    end
  end;
  root1 := RandomN(1, k01);
  root2 := RandomN(1, k02);

  k11 := 0;
  k12 := 0;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
      tit := 'X: ';
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      c3 := a[i+1];
      tit := 'X = ';
      if a[i+1] = 1 then
      begin
        k11 := k11 + 1;
      end;
      k0 := k11;
      c2 := a2;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      c3 := a[i+1];
      tit := 'Y = ';
      if a[i+1] = 2 then k12 := k12 + 1;
      k0 := k12;
      c2 := b2;
    end;
    DataN(prclong(i,n)+ 'C = ', c3, x1, y1, 1);
    x1 := x1 + l + 8;
    if a[i+1] <> 0 then
    begin
        DataR(tit, c2[k0], x1, y1, 4);
    end;
  end;

  k1 := 0;
  k2 := 0;
  for i := 0 to n - 1 do
  begin
    k0 := 0;
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    c1 := -1;
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      if a[i+1] = 1 then
      begin
        c1 := k1;
        k1 := k1 + 1;
        c4 := min;
      end;
      tit := 'Y_{min} = ';
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      if a[i+1] = 2 then
      begin
        c1 := k2;
        k2 := k2 + 1;
        c4 := max;
      end;
      tit := 'X_{max} = ';
    end;
    ResultN(prclong(i,n)+ 'R = ', c1, x1, y1, 2);
    x1 := x1 + l + 8;
    if a[i+1] <> 0 then
    begin
//        x1 := x1 + 5;
        ResultR(tit, c4, x1, y1, 4);
    end;
  end;
end;

procedure MPIInter14;
var
  i, j, k0, k00, k01, k02, k11, k12, k1, k2, x1, x2, y1, y2, l, c1, c3, n0, l0, root1, root2, root0, root0a: integer;
  a: array[1..20] of integer;
  a1,b1, a2, b2, c2: array[1..20,1..20] of integer;
  tit: string;
begin
  n := 2*RandomN(4,6);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дано целое число {C},'#13#10
+'лежащее в диапазоне от 0 до 2, причем известно, что в процессе ранга 0 дано'#13#10
+'число {C}~=~1, а первое из значений {C}~=~2 имеется у процесса ранга {K}~\-~1.'#13#10
+'Используя функцию MPI\_Comm\_split, создать коммуникаторы, первый из которых'#13#10
+'содержит процессы со значениями {C}~=~1 в том же порядке, а второй \= процессы'#13#10
+'со значениями {C}~=~2 в обратном порядке. Вывести ранги процессов {R} в созданных'#13#10
+'коммуникаторах (если процесс не входит ни в один из созданных коммуникаторов,'#13#10
+'то вывести для него число~\-1). Затем объединить созданные коммуникаторы'#13#10
+'в интеркоммуникатор с помощью функции MPI\_Intercomm\_create (группа, содержащая'#13#10
+'процессы со значениями {C}~=~1, считается первой группой созданного'#13#10
+'интеркоммуникатора, а группа процессов со значениями {C}~=~2 \= второй).'#13#10
+'В каждом процессе первой группы дан массив целых чисел {X} размера {N}_2, где {N}_2 \='#13#10
+'количество процессов во второй группе, в каждом процессе второй группы дан'#13#10
+'массив целых чисел {Y} размера {N}_1, где {N}_1 \= количество процессов в первой'#13#10
+'группе. Используя один вызов коллективной функции MPI\_Alltoall в каждом'#13#10
+'процессе созданного интеркоммуникатора, переслать в процесс ранга {R}_1 первой'#13#10
+'группы ({R}_1~=~0,~\., {N}_1~\-~1) элементы с индексом {R}_1 из всех массивов {Y},'#13#10
+'а в процесс ранга {R}_2 второй группы ({R}_2~=~0,~\., {N}_2~\-~1) элементы'#13#10
+'с индексом {R}_2 из всех массивов {X}. Вывести полученные числа'#13#10
+'в порядке возрастания рангов переславших их процессов.'
);
  l := length(prclong(1,n));
  n0 := n div 2;
  for i := 1 to n do
  begin
    a[i] := 0;
    for j := 1 to n do
    begin
      a1[i,j] := RandomN(10,99);
      b1[i,j] := RandomN(10,99);
    end;
  end;
  a[1] := 1;
  a[n] := 2;
  repeat
  k01 := 1;
  for i := 2 to n0 do
  begin
    a[i] := 0;
    if RandomN(0,1) = 0 then
    begin
      a[i] := 1;
      k01 := k01 + 1;
    end;
  end;
  until k01 < 6;
  repeat
  k02 := 1;
  for i := n0 + 1 to n-1 do
  begin
    a[i] := 0;
    if RandomN(0,1) = 0 then
    begin
      a[i] := 2;
      k02 := k02 + 1;
    end;
  end;
  until k02 < 6;

  k1 := 1;
  k2 := 1;
  for i := 1 to n do
  begin
    if a[i] = 1 then
    begin
      for j := 1 to n do
        a2[k1,j] := a1[i,j];
      k1 := k1 + 1;
    end
    else
    if a[i] = 2 then
    begin
      for j := 1 to n do
        b2[k2,j] := b1[i,j];
      k2 := k2 + 1;
    end
  end;
//  root1 := RandomN(1, k01);
//  root2 := RandomN(1, k02);

  k11 := 0;
  k12 := 0;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
//      tit := 'X: ';
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
//      c1 := a1[i+1];
      c3 := a[i+1];
      tit := 'X: ';
      k0 := k02;
      if a[i+1] = 1 then
      begin
        k11 := k11 + 1;
        k00 := k11;
        c2 := a2;
      end;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
//      c1 := b1[i+1];
      c3 := a[i+1];
      tit := 'Y: ';
      k0 := k01;
      if a[i+1] = 2 then
      begin
        k12 := k12 + 1;
        k00 := k12;
        c2 := b2;
      end;

//      if k12 = root2 then
//      begin
//        k0 := 1;
//        c2 := b1;
//        c3 := -c3;
//      end;
    end;
    DataN(prclong(i,n)+ 'C=', c3, x1, y1, 1);
    x1 := x1 + l + 4;
    if c3 <> 0 then
    begin
        x1 := x1 + 2;
        DataComment(tit, x1, y1);
        x1 := x1 + 3;
        for j := 1 to k0 do
        begin
         DataN(c2[k00,j], x1, y1, 2);
          x1 := x1 + 3;
        end;
    end;
  end;

  for i := 1 to k02 div 2 do
    for j := 1 to k01 do
      SwapN(b2[i,j], b2[k02-i+1, j]);

  k1 := 0;
  k2 := k02 - 1;
  for i := 0 to n - 1 do
  begin
    k0 := 0;
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
    c1 := -1;
    if (i < n div 2) then
    begin
      x1 := 1;
      y1 := i + 1;
      if a[i+1] = 1 then
      begin
        c1 := k1;
        k1 := k1 + 1;
      end;
      k00 := k02;
      tit := 'Y: ';
      c2 := b2;
    end
    else
    begin
      x1 := 40;
      y1 := (i-n div 2) + 1;
      if a[i+1] = 2 then
      begin
        c1 := k2;
        k2 := k2 - 1;
      end;
      k00 := k01;
      tit := 'X: ';
      c2 := a2;
    end;

    ResultN(prclong(i,n)+ 'R=', c1, x1, y1, 2);
    x1 := x1 + l + 6;
    if c1 <> -1 then
    begin
//        x1 := x1 + 5;
        ResultComment(tit, x1, y1);
        x1 := x1 + 3;
        for j := 1 to k00 do
        begin
           ResultN(c2[j,c1+1], x1, y1, 2);
           x1 := x1 + 3;
        end;
    end;
  end;


end;


procedure MPIInter15;
var
  i, j, k0, x1, x2, y1, y2, l: integer;
  a, sum: real;
  s: string;
begin
  n := RandomN(3,6);
  CreateTask(title3, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дано вещественное число. Используя функцию MPI\_Comm\_spawn'#13#10
+'с первым параметром \<ptprj.exe\>, создать один новый процесс. С помощью'#13#10
+'коллективной функции MPI\_Reduce переслать в созданный процесс сумму исходных'#13#10
+'чисел и отобразить ее в разделе отладки, используя в этом процессе функцию'#13#10
+'Show. Затем с помощью коллективной функции MPI\_Bcast переслать найденную сумму'#13#10
+'в исходные процессы и вывести эту сумму в каждом процессе.'
);
  sum := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    a := RandomR(10,20.9);
    sum := sum + a;
    y1 := i+1;
    DataR(prc(i), a, 0, y1, 4);
  end;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    y1 := i + 1;
    ResultR(prc(i), sum, 0, y1, 4);
  end;
    Str(sum:5:2,s);
    DataComment(DebugSec, 1, n+1);
    DataComment('a0|  1>  '+s, 1, n+2);
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);

end;

procedure MPIInter16;
var
  i, j, k0, x1, x2, y1, y2, l: integer;
  c: array[1..10,1..10] of real;
  s, s1, s2: string;
  s0: array[1..10] of string;
begin
  n := RandomN(3,6);
  CreateTask(title3, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дан массив из {K} вещественных чисел, где {K} \= количество'#13#10
+'процессов. Используя один вызов функции MPI\_Comm\_spawn с первым параметром'#13#10
+'\<ptprj.exe\>, создать {K} новых процессов. С помощью коллективной функции'#13#10
+'MPI\_Reduce\_scatter\_block переслать в созданный процесс ранга {R} ({R}~=~0,~\.,'#13#10
+'{K}~\-~1) максимальный из элементов исходных массивов с индексом {R} и отобразить'#13#10
+'полученные максимальные элементы в разделе отладки, используя в каждом новом'#13#10
+'процессе функцию Show. Затем с помощью функций MPI\_Send и MPI\_Recv переслать'#13#10
+'найденный максимальный элемент из нового процесса ранга {R} ({R}~=~0,~\., {K}~\-~1)'#13#10
+'в исходный процесс того же ранга и вывести'#13#10
+'полученные элементы в исходных процессах.'
);
  for i := 1 to n do
    b[i] := 0;
  for i := 1 to n do
  for j := 1 to n do
  begin
    c[i,j] := RandomR(1,9.9);
    if c[i,j] > b[j] then
      b[j] := c[i,j];
  end;
  for i := 0 to n-1 do
  begin
    SetProcess(i);
    x1 := 1;
    y1 := i+1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 10;
    for j := 0 to n - 1 do
    begin
      x1 := x1 + 5;
      DataR(c[i+1,j+1], x1, y1, 4);
    end;
  end;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    y1 := i + 1;
{    if not Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    x1 := 0;
    ResultR(prc(i), b[i+1], x1, y1, 4);
  end;
  for i := 1 to n do
  s0[i] := 'a'+IntToStr(i-1)+'|  1> ';
  for i := 1 to n do
  begin
    Str(b[i]:5:2,s);
    s0[i] := s0[i] + s;
  end;
    DataComment(DebugSec, 1, n +1);
  for i := 1 to n do
    DataComment(s0[i], 1, n+ 1+i);
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);

end;


procedure MPIInter17;
var
  i, j, k0, x1, x2, y1, y2, l: integer;
  s, s1, s2: string;
begin
  n := 2*RandomN(3,5);
  CreateTask(title3, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В процессах ранга 0 и 1 даны массивы'#13#10
+'вещественных чисел размера {K}/2. Используя один вызов функции MPI\_Comm\_spawn'#13#10
+'с первым параметром \<ptprj.exe\>, создать два новых процесса. Используя'#13#10
+'один вызов функции MPI\_Comm\_split для интеркоммуникатора, связанного'#13#10
+'с созданными процессами, создать два новых интеркоммуникатора: первый содержит'#13#10
+'группу исходных процессов четного ранга (0,~\., {K}~\-~2), а также, в качестве'#13#10
+'второй группы, первый из новых процессов (ранга 0), второй содержит группу'#13#10
+'исходных процессов нечетного ранга (1,~\., {K}~\-~1), а также, в качестве второй'#13#10
+'группы, второй из новых процессов (ранга 1). Используя функции MPI\_Send'#13#10
+'в исходных процессах и функции MPI\_Recv в новых процессах, переслать все'#13#10
+'исходные числа из первого процесса первой группы каждого интеркоммуникатора'#13#10
+'в единственный процесс, входящий в его вторую группу. Отобразить полученные'#13#10
+'числа в разделе отладки, используя в новых процессах функцию Show. Затем'#13#10
+'с помощью коллективной функции MPI\_Scatter для интеркоммуникаторов переслать'#13#10
+'по одному числу из новых процессов во все процессы первой группы'#13#10
+'соответствующего интеркоммуникатора (в порядке возрастания рангов процессов)'#13#10
+'и вывести полученные числа.'
);
  for i := 0 to n do
    b[i] := RandomR(1,9.9);
  for i := 0 to 1 do
  begin
    SetProcess(i);
    x1 := 1;
    y1 := i+1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 10;
    for j := 0 to n div 2 - 1 do
    begin
      x1 := x1 + 5;
      DataR(b[i+2*j], x1, y1, 4);
    end;
  end;

  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    y1 := i div 2 + 1;
    if not Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;
    ResultR(prc(i), b[i], x1, y1, 4);
  end;
  s1 := 'a0|  1> ';
  s2 := 'a1|  1> ';
  for i := 0 to n div 2 - 1do
  begin
    Str(b[2*i]:5:2,s);
    s1 := s1 + s;
    Str(b[2*i+1]:5:2,s);
    s2 := s2 + s;
  end;
    DataComment(DebugSec, 1, 2 +1);
    DataComment(s1, 1, 2 +2);
    DataComment(s2, 1, 2 +3);
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);

end;



procedure MPIInter18;
var
  i, j, k0, x1, x2, y1, y2, l, amax, amin: integer;
  c1, c2: array[1..10,1..10] of integer;
  a1, a2: array[1..10] of integer;
  s, s1, s2: string;
  s0: array[1..10] of string;
begin
  n := 2*RandomN(3,5);
  CreateTask(title3, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дан массив'#13#10
+'вещественных чисел размера {K}/2. Используя один вызов функции MPI\_Comm\_spawn'#13#10
+'с первым параметром \<ptprj.exe\>, создать {K} новых процессов. Используя'#13#10
+'один вызов функции MPI\_Comm\_split для интеркоммуникатора, связанного'#13#10
+'с созданными процессами, создать два новых интеркоммуникатора: первый содержит'#13#10
+'группу исходных процессов четного ранга (0,~\., {K}~\-~2), а также, в качестве'#13#10
+'второй группы, созданные процессы четного ранга, второй содержит группу'#13#10
+'исходных процессов нечетного ранга (1,~\., {K}~\-~1), а также, в качестве второй'#13#10
+'группы, созданные процессы нечетного ранга. Для каждого из созданных'#13#10
+'интеркоммуникаторов выполнить следующие действия: среди элементов исходных'#13#10
+'массивов с индексом {R} ({R}~=~0,~\., {K}/2~\-~1), входящих в первую группу каждого'#13#10
+'интеркоммуникатора, найти минимальный (для первого интеркоммуникатора)'#13#10
+'или максимальный (для второго) и переслать этот экстремальный элемент в тот'#13#10
+'из новых процессов, который имеет ранг {R} во второй группе соответствующего'#13#10
+'интеркоммуникатора (например, минимальный из первых элементов массивов,'#13#10
+'которые даны в исходных процессах четного ранга, следует переслать в первый'#13#10
+'из созданных процессов, а максимальный из первых элементов массивов, которые'#13#10
+'даны в исходных процессах нечетного ранга, следует переслать во второй'#13#10
+'из созданных процессов, поскольку этот процесс имеет ранг 0 в соответствующем'#13#10
+'интеркоммуникаторе). Для выполнения этих действий использовать коллективную'#13#10
+'функцию MPI\_Reduce\_scatter\_block. Полученные экстремальные элементы отобразить'#13#10
+'в разделе отладки, используя в каждом новом процессе функцию Show. Затем'#13#10
+'с помощью коллективной функции MPI\_Reduce найти минимальный элемент'#13#10
+'из тех минимумов, которые были получены во второй группе первого'#13#10
+'интеркоммуникатора, переслать и вывести его в первом процессе первой группы'#13#10
+'этого интеркоммуникатора (т.\,е. в процессе ранга 0 в исходном коммуникаторе'#13#10
+'MPI\_COMM\_WORLD), а также найти максимальный элемент из тех максимумов, которые'#13#10
+'были получены во второй группе второго интеркоммуникатора, переслать'#13#10
+'и вывести его в первом процессе первой группы этого интеркоммуникатора'#13#10
+'(т.\,е. в процессе ранга 1 в исходном коммуникаторе MPI\_COMM\_WORLD).'
);
  for i := 1 to n do
  begin
    a1[i] := 1000;
    a2[i] := 0;
  end;
  for i := 1 to n div 2 do
  for j := 1 to n div 2 do
  begin
    c1[i,j] := RandomN(10,99);
    if c1[i,j] < a1[j] then
      a1[j] := c1[i,j];
  end;
  for i := 1 to n div 2 do
  for j := 1 to n div 2 do
  begin
    c2[i,j] := RandomN(10,99);
    if c2[i,j] > a2[j] then
      a2[j] := c2[i,j];
  end;
  amin := 1000;
  amax := 0;
  for i := 1 to n div 2 do
  begin
    if amin > a1[i] then
      amin:= a1[i];
    if amax < a2[i] then
      amax:= a2[i];
  end;
  for i := 0 to n-1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
    y1 := i div 2 +1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 8;
    for j := 1 to n div 2 do
    begin
      x1 := x1 + 3;
      if not Odd(i) then
      DataN(c1[i div 2+1,j], x1, y1, 2)
      else
      DataN(c2[i div 2+1,j], x1, y1, 2);
    end;
  end;
(*
  x1 := 1;
  for j := 1 to n div 2 do
  begin
  x1 := x1 + 6;
  ResultN(a1[j],x1, 20, 2);
  end;
  x1 := 1;
  for j := 1 to n div 2 do
  begin
  x1 := x1 + 6;
  ResultN(a2[j],x1, 21, 2);
  end;
*)
    SetProcess(0);
    ResultN(prc(0), amin, 1, 1, 2);
    SetProcess(1);
    ResultN(prc(1), amax, 41, 1, 2);
    DataComment(DebugSec, 1, (n-1) div 2 + 2);
    j := 0;
    for i := 1 to n div 2 do
    begin
    DataComment('a'+IntToStr(j)+'|  1>  '+IntToStr(a1[i]), 1, (n-1) div 2 + 3+j);
    inc(j);
    DataComment('a'+IntToStr(j)+'|  1>  '+IntToStr(a2[i]), 1, (n-1) div 2 + 3+j);
    inc(j);
    end;

(*
  for i := 1 to n do
  s0[i] := 'a'+IntToStr(i-1)+'|  1> ';
  for i := 1 to n do
  begin
    Str(b[i]:5:2,s);
    s0[i] := s0[i] + s;
  end;
  for i := 1 to n do
    ResultComment(s0[i], 1, n+ 1+i);
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);
*)
end;

procedure MPIInter19;
var
  i, j, k0, x1, x2, y1, y2, sum: integer;
  s,s1: string;
begin
  n := RandomN(3,5);
  CreateTask(title3, n);
  if n = 0 then exit;
TaskText(
 'В главном процессе дан массив {A} из 2{K} целых чисел, где {K} \= количество'#13#10
+'процессов. Используя один вызов функции MPI\_Comm\_spawn с первым параметром'#13#10
+'\<ptprj.exe\>, создать {K} новых процессов. Используя функцию'#13#10
+'MPI\_Intercomm\_merge для интеркоммуникатора, связанного с созданными'#13#10
+'процессами, создать новый интракоммуникатор, содержащий как исходные,'#13#10
+'так и новые процессы (параметр high функции MPI\_Intercomm\_merge необходимо'#13#10
+'задать таким образом, чтобы в созданном интракоммуникаторе вначале'#13#10
+'располагались исходные, а затем созданные процессы). Используя коллективную'#13#10
+'функцию MPI\_Scatter для нового интракоммуникатора, переслать по одному'#13#10
+'элементу массива {A} из главного процесса во все процессы приложения'#13#10
+'(как исходные, так и созданные) в порядке возрастания их рангов в новом'#13#10
+'интракоммуникаторе. В исходных процессах вывести полученные числа, в новых'#13#10
+'процессах отобразить полученные числа в разделе отладки, используя в этих'#13#10
+'процессах функцию Show. Затем, используя коллективную функцию MPI\_Reduce'#13#10
+'в этом же интракоммуникаторе, переслать в исходный процесс ранга 1'#13#10
+'сумму всех чисел и вывести ее в этом процессе.'
);
  SetProcess(0);
  DataComment(prc(0),1,1);
  x1 := 9;
  sum := 0;
  for i := 1 to 2*n do
  begin
    a[i] := RandomN(10,99);
    sum := sum + a[i];
    x1 := x1 + 3;
    DataN(a[i], x1, 1, 2);
  end;
  for i := 0 to n-1 do
  begin
    SetProcess(i);
    ResultN(prc(i), a[i+1],1, i+1,2);
    if i = 1 then
    begin
      ResultN(sum, 15, 2, 3);
    end;
  end;
(*
  x1 := 1;
  for j := 1 to n div 2 do
  begin
  x1 := x1 + 6;
  ResultN(a1[j],x1, 20, 2);
  end;
  x1 := 1;
  for j := 1 to n div 2 do
  begin
  x1 := x1 + 6;
  ResultN(a2[j],x1, 21, 2);
  end;
*)
    DataComment(DebugSec, 1, 2);
    j := 0;
    for i := n+1 to 2*n do
    begin
    DataComment('a'+IntToStr(j)+'|  1>  '+IntToStr(a[i]), 1, 3+j);
    inc(j);
    end;


(*
  for i := 1 to n do
  s0[i] := 'a'+IntToStr(i-1)+'|  1> ';
  for i := 1 to n do
  begin
    Str(b[i]:5:2,s);
    s0[i] := s0[i] + s;
  end;
  for i := 1 to n do
    ResultComment(s0[i], 1, n+ 1+i);
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);
*)
end;


procedure MPIInter20;
var
  i, j, k0, x1, x2, y1, y2, sum: integer;
  a: array[1..10, 1..4] of integer;
  s,s1: string;
begin
  repeat
  n := RandomN(5,15);
  until n mod 4 <> 0;
  CreateTask(title3, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} не делится на 4. В каждом процессе дано целое число {A}.'#13#10
+'Используя один вызов функции MPI\_Comm\_spawn с первым параметром \<ptprj.exe\>,'#13#10
+'создать такое количество новых процессов (1, 2 или 3), чтобы общее число'#13#10
+'процессов {K}_0 в приложении стало кратным 4. В каждом из созданных процессов'#13#10
+'задать значение числа {A}, равное \-{R}~\-~1, где {R} \= ранг созданного процесса.'#13#10
+'Используя функцию MPI\_Intercomm\_merge для интеркоммуникатора, связанного'#13#10
+'с созданными процессами, создать новый интракоммуникатор, содержащий'#13#10
+'как исходные, так и новые процессы (параметр high функции MPI\_Intercomm\_merge'#13#10
+'необходимо задать таким образом, чтобы в созданном интракоммуникаторе вначале'#13#10
+'располагались исходные, а затем новые процессы). Используя функцию'#13#10
+'MPI\_Cart\_create для созданного интракоммуникатора, определить для всех'#13#10
+'процессов декартову топологию в виде двумерной решетки размера ({K}_0/4)~\x~4,'#13#10
+'являющейся периодической по второму измерению (порядок нумерации процессов'#13#10
+'оставить прежним). Используя функцию MPI\_Cart\_coords, определить координаты'#13#10
+'{X}, {Y} каждого процесса в данной решетке; в исходных процессах вывести'#13#10
+'эти координаты, в новых процессах отобразить координаты в разделе отладки'#13#10
+'с помощью функций Show, снабдив их комментариями \<X~=~\> и \<Y~=~\>. Выполнить'#13#10
+'циклический сдвиг значений {A} в каждом столбце созданной решетки с шагом \-1'#13#10
+'(т.\,е. в направлении убывания рангов процессов), используя для этого функции'#13#10
+'MPI\_Cart\_shift и MPI\_Sendrecv\_replace. В исходных процессах вывести'#13#10
+'полученные значения {A}, в новых процессах отобразить их в разделе отладки'#13#10
+'с помощью функции Show, снабдив комментарием \<A~=~\>.'
);
  for i := 1 to n div 4 + 1 do
    for j := 1 to 4 do
      a[i,j] := RandomN(10,99);
  k := 0;
  for j := n mod 4+1 to 4 do
  begin
    k := k - 1;
    a[n div 4 + 1, j] := k;
  end;
  k := -1;
  for i := 1 to n div 4 + 1 do
  begin

    for j := 1 to 4 do
    begin
    k := k + 1;
    if k >= n then break;
    SetProcess(k);
    x1 := 1 + (j-1) * 20;
    DataN(prclong(k,20) + 'A = ', a[i,j], x1, i,2);
    ResultComment(prclong(k,20), x1, 2*i-1);
    ResultN('X = ', i-1, x1, 2*i,1);
    x1 := x1 + 6;
    ResultN('Y = ', j-1, x1, 2*i,1);
    x1 := x1 + 6;
    ResultN('A = ', a[(i) mod (n div 4 + 1) + 1,j], x1, 2*i,2);
    end;

  end;
//  ResultN(n,1,1,1);
(*
  x1 := 1;
  for j := 1 to n div 2 do
  begin
  x1 := x1 + 6;
  ResultN(a1[j],x1, 20, 2);
  end;
  x1 := 1;
  for j := 1 to n div 2 do
  begin
  x1 := x1 + 6;
  ResultN(a2[j],x1, 21, 2);
  end;
*)
    DataComment(DebugSec, 1, n div 4 + 2);
    j := 0;
    for i := n mod 4+1 to 4 do
    begin
      DataComment('a'+IntToStr(j)+'|  1>  X = '+IntToStr(n div 4) +
        ' Y = ' + IntToStr(i-1) + ' A = ' + IntToStr(a[1, i]), 1, n div 4 + 3 + j);
    inc(j);
    end;


(*
  for i := 1 to n do
  s0[i] := 'a'+IntToStr(i-1)+'|  1> ';
  for i := 1 to n do
  begin
    Str(b[i]:5:2,s);
    s0[i] := s0[i] + s;
  end;
  for i := 1 to n do
    ResultComment(s0[i], 1, n+ 1+i);
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);
*)
end;



procedure MPIInter21;
var
  i, j, k0, x1, x2, y1, y2: integer;
  s,s1: string;
  s0: array[1..2,1..10] of string;
begin
  n := RandomN(3,5);
  CreateTask(title3, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дано вещественное число: в главном процессе это число'#13#10
+'обозначается буквой {A}, в подчиненных процессах \= буквой {B}. Используя два'#13#10
+'вызова функции MPI\_Comm\_spawn с первым параметром \<ptprj.exe\>, создать'#13#10
+'две группы новых процессов: первая группа (группа-\Iсервер\i) должна содержать'#13#10
+'один процесс, вторая группа (группа-\Iклиент\i) должна содержать {K}~\-~1 процесс,'#13#10
+'где {K} \= количество исходных процессов. Переслать в процесс группы-сервера'#13#10
+'число {A} из главного процесса, а в процессы группы-клиента \= числа {B}'#13#10
+'из подчиненных процессов (в порядке возрастания рангов процессов) и отобразить'#13#10
+'полученные числа в разделе отладки, используя в каждом новом процессе функцию'#13#10
+'Show. С помощью функций MPI\_Open\_port, MPI\_Publish\_name и MPI\_Comm\_accept'#13#10
+'на стороне сервера и функций MPI\_Lookup\_name и MPI\_Comm\_connect на стороне'#13#10
+'клиента установить связь между двумя новыми группами процессов, создав для них'#13#10
+'новый интеркоммуникатор. Используя функции MPI\_Send и MPI\_Recv для этого'#13#10
+'интеркоммуникатора, получить в каждом процессе группы-клиента число {A}'#13#10
+'из процесса группы-сервера и найти сумму этого числа и числа {B}, полученного'#13#10
+'ранее из исходных подчиненных процессов. Отобразить найденную сумму {A}~+~{B}'#13#10
+'в разделе отладки, используя в каждом процессе группы-клиента функцию Show,'#13#10
+'а также переслать эту сумму в соответствующий исходный подчиненный процесс'#13#10
+'и вывести полученную сумму в этом процессе (сумма, найденная в процессе'#13#10
+'ранга {R} группы-клиента, должна быть переслана в исходный процесс ранга {R}~+~1).'#13#10
+'\P\SПримечание.\s В программе необходимо обеспечить такую последовательность'#13#10
+'действий, чтобы вызов функции MPI\_Lookup\_name в процессах клиента'#13#10
+'гарантированно выполнялся \Iпосле\i вызова функции MPI\_Publish\_name в процессе'#13#10
+'сервера. Можно, например, использовать функцию MPI\_Barrier для исходных'#13#10
+'процессов и процесса сервера, вызвав ее в процессе сервера только после'#13#10
+'завершения вызова функции MPI\_Publish\_name, и вызвать функцию MPI\_Comm\_spawn'#13#10
+'для создания группы-клиента уже после выхода из функции MPI\_Barrier'#13#10
+'в исходных процессах.'
);
  for i := 1 to n do
  begin
    b[i] := RandomR(1,4.9);
  end;
  for i := 0 to n-1 do
  begin
    SetProcess(i);
    s := 'A = ';
    if i > 0 then
      s := 'B = ';
    DataR(prc(i)+ '     ' + s, b[i+1],0, i+1,4);
  end;
  s := 'A + B = ';
  for i := 1 to n-1 do
  begin
    SetProcess(i);
    ResultR(prc(i)+ ' '+ s, b[1]+b[i+1],0, i,4);
  end;
(*
  x1 := 1;
  for j := 1 to n div 2 do
  begin
  x1 := x1 + 6;
  ResultN(a1[j],x1, 20, 2);
  end;
  x1 := 1;
  for j := 1 to n div 2 do
  begin
  x1 := x1 + 6;
  ResultN(a2[j],x1, 21, 2);
  end;
*)

    DataComment(DebugSec1, 1, n+1);
    Str(b[1]:0:2, s);
    s0[1,1] := 'a0|  1>  '+s;
    s0[2,n] := 'b0|  1>  '+s;
//    ResultComment('a0|  1>  '+s, 1, n+1);
    for i := 1 to n-1 do
    begin
    Str(b[i+1]:0:2, s);
    Str(b[1]+b[i+1]:0:2, s1);
    s0[1, i+1] := 'b'+IntToStr(i-1)+'|  1>  '+s + ' ' + s1;
    s0[2, i] := 'a'+IntToStr(i-1)+'|  1>  '+s + ' ' + s1;
    end;
    for i := 1 to n do
    begin
    DataComment(s0[1,i], 1, n+ 1 + i);

    DataComment(s0[2,i], 41, n+ 1 + i);
    end;

(*
  for i := 1 to n do
  s0[i] := 'a'+IntToStr(i-1)+'|  1> ';
  for i := 1 to n do
  begin
    Str(b[i]:5:2,s);
    s0[i] := s0[i] + s;
  end;
  for i := 1 to n do
    ResultComment(s0[i], 1, n+ 1+i);
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);
*)
end;

procedure MPIInter22;
var
  i, j, k0, k1, x1, x2, y1, y2: integer;
  s,s1: string;
  b0: boolean;
  s0: array[1..4,1..10] of string;
  a: array[0..20,1..20] of integer;
  b,k2: array[0..10] of integer;
  c: array[1..20] of integer;
begin
  n := RandomN(6,10);
  CreateTask(title3, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дано целое число {N}, которое может принимать три значения:'#13#10
+'0, 1 и {K} ({K}~>~1). Известно, что имеется ровно один процесс со значением {N}~=~1'#13#10
+'и ровно {K} процессов со значением {N}~=~{K}. В тех процессах, в которых число {N}'#13#10
+'не равно 0, также дано целое число {A}. Используя функцию MPI\_Comm\_split,'#13#10
+'разбить исходный коммуникатор MPI\_COMM\_WORLD на два, в каждый из которых'#13#10
+'входят процессы с одинаковым ненулевым значением {N}. Используя один вызов'#13#10
+'функции MPI\_Comm\_spawn для каждого из созданных коммуникаторов, создать два'#13#10
+'набора новых процессов; число новых процессов должно совпадать с количеством'#13#10
+'процессов в соответствующем коммуникаторе (таким образом, в одной новой группе'#13#10
+'будет содержаться 1 процесс, в другой \= {K} процессов). Переслать в каждый из'#13#10
+'новых процессов число {A} из того исходного процесса, ранг которого в созданном'#13#10
+'коммуникаторе совпадает с рангом нового процесса. Отобразить полученные числа'#13#10
+'в разделе отладки, используя в каждом новом процессе функцию Show. Считая'#13#10
+'новую группу, состоящую из одного процесса, \Iгруппой-сервером\i, а новую группу'#13#10
+'из {K} процессов \= \Iгруппой-клиентом\i, установить между ними связь с помощью'#13#10
+'функций MPI\_Open\_port, MPI\_Publish\_name и MPI\_Comm\_accept на стороне сервера'#13#10
+'и MPI\_Lookup\_name и MPI\_Comm\_connect на стороне клиента. Используя'#13#10
+'коллективную функцию MPI\_Gather для интеркоммуникатора, связывающего'#13#10
+'группу-клиент и группу-сервер, переслать все числа {A} из процессов'#13#10
+'группы-клиента в процесс группы-сервера и отобразить полученные числа'#13#10
+'в разделе отладки, используя несколько вызовов функции Show в процессе'#13#10
+'группы-сервера. Кроме того, переслать эти числа с помощью функций MPI\_Send'#13#10
+'и MPI\_Recv из процесса группы-сервера в тот исходный процесс, который создал'#13#10
+'группу-сервер, и вывести полученные числа в этом исходном процессе.'#13#10
+'\P\SПримечание.\s В программе необходимо обеспечить такую последовательность'#13#10
+'действий, чтобы вызов функции MPI\_Lookup\_name в процессах клиента'#13#10
+'гарантированно выполнялся \Iпосле\i вызова функции MPI\_Publish\_name в процессе'#13#10
+'сервера. Можно, например, поступить следующим образом. Для пересылки числа {A}'#13#10
+'в процесс группы-сервера применить функцию MPI\_Ssend, вызвав после нее функцию'#13#10
+'MPI\_Barrier для исходного коммуникатора MPI\_COMM\_WORLD и организовав прием'#13#10
+'этого числа в процессе группы-сервера только после выполнения функции'#13#10
+'MPI\_Publish\_name. В остальных процессах исходного коммуникатора MPI\_COMM\_WORLD'#13#10
+'следует вначале вызвать функцию MPI\_Barrier, а затем организовать пересылку'#13#10
+'чисел {A} в созданные процессы группы-клиента. Таким образом, любой'#13#10
+'из процессов группы-клиента получит число {A} только тогда, когда процесс'#13#10
+'группы-сервера уже выполнит вызов функции MPI\_Publish\_name.'
);
  b[1] := 1;
  b[2] := RandomN(2, n-2);
  for i := 1 to n do
    c[i] := 0;
  c[1] := 1;
  for i := 2 to b[2]+1 do
    c[i] := b[2];
  for i := 1 to 30 do
    SwapN(c[RandomN(1,n)], c[RandomN(1,n)]);
  for i := 1 to 2 do
    for j := 1 to b[i] do
      a[b[i],j] := RandomN(10,99);
  k2[0] := 0;
  k2[1] := 0;
  k2[b[2]] := 0;
  for i := 0 to n-1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
    y1 := i div 2 +1;
    DataN(prc(i)+' N = ', c[i+1], x1, y1, 1);
    x1 := x1 + 20;
    Inc(k2[c[i+1]]);
    if c[i+1] <> 0 then
      DataN(' A = ', a[c[i+1], k2[c[i+1]]], x1, y1, 2);
    if c[i+1] = 1 then
      k0 := i;
  end;
  y1 := 1;
  SetProcess(k0);
  ResultComment(prc(k0), 1, y1);
    x1 := 14;
    for j := 1 to b[2] do
    begin
      ResultN(a[b[2], j], x1, y1, 2);
      x1 := x1 + 4;
    end;
    y1 := y1 + 1;

    DataComment(DebugSec1, 1, (n-1) div 2 +2);
    s0[1,1] := 'a0|  1>  '+IntToStr(a[1,1]);
    s0[1,2] := 'a0|  2>  ';
    for j := 1 to b[2] do
      s0[1,2] := s0[1,2] + IntToStr(a[b[2], j])+ ' ';

    for j := 3 to b[2]+2 do
        s0[1, j] := 'b' + IntToStr(j-3) + '|  1>  '+IntTOStr(a[b[2], j-2]);

    for j := 1 to b[2] do
        s0[2, j] := 'a' + IntToStr(j-1) + '|  1>  '+IntTOStr(a[b[2], j]);


    s0[2,b[2]+1] := 'b0|  1>  '+IntToStr(a[1,1]);
    s0[2,b[2]+2] := 'b0|  2>  ';
    for j := 1 to b[2] do
      s0[2,b[2]+2] := s0[2,b[2]+2] + IntToStr(a[b[2], j])+ ' ';

    y2 := (n-1) div 2 +2;
    x1 := 1;
    for i := 1 to 2 do
    begin
      y1 := y2;
      for j := 1 to b[2]+2 do
      begin
        y1 := y1 + 1;
        DataComment(s0[i,j], x1, y1);
      end;
      x1 := x1 + 40;
    end;


(*
  for i := 1 to n do
  s0[i] := 'a'+IntToStr(i-1)+'|  1> ';
  for i := 1 to n do
  begin
    Str(b[i]:5:2,s);
    s0[i] := s0[i] + s;
  end;
  for i := 1 to n do
    ResultComment(s0[i], 1, n+ 1+i);
//  DataComment(prc(0)+'------', xLeft, 10);
//  DataComment(prc(1)+'------', xRight, 10);
*)
end;



procedure InitTask(num: integer); stdcall;
begin
  case num of
  1: MPIInter1;
  2: MPIInter2;
  3: MPIInter3;
  4: MPIInter4;
  5: MPIInter5;
  6: MPIInter6;
  7: MPIInter7;
  8: MPIInter8;
  9: MPIInter9;
  10: MPIInter10;
  11: MPIInter11;
  12: MPIInter12;
  13: MPIInter13;
  14: MPIInter14;
  15: MPIInter15;
  16: MPIInter16;
  17: MPIInter17;
  18: MPIInter18;
  19: MPIInter19;
  20: MPIInter20;
  21: MPIInter21;
  22: MPIInter22;
  end;
end;


procedure inittaskgroup;
begin
  if CurrentLanguage and lgCPP = 0 then exit;
  CreateGroup('MPI8Inter', 'Интеркоммуникаторы и динамическое создание процессов',
    'М. Э. Абрамян, 2017', 'sddwertfghklbfdgfgd', 22, InitTask);
end;

// exports inittaskgroup;  //----------------------------------------------------------

begin
end.
