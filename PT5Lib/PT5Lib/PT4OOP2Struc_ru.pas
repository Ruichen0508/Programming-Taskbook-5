{$A+,B-,D-,E+,F-,G-,I+,L-,N+,O-,P-,Q-,R-,S-,T-,V+,X+,Y-}

//---------------------------------
unit PT4OOP2Struc_ru;

{$MODE Delphi}

interface


procedure InitTask(num: integer); stdcall;
procedure inittaskgroup;


implementation


uses PT5TaskMaker, SysUtils;

//-----------------------------------

const
  TestHeader = '\P\SТестирование разработанной системы классов\s.'#13;
  Subgroup1 = 'Adapter, Composite, Decorator';
  Subgroup2 = 'Proxy, Bridge, Flyweight';



procedure Pat1(k: integer);
var n, i: integer;
    a, b, res: array[1..10] of integer;
    c: array[1..10] of char;
    isA, isB: boolean;
begin
  CreateTask(Subgroup1);
if k = 1 then
TaskText(
'\G<Graph\OOPAdapterO.png>\BAdapter\b (\BАдаптер\b)~\= структурный паттерн.'#13+
'\PИзвестен также под именем \BWrapper\b (\BОбертка\b).'#13+
'\P\SЧастота использования\s: выше средней.'#13+
'\P\SНазначение\s: преобразует интерфейс одного класса в интерфейс другого, который'#13+
'ожидают клиенты. Адаптер обеспечивает совместную работу классов'#13+
'с несовместимыми интерфейсами, которая без него была бы невозможна.'#13+
'\P\SУчастники\s: \P\X~\ITarget\i (\IЦелевой класс\i)~\= определяет зависящий от предметной'#13+
'области интерфейс, которым пользуется Client; \P\X~\IClient\i (\IКлиент\i)~\= вступает'#13+
'во взаимоотношения с объектами, удовлетворяющими интерфейсу Target;'#13+
'\P\X~\IAdaptee\i (\IАдаптируемый класс\i)~\= определяет существующий интерфейс,'#13+
'который нуждается в адаптации; \P\X~\IAdapter\i (\IАдаптер\i)~\= адаптирует интерфейс'#13+
'Adaptee к интерфейсу Target.'#13+
'\PВ данном задании рассматривается вариант адаптера, использующий композицию.'#13+
'Такой вариант называется \Iадаптером объекта\i, поскольку адаптируется \Iобъект\i'#13+
'типа Adaptee, входящий в виде ссылочного поля в класс Adapter.'#13+
'\P\SЗадание 1\s. Абстрактный класс \MTarget\m содержит три абстрактных метода:'#13+
'\MGetA\m, \MGetB\m и \MRequest\m (не имеют параметров, возвращают значение целого типа).'#13+
'Класс \MConcreteTarget\m является потомком класса \MTarget\m; он содержит поля~\Ma\m и~\Mb\m'#13+
'целого типа, которые инициализируются в конструкторе, имеющем одноименные'#13+
'параметры. Методы \MGetA\m и \MGetB\m класса \MConcreteTarget\m возвращают значения'#13+
'полей~\Ma\m и~\Mb\m соответственно, а метод \MRequest\m возвращает сумму этих полей.'#13+
'\PКласс \MAdaptee\m содержит два целочисленных поля~\Ma\m и~\Mb\m, конструктор'#13+
'с параметрами~\Ma\m и~\Mb\m, задающий значения этих полей, метод \MGetAll\m,'#13+
'возвращающий текущие значения полей (либо с помощью выходных параметров,'#13+
'либо с помощью возвращаемого значения~\= массива или кортежа), и метод'#13+
'\MSpecificRequest\m без параметров, возвращающий произведение полей~\Ma\m и~\Mb\m.'#13+
'\PРеализовать класс \MAdapter\m, адаптирующий класс \MAdaptee\m к интерфейсу класса'#13+
'\MTarget\m. Класс должен быть адаптером объекта: он порождается от класса \MTarget\m'#13+
'и включает ссылку \Mad\m на экземпляр адаптируемого объекта \MAdaptee\m.'#13+
'Ссылка \Mad\m инициализируется в конструкторе класса \MAdapter\m путем вызова'#13+
'конструктора класса \MAdaptee\m с параметрами~\Ma\m и~\Mb\m, совпадающими с одноименными'#13+
'параметрами конструктора класса \MAdapter\m. Метод \MRequest\m класса \MAdapter\m'#13+
'должен вызывать метод \MSpecificRequest\m объекта \Mad\m, а методы \MGetA\m и \MGetB\m~\='#13+
'возвращать значения полей~\Ma\m и~\Mb\m объекта \Mad\m, используя его метод \MGetAll\m.'#13+
TestHeader+
'Дано целое число {N} (\l\,6) и набор из {N} троек ({C}, {A}, {B}), где {C} является'#13+
'символом \<+\> или \<*\>, а элементы {A} и {B} являются целыми числами. Создать'#13+
'структуру данных (например, массив) с элементами-ссылками типа \MTarget\m'#13+
'и заполнить ее объектами типа \MConcreteTarget\m (для троек с символом \<+\>)'#13+
'и \MAdapter\m (для троек с символом \<*\>) с полями, равными~{A} и~{B}. Перебирая'#13+
'элементы полученного набора \Iв обратном порядке\i, вывести для каждого из них'#13+
'значения полей~\Ma\m, \Mb\m и результат выполнения метода \MRequest\m.'
)
else
TaskText(
'\G<Graph\OOPAdapterC.png>\BAdapter\b (\BАдаптер\b)~\= структурный паттерн.'#13+
'\PВ данном задании рассматривается вариант адаптера, использующий множественное'#13+
'наследование. Такой вариант называется \Iадаптером класса\i, поскольку класс'#13+
'Adapter порождается от \Iкласса\i Adaptee, наследуя его реализацию (а также'#13+
'от класса Target, наследуя его интерфейс). Если язык не поддерживает'#13+
'множественное наследование, то адаптер класса можно реализовать с помощью'#13+
'\Iинтерфейсов\i; для этого надо преобразовать абстрактный класс Target'#13+
'в интерфейс ITarget, сделать класс Adapter потомком класса Adaptee'#13+
'и добавить к нему интерфейс ITarget.'#13+
'\P\SЗадание 2\s. Выполнить предыдущее задание (см.~\1), реализовав \MAdapter\m'#13+
'как адаптер класса. Для языков, не поддерживающих множественное наследование,'#13+
'определить интерфейс \MITarget\m с методами \MGetA\m, \MGetB\m и \MRequest\m и добавить'#13+
'интерфейс \MITarget\m к классам \MConcreteTarget\m и \MAdapter\m (абстрактный класс \MTarget\m'#13+
'теперь не требуется; для хранения исходных данных надо использовать'#13+
'коллекцию с элементами интерфейсного типа \MITarget\m).'
);


n := Random(4) + 3;
DataN('N = ', n, 0, 1, 1);
repeat
isA := false;
isB := false;
for i := 1 to n do
begin
  a[i] := Random(26) + 5;
  b[i] := Random(26) + 5;
  if Random(2) = 0 then
  begin
    c[i] := '+';
    res[i] := a[i] + b[i];
    isA := true;
  end
  else
  begin
    c[i] := '*';
    res[i] := a[i] * b[i];
    isB := true;
  end;
end;
until isA and isB;
for i := 1 to n do
begin
  DataC('', c[i], Center(i, n, 9, 4), 2);
  DataN('', a[i], Center(i, n, 9, 4) + 4, 2, 2);
  DataN('', b[i], Center(i, n, 9, 4) + 7, 2, 2);
end;
for i := n downto 1 do
begin
  ResultN('', a[i], Center(n-i+1, n, 9, 4), 1, 2);
  ResultN('', b[i], Center(n-i+1, n, 9, 4) + 3, 1, 2);
  ResultN('', res[i], Center(n-i+1, n, 9, 4) + 6, 1, 3);
end;
end;


procedure Pat3(k: integer);
var n, i, y, a, b: integer;
    x1, y1, x2, y2: array[1..10] of integer;
    c: array[1..10] of char;
    isA, isB: boolean;

function Str(i: integer): string;
begin
  result := c[i] + '(' + IntToStr(x1[i]) + ',' + IntToStr(y1[i]) + ')(' +
    IntToStr(x2[i]) + ',' + IntToStr(y2[i]) + ')';
end;
begin
  CreateTask(Subgroup1);
if k = 1 then
TaskText(
'\BAdapter\b (\BАдаптер\b)~\= структурный паттерн.'#13+
'\P\SЗадание 3\s. Дан абстрактный класс \MShape\m, предоставляющий интерфейс'#13+
'для графических объектов: метод \MGetInfo\m без параметров, возвращающий строку'#13+
'с именем объекта и координатами левой верхней и правой нижней вершины'#13+
'ограничивающего прямоугольника (считается, что ось {OY} направлена вниз),'#13+
'и метод \MMoveBy(a,~b)\m с двумя целочисленными параметрами, определяющими вектор,'#13+
'на который надо сместить данный графический объект (метод не возвращает'#13+
'значений). В классе \MShape\m методы \MGetInfo\m и \MMoveBy\m являются абстрактными.'#13+
'\PТакже дан конкретный класс \MRectShape\m~\= потомок класса \MShape\m, реализующий'#13+
'прямоугольник и имеющий конструктор с параметрами \M(x1, y1, x2, y2)\m, которые'#13+
'задают координаты левой верхней и правой нижней вершины этого прямоугольника.'#13+
'Метод \MGetInfo\m для данного класса возвращает строку вида \<R(x1,y1)(x2,y2)\>'#13+
'с текущими значениями координат (например, \<R(1,\-4)(3,2)\>).'#13+
'\PДан класс \MTextView\m для работы с текстовыми объектами. Он содержит поля \Mx\m, \My\m'#13+
'(координаты точки привязки~\= левого верхнего угла текстовой области),'#13+
'\Mwidth\m, \Mheight\m (ширина и высота текстовой области) и методы \MGetOrigin\m'#13+
'(возвращает координаты точки привязки), \MSetOrigin\m (изменяет точку привязки),'#13+
'\MGetSize\m (возвращает размеры текстовой области) и \MSetSize\m (изменяет размеры'#13+
'текстовой области). Методы \MGetOrigin\m и \MGetSize\m возвращают результаты либо'#13+
'с помощью выходных параметров, либо с помощью возвращаемого значения~\='#13+
'массива или кортежа. Конструктор класса не имеет параметров (поля~\Mx\m и~\My\m'#13+
'полагаются равными~0, поля \Mwidth\m и \Mheight\m~\= равными~1).'#13+
'\PРеализовать класс \MTextShape\m, адаптирующий класс \MTextView\m к интерфейсу'#13+
'класса \MShape\m. Класс должен быть адаптером объекта: он порождается от класса'#13+
'\MShape\m и включает поле \Mtview\m, являющееся ссылкой на экземпляр адаптируемого'#13+
'объекта \MTextView\m (других полей класс \MTextShape\m не содержит). Метод \MGetInfo\m'#13+
'класса \MTextShape\m должен возвращать строку вида \<T(x1,y1)(x2,y2)\> с текущими'#13+
'значениями левой верхней и правой нижней вершины ограничивающего'#13+
'прямоугольника. Включить в класс \MTextShape\m конструктор с параметрами'#13+
'\M(x1, y1, x2, y2)\m, задающими координаты левой верхней и правой нижней вершины'#13+
'ограничивающего прямоугольника для текстовой области (эти параметры должны'#13+
'использоваться в конструкторе при инициализации поля \Mtview\m).'#13+
TestHeader+
'Дано целое число {N} (\l\,8) и набор из {N} пятерок ({C}, {X}_1, {Y}_1, {X}_2, {Y}_2), где {C}'#13+
'является символом \<R\> или \<T\>, а остальные элементы являются целыми числами.'#13+
'Кроме того, даны целые числа~{A} и~{B}. Создать структуру данных (например,'#13+
'массив) с элементами типа \MShape\m и заполнить ее объектами типа \MRectShape\m'#13+
'(для пятерок с символом \<R\>) и \MTextShape\m (для пятерок с символом \<T\>),'#13+
'используя значения {X}_1, {Y}_1, {X}_2, {Y}_2 в качестве параметров соответствующего'#13+
'конструктора. Применить к каждому элементу созданного набора метод \MMoveBy\m'#13+
'с параметрами {A} и {B} и вывести строковые представления элементов набора'#13+
'с помощью метода \MGetInfo\m (перебирая элементы в исходном порядке).'
)
else
TaskText(
'\BAdapter\b (\BАдаптер\b)~\= структурный паттерн.'#13+
'\P\SЗадание 4\s. Выполнить предыдущее задание (см.~\1), реализовав'#13+
'\MTextShape\m как адаптер класса. Для языков, не поддерживающих множественное'#13+
'наследование, преобразовать абстрактный класс \MShape\m в интерфейс \MIShape\m'#13+
'и добавить его к классам \MRectShape\m и \MTextShape\m (для хранения'#13+
'исходных данных в этом случае надо использовать коллекцию'#13+
'с элементами интерфейсного типа \MIShape\m).'
);

n := Random(5) + 4;
DataN('N = ', n, 0, 1, 1);
repeat
isA := false;
isB := false;
for i := 1 to n do
begin
  x1[i] := Random(21) + 30;
  y1[i] := Random(21) + 30;
  x2[i] := x1[i] + 1 + Random(20);
  y2[i] := y1[i] + 1 + Random(20);
  if Random(2) = 0 then
  begin
    c[i] := 'R';
    isA := true;
  end
  else
  begin
    c[i] := 'T';
    isB := true;
  end;
end;
until isA and isB;
for i := 1 to 4 do
begin
  DataC('', c[i], Center(i, 4, 15, 4)-1, 2);
  DataN('', x1[i], Center(i, 4, 15, 4) + 3, 2, 2);
  DataN('', y1[i], Center(i, 4, 15, 4) + 6, 2, 2);
  DataN('', x2[i], Center(i, 4, 15, 4) + 9, 2, 2);
  DataN('', y2[i], Center(i, 4, 15, 4) + 12, 2, 2);
end;
y := 3;
if n > 4 then
begin
y := 4;
for i := 5 to n do
begin
  DataC('', c[i], Center(i-4, 4, 15, 4)-1, 3);
  DataN('', x1[i], Center(i-4, 4, 15, 4) + 3, 3, 2);
  DataN('', y1[i], Center(i-4, 4, 15, 4) + 6, 3, 2);
  DataN('', x2[i], Center(i-4, 4, 15, 4) + 9, 3, 2);
  DataN('', y2[i], Center(i-4, 4, 15, 4) + 12, 3, 2);
end;
end;
a := Random(41) - 20;
b := Random(41) - 20;
DataN('A = ', a, xLeft, y, 2);
DataN('B = ', b, xRight, y, 2);
for i := 1 to n do
begin
  x1[i] := x1[i] + a;
  x2[i] := x2[i] + a;
  y1[i] := y1[i] + b;
  y2[i] := y2[i] + b;
end;
for i := 1 to 4 do
  ResultS('', str(i), Center(i, 4, 17, 2), 1);
for i := 5 to n do
  ResultS('', str(i), Center(i-4, 4, 17, 2), 2);
end;

procedure Pat5;
var m, i, j: integer;
    s: string;
    x: array[0..5] of integer;
    isA, isB: boolean;

function Str(s: string; sz, j: integer): string;
var c: char;
    m, i: integer;
begin
  result := '';
  if (j = 1) or (j = 3) then
    c := '-'
  else
    c := '=';
  if j = 3 then
    s := LowerCase(s)
  else
    s := UpperCase(s);
  for i := 1 to sz do
    result := result + c;
  m := length(s);
  if m > sz - 1 then
    m := sz - 1;
  if (j = 3) or (j = 4) then
    for i := 1 to m do
      result[i+1] := s[i];
end;

begin
  CreateTask(Subgroup2);
TaskText(
'\G<Graph\OOPBridge.png>\BBridge\b (\BМост\b)~\= структурный паттерн.'#13+
'\PИзвестен также под именем \BHandle/Body\b (\BОписатель/Тело\b).'#13+
'\P\SЧастота использования\s: средняя.'#13+
'\P\SНазначение\s: отделяет абстракцию от ее реализации так, чтобы то и другое'#13+
'можно было изменять независимо.'#13+
'\P\SУчастники\s: \P\X~\IAbstraction\i (\IАбстракция\i)~\= определяет интерфейс абстракции;'#13+
'хранит ссылку на объект типа Implementor; \P\X~\IRefinedAbstraction\i (\IУточненная\i'#13+
'\Iабстракция\i)~\= расширяет интерфейс, определенный абстракцией Abstraction;'#13+
'\P\X~\IImplementor\i (\IРеализатор\i)~\= определяет интерфейс для классов реализации;'#13+
'не обязан точно соответствовать интерфейсу класса Abstraction (обычно'#13+
'предоставляет только примитивные операции, в то время как класс Abstraction'#13+
'определяет операции более высокого уровня, базирующиеся на этих примитивах);'#13+
'\P\X~\IConcreteImplementorA\i и \IConcreteImplementorB\i (\IКонкретные реализаторы\i)~\='#13+
'содержат конкретную реализацию интерфейса класса Implementor.'#13+
'\P\SЗадание 1\s. Реализовать иерархию классов-\Iреализаторов\i, содержащую'#13+
'абстрактного реализатора \MImplementor\m и два конкретных реализатора'#13+
'\MConcreteImplementorA\m и \MConcreteImplementorB\m. Классы отвечают за представление'#13+
'горизонтальных линий и текста и включают методы \MDrawLine(size)\m'#13+
'и \MDrawText(text)\m (аналоги метода OperationImp на диаграмме классов), которые'#13+
'возвращают строковые значения. Параметр \Msize\m определяет размер линии'#13+
'(в символах), параметр \Mtext\m~\= выводимый текст. В классе \MImplementor\m методы'#13+
'\MDrawLine\m и \MDrawText\m являются абстрактными. Конкретный реализатор~A'#13+
'представляет линию в виде набора символов \<\-\>, а текст отображает'#13+
'в нижнем регистре. Конкретный реализатор~B представляет линию в виде набора'#13+
'символов \<=\>, а текст отображает в верхнем регистре. Оба конкретных'#13+
'реализатора имеют конструкторы без параметров,'#13+
'не выполняющие дополнительных действий.'#13+
'\PРеализовать класс \MAbstraction\m, предназначенный для отображения и корректировки'#13+
'строки заголовка. Конструктор класса принимает параметры \Mimp\m типа \MImplementor\m'#13+
'(ссылку на используемый реализатор) и \Msize\m целого типа (размер заголовка).'#13+
'Класс также содержит метод \MShow\m без параметров (аналог метода Operation'#13+
'на диаграмме классов), возвращающий строку-заголовок, и метод \MSetSize(n)\m,'#13+
'задающий размер заголовка равным значению~\Mn\m (целое неотрицательное число).'#13+
'Класс \MAbstraction\m реализует простейший вариант заголовка,'#13+
'представляющий собой линию указанного размера.'#13+
'\PРеализовать класс \MRefinedAbstraction\m, который является усовершенствованным'#13+
'вариантом класса \MAbstraction\m и позволяет включать в заголовок текст.'#13+
'Конструктор класса \MRefinedAbstraction\m содержит, кроме параметров \Mimp\m и \Msize\m,'#13+
'имеющих тот же смысл, что и для конструктора класса \MAbstraction\m, строковый'#13+
'параметр \Mcaption\m. Заголовок формируется следующим образом: вначале указывается'#13+
'линия размера~1, затем строка \Mcaption\m, затем линия такого размера, чтобы'#13+
'суммарный размер заголовка был равен \Msize\m. Для малых значений \Msize\m строка'#13+
'\Mcaption\m может урезаться справа. Переопределить нужным образом'#13+
'метод \MShow\m в классе \MRefinedAbstraction\m.'#13+
TestHeader+
'Дано целое положительное число {size} (начальный размер заголовка) и строка'#13+
'{caption} (необязательный элемент заголовка). Также даны пять целых'#13+
'положительных чисел (новые размеры заголовков). Создать экземпляры классов'#13+
'\MAbstraction\m и \MRefinedAbstraction\m с указанными параметрами и каждым'#13+
'из конкретных реализаторов~A и~B и вывести соответствующие заголовки'#13+
'методом \MShow\m. Затем, используя каждый из новых размеров, изменить размер'#13+
'каждого заголовка и вывести измененные заголовки. Порядок вывода заголовков'#13+
'для каждого размера: \MAbstraction\m с реализатором~A, \MAbstraction\m'#13+
'с реализатором~B, \MRefinedAbstraction\m с реализатором~A, \MRefinedAbstraction\m'#13+
'с реализатором~B. Для хранения созданных объектов использовать массив'#13+
'из четырех ссылочных элементов типа \MAbstraction\m.'
);

repeat
s := LowerCase(EnWordSample(Random(EnWordCount)));
s[1] := Uppercase(s)[1];
m := Length(s);
isA := false;
isB := false;
for i := 0 to 5 do
begin
x[i] := Random(12) + 5;
if x[i] < m + 1 then
  isA := true;
if x[i] > m + 1 then
  isB := true;
end;
until isA and isB;
DataN('size = ', x[0], xLeft, 1, 1);
DataS('caption: ', s, xRight, 1);
for i := 1 to 5 do
  DataN('', x[i], Center(i, 5, 2, 3), 2, 2);

for i := 0 to 5 do
  for j := 1 to 4 do
    ResultS('', Str(s, x[i], j), Center(j, 4, 16, 3), i+1);
end;

procedure Pat6;
var n, i: integer;
    s: string;
    c: char;
    k, k1, k2: integer;
function Str(s: string; i: integer): string;
var k, j: integer;
begin
  result := s[i];
  k := 0;
  if s[i] in ['a'..'z'] then exit;
  for j := i + 1 to length(s) do
  begin
    result := result + s[j];
    if s[j] = '(' then
      k := k + 1;
    if s[j] = ')' then
    begin
      k := k - 1;
      if k = 0 then exit;
    end;
  end;
end;
function Str2(s: string; j: integer): integer;
var i,k: integer;
    c: char;
begin
  k := 0;
  c := ' ';
  for i := j-1 downto 1 do
  begin
    if s[i] = ')' then
      k := k + 1;
    if s[i] = '(' then
    begin
      k := k - 1;
      if k = -1 then
      begin
        c := s[i-1];
        break;
      end;
    end;
  end;
  result := -1;
  if c = ' ' then exit;
  k := -1;
  for i := 1 to length(s) do
    if not (s[i] in ['(', ')']) then
    begin
      k := k + 1;
      if s[i] = c then
        break;
    end;
  result := k;
end;


function Empty(s: string): integer;
var j: integer;
begin
  result := 0;
  for j := 1 to length(s)-1 do
    if Copy(s, j, 2) = '()' then
      result := result + 1;
end;
begin
  CreateTask(Subgroup1);
TaskText(
'\G<Graph\OOPComposite.png>\BComposite\b (\BКомпоновщик\b)~\= структурный паттерн.'#13+
'\P\SЧастота использования\s: выше средней.'#13+
'\P\SНазначение\s: компонует объекты в древовидные структуры для представления'#13+
'иерархий \<часть-целое\>. Позволяет клиентам единообразно трактовать'#13+
'индивидуальные и составные объекты.'#13+
'\P\SУчастники\s: \P\X~\IComponent\i (\IКомпонент\i)~\= объявляет интерфейс для компонуемых'#13+
'объектов; предоставляет подходящую реализацию операций по умолчанию, общую'#13+
'для всех классов; объявляет интерфейс для доступа к дочерним компонентам'#13+
'и управления ими; \P\X~\ILeaf\i (\IЛист\i)~\= представляет листовой узел композиции,'#13+
'не имеющий потомков; \P\X~\IComposite\i (\IСоставной объект\i)~\= хранит дочерние'#13+
'компоненты составного узла; реализует относящиеся к управлению потомками'#13+
'операции в интерфейсе класса Component; \P\X~\IClient\i (\IКлиент\i)~\= манипулирует'#13+
'объектами композиции через интерфейс Component.'#13+
'\PОбъекты-листы и составные объекты могут также содержать дополнительные методы,'#13+
'определяющие их особое поведение, однако паттерн Composite ориентирован прежде'#13+
'всего на применение тех методов, которые являются общими у всех объектов'#13+
'композиции (хотя и реализуются по-разному для листов и составных объектов).'#13+
'\P\SЗадание 1\s. Реализовать иерархию классов, включающую абстрактный'#13+
'класс \MComponent\m с методами \MAddComponent\m и \MOperation\m и конкретные классы \MLeaf\m'#13+
'и \MComposite\m. Метод \MAddComponent\m с параметром-ссылкой~\Mc\m типа \MComponent\m'#13+
'добавляет компонент~\Mc\m в набор дочерних компонентов (имеет смысл только'#13+
'для класса \MComposite\m; для класса \MLeaf\m не выполняет никаких действий),'#13+
'метод \MOperation\m возвращает строковое представление данного компонента и всех'#13+
'его потомков (при наличии). В классе \MComponent\m метод \MAddComponent\m не выполняет'#13+
'никаких действий, а метод \MOperation\m является абстрактным.'#13+
'\PКлассы \MComposite\m и \MLeaf\m содержат символьное поле \Mdata\m; метод \MOperation\m класса'#13+
'\MLeaf\m возвращает это поле (преобразованное к строковому типу), метод \MOperation\m'#13+
'класса \MComposite\m возвращает строку, начинающуюся с символа \Mdata\m, после'#13+
'которого стоит открывающая круглая скобка \<(\>, затем указываются данные,'#13+
'полученные методом \MOperation\m для каждого дочернего компонента (без пробелов),'#13+
'а затем указывается закрывающая круглая скобка \<)\>. Класс \MComposite\m хранит'#13+
'свои дочерние компоненты в структуре данных \Mchildren\m (например, массиве)'#13+
'с элементами-ссылками типа \MComponent\m (можно считать, что любой объект типа'#13+
'\MComposite\m содержит не более 15 дочерних компонентов). Конструктор классов'#13+
'\MLeaf\m и \MComposite\m содержит один символьный параметр,'#13+
'которым инициализируется поле \Mdata\m.'#13+
TestHeader+
'Дано целое число {N} (\l\,15) и набор из {N} символов, являющихся прописными или'#13+
'строчными латинскими буквами. Создать набор данных comp (например, массив)'#13+
'из {N} ссылок на объекты \MComponent\m и заполнить этот набор, создавая для каждой'#13+
'прописной буквы из исходного набора символов объект типа \MComposite\m, а для'#13+
'каждой строчной буквы~\= объект типа \MLeaf\m, и указывая эту букву в качестве'#13+
'параметра конструктора объекта.'#13+
'\PКроме того, дан набор из {N} целых чисел, определяющих связи между объектами'#13+
'набора \Mcomp\m: число с индексом {K} ({K}~=~0,~\., {N}\,\-\,1) определяет индекс'#13+
'родительского объекта для объекта с индексом~{K} (при этом гарантируется,'#13+
'что родительский объект обязательно имеет тип \MComposite\m). Если объект не имеет'#13+
'родителя, то соответствующий элемент в исходном наборе чисел равен~\-1.'#13+
'Если несколько объектов имеют общего родителя, то они должны добвляться к нему'#13+
'в порядке их следования в наборе \Mcomp\m. Используя данные из исходного набора'#13+
'чисел и вызывая метод \MAddComponent\m для требуемых объектов типа \MComposite\m,'#13+
'установить связи между объектами набора \Mcomp\m. Затем, перебирая объекты'#13+
'из набора \Mcomp\m с порядке возрастания их индексов, вызвать для каждого'#13+
'из них метод \MOperation\m и вывести возвращаемое этим методом'#13+
'строковое описание объекта.'



{'Дана строка, содержащая не более 15 прописных и строчных латинских букв'#13+
'и набор согласованных круглых скобок, причем скобка \<(\> располагается после'#13+
'каждой прописной буквы (а в других позициях строки располагаться не может).'#13+
'Эта строка определяет набор данных для объектов типа Component; круглые скобки'#13+
'задают композицию этих объектов. Например, строка \<aB(C(de)f)G()h\> задает'#13+
'листья a, d, e, f, h и составные объекты B, C, G; при этом объект B'#13+
'содержит дочерние объекты C и f, объект C содержит дочерние объекты d и e,'#13+
'а объект G не содержит дочерних объектов (хотя и является составным).'#13+
'Создать все компоненты, определяемые данной строкой, и вывести для каждого'#13+
'из них описание, используя метод Show и перебирая компоненты'#13+
'в порядке их появления в исходной строке.'}
);
n := Random(4) + 12;
repeat
repeat
s := '';
k := 0;
for i := 1 to n do
begin
  c := chr(i + 64);
  if Random(2) = 0 then
  begin
    Inc(c, 32);
    k := k + 1;
  end;
  s := s + c;
end;
until (k >=3) and (n-k >= 7);
for i := 1 to n do
begin
  k1 := Random(n) + 1;
  k2 := Random(n) + 1;
  c := s[k1];
  s[k1] := s[k2];
  s[k2] := c;
end;
for i := n downto 1 do
  if s[i] in ['A'..'Z'] then
    Insert('(', s, i+1);
for i := length(s) downto 1 do
  if s[i] = '(' then
  begin
    repeat
      k := i + Random(length(s) - i);
    until not (s[k] in ['A'..'Z']);
    Insert(')', s, k + 1);
  end;
k := Empty(s);
until (k >= 1) and (k <= 2);





DataN('N = ', n, 0, 1, 1);
k := 0;
for i := 1 to length(s) do
  if not (s[i] in ['(',')']) then
  begin
    k := k + 1;
    DataC('', s[i], Center(k, n, 3, 2), 2);
  end;
k := 0;
for i := 1 to length(s) do
  if not (s[i] in ['(',')']) then
  begin
    k := k + 1;
    DataN('', Str2(s, i), Center(k, n, 3, 2)-1, 3, 3);
  end;
//DataS('', s, 0, 4);
k := 0;
for i := 1 to length(s) do
  if (s[i] <> '(') and (s[i] <> ')') then
  begin
    k := k + 1;
    ResultS('', Str(s, i), 0, k);
  end;
end;

procedure Pat7;
var n, i: integer;
    s: string;
    c: char;
    k, k1, k2: integer;
    name: array['A'..'z'] of string;
    price: array['A'..'z'] of integer;
    totalPrice: array['A'..'z'] of integer;
    name1: array[1..15] of string;
    price1: array[1..15] of integer;
    totalPrice1: array[1..15] of integer;
function TotPr(s: string; i: integer): integer;
var k, j: integer;
begin
  result := price[s[i]];
  k := 0;
  if s[i] in ['a'..'z'] then exit;
  for j := i + 1 to length(s) do
  begin
    if s[j] in ['A'..'z'] then
    result := result + price[s[j]];
    if s[j] = '(' then
      k := k + 1;
    if s[j] = ')' then
    begin
      k := k - 1;
      if k = 0 then exit;
    end;
  end;
end;
function Empty(s: string): integer;
var j: integer;
begin
  result := 0;
  for j := 1 to length(s)-1 do
    if Copy(s, j, 2) = '()' then
      result := result + 1;
end;
function ind(c: char): integer;
begin
  if c in ['a'..'z'] then
    Dec(c, 32);
  result := Ord(c) -Ord('A') + 1;
end;
function FindAnc(s: string; c: char): integer;
var m, i, k, cnt: integer;
begin
  result := -1;
  m := length(s);
  for i := 1 to m do
    if s[i] = c then
    begin
      k := i;
      break;
    end;
  cnt := 0;
  for i := k-1 downto 2 do
  begin
    if s[i] = ')' then
      cnt := cnt + 1;
    if s[i] = '(' then
      cnt := cnt - 1;
    if cnt = -1 then
    begin
      result := ind(s[i-1])-1;
      exit;
    end;
  end;
end;
begin
  CreateTask(Subgroup1);
TaskText(
'\BComposite\b (\BКомпоновщик\b)~\= структурный паттерн.'#13+
'\P\SЗадание 2\s. Реализовать иерархию классов, включающую абстрактный класс'#13+
'\MDevice\m (устройство) с методами \MAdd\m, \MGetName\m и \MGetTotalPrice\m и конкретные'#13+
'классы \MSimpleDevice\m (простое устройство) и \MCompoundDevice\m (составное'#13+
'устройство). Метод \MAdd\m с параметром-ссылкой~\Md\m типа \MDevice\m добавляет'#13+
'устройство~\Md\m в набор дочерних устройств (имеет смысл только для класса'#13+
'\MCompoundDevice\m; для класса \MSimpleDevice\m не выполняет никаких действий),'#13+
'метод \MGetName\m возвращает строковое имя данного устройства, метод \MGetTotalPrice\m'#13+
'возвращает стоимость данного устройства и всех его потомков (целое число).'#13+
'В классе \MDevice\m метод \MAdd\m не выполняет никаких действий,'#13+
'а методы \MGetName\m и \MGetTotalPrice\m являются абстрактными.'#13+
'\PКлассы \MSimpleDevice\m и \MCompoundDevice\m содержат строковое поле \Mname\m'#13+
'и целочисленное поле \Mprice\m; класс \MCompoundDevice\m хранит свои дочерние'#13+
'устройства в виде массива или другой структуры данных с элементами-ссылками'#13+
'типа \MDevice\m (можно считать, что любой объект типа \MCompoundDevice\m содержит'#13+
'не более 15 дочерних устройств). Конструктор классов \MSimpleDevice\m'#13+
'и \MCompoundDevice\m содержит параметры \Mname\m и \Mprice\m, которые используются'#13+
'для инициализации одноименных полей.'#13+
TestHeader+
'Дано целое число {N} (\l\,15) и {N} пар вида ({name}, {price}), где {name}~\= некоторая'#13+
'строка, а {price}~\= положительное целое число. Первый символ строки {name}'#13+
'является латинской буквой; если буква заглавная, то строка определяет'#13+
'составное устройство, а если строчная~\= простое устройство. Кроме того,'#13+
'дан набор из {N} целых чисел, определяющих связи между исходными устройствами:'#13+
'число с индексом {K} ({K}~=~0,~\., {N}\,\-\,1) определяет индекс родительского'#13+
'устройства для исходного устройства с индексом~{K} (при этом гарантируется,'#13+
'что родительское устройство обязательно имеет тип \MCompoundDevice\m). Если'#13+
'устройство не имеет родителя, то соответствующий элемент в исходном наборе'#13+
'чисел равен~\-1. Перебирая созданные устройства в порядке, соответствующем'#13+
'порядку их характеристик ({name}, {price}) и используя методы \MGetName\m'#13+
'и \MGetTotalPrice\m, вывести для каждого устройства название и полную стоимость.'
);
n := Random(4) + 12;
repeat
repeat
s := '';
k := 0;
for i := 1 to n do
begin
  c := chr(i + 64);
  if Random(2) = 0 then
  begin
    Inc(c, 32);
    k := k + 1;
  end;
  s := s + c;
end;
until (k >=3) and (n-k >= 7);
for i := 1 to n do
begin
  k1 := Random(n) + 1;
  k2 := Random(n) + 1;
  c := s[k1];
  s[k1] := s[k2];
  s[k2] := c;
end;
for i := n downto 1 do
  if s[i] in ['A'..'Z'] then
    Insert('(', s, i+1);
for i := length(s) downto 1 do
  if s[i] = '(' then
  begin
    repeat
      k := i + Random(length(s) - i);
    until not (s[k] in ['A'..'Z']);
    Insert(')', s, k + 1);
  end;
k := Empty(s);
until (k >= 1) and (k <= 2);

for i := 1 to length(s) do
if s[i] in ['A'..'z'] then
begin
  name[s[i]] := s[i] + chr(Random(26) + 97) + chr(Random(26) + 97) + chr(Random(10) + 48);
  price[s[i]] := Random(31) + 30;
  name1[ind(s[i])] := name[s[i]];
  price1[ind(s[i])] := price[s[i]];
end;

for i := 1 to length(s) do
  if (s[i] <> '(') and (s[i] <> ')') then
  begin
    totalPrice[s[i]] := TotPr(s, i);
    totalPrice1[ind(s[i])] := totalPrice[s[i]];
  end;





DataN('N = ', n, 0, 1, 2);

for i := 1 to 5 do
begin
  DataS('', name1[i], Center(i, 5, 10, 4), 2);
  DataN('', price1[i], Center(i, 5, 10, 4) + 7, 2, 3);
end;
for i := 1 to 5 do
begin
  DataS('', name1[i+5], Center(i, 5, 10, 4), 3);
  DataN('', price1[i+5], Center(i, 5, 10, 4) + 7, 3, 3);
end;
k := 4;
for i := 1 to n - 10 do
begin
  k := 5;
  DataS('', name1[i+10], Center(i, 5, 10, 4), 4);
  DataN('', price1[i+10], Center(i, 5, 10, 4) + 7, 4, 3);
end;


for i := 1 to n do
begin
  c := name1[i][1];
  DataN('', FindAnc(s, c), Center(i, n, 2, 3), k, 2);
end;



for i := 1 to 5 do
begin
  ResultS('', name1[i], Center(i, 5, 10, 4), 1);
  ResultN('', totalPrice1[i], Center(i, 5, 10, 4) + 6, 1, 4);
end;
for i := 1 to 5 do
begin
  ResultS('', name1[i+5], Center(i, 5, 10, 4), 2);
  ResultN('', totalPrice1[i+5], Center(i, 5, 10, 4) + 6, 2, 4);
end;
for i := 1 to n - 10 do
begin
  ResultS('', name1[i+10], Center(i, 5, 10, 4), 3);
  ResultN('', totalPrice1[i+10], Center(i, 5, 10, 4) + 6, 3, 4);
end;


//ResultS('', S, 0, 4);



end;



procedure Pat8;
var n,i,j, max, empty, len1: integer;
    s: array [1..10] of string;
    p: array [1..10] of string;
    b: boolean;
    c: char;

function v(s, p: string; c: char): string;
var i: integer;
begin
  result := s;
  for i := 1 to length(p) do
  if p[i] = 'A' then
    result := c + result + c
  else
    result := '(' + result + ')';
end;
begin

  CreateTask(Subgroup1);
TaskText(
'\G<Graph\OOPDecorator.png>\BDecorator\b (\BДекоратор\b)~\= структурный паттерн.'#13+
'\PИзвестен также под именем \BWrapper\b (\BОбертка\b).'#13+
'\P\SЧастота использования\s: средняя.'#13+
'\P\SНазначение\s: динамически добавляет объекту новые возможности, приводящие'#13+
'к изменению его состояния и/или поведения. Является гибкой альтернативой'#13+
'порождению подклассов с целью расширения функциональности.'#13+
'\P\SУчастники\s: \P\X~\IComponent\i (\IКомпонент\i)~\= определяет интерфейс для объектов,'#13+
'к которым могут быть динамически добавлены новые возможности;'#13+
'\P\X~\IConcreteComponent\i (\IКонкретный компонент\i)~\= определяет объект, к которому'#13+
'могут быть добавлены новые возможности; \P\X~\IDecorator\i (\IДекоратор\i)~\='#13+
'хранит ссылку на объект Component и определяет интерфейс, соответствующий'#13+
'интерфейсу Component; \P\X~\IConcreteDecoratorA\i и \IConcreteDecoratorB\i'#13+
'(\IКонкретные декораторы\i)~\= добавляют к компоненту новые возможности,'#13+
'изменяющие его состояние и/или поведение.'#13+
'\P\SЗадание 1\s. Реализовать иерархию классов, которая включает абстрактный класс'#13+
'\MComponent\m с абстрактным методом \MOperation\m (не имеет параметров, возвращает'#13+
'строку), абстрактный класс \MDecorator\m, который является потомком класса'#13+
'\MComponent\m и содержит защищенное поле \Mcomp\m~\= ссылку на объект типа \MComponent\m,'#13+
'и конкретные классы \MConcreteComponent\m (потомок класса \MComponent\m),'#13+
'\MConcreteDecoratorA\m и \MConcreteDecoratorB\m (потомки класса \MDecorator\m).'#13+
'\PКласс \MConcreteComponent\m содержит строковое поле \Mtext\m, которое'#13+
'инициализируется в конструкторе с помощью одноименного параметра.'#13+
'Метод \MOperation\m класса \MConcreteComponent\m возвращает строку \Mtext\m.'#13+
'\PКлассы \MConcreteDecoratorA\m и \MConcreteDecoratorB\m имеют поле \Mcomp\m, являющееся'#13+
'ссылкой на объект типа \MComponent\m; класс \MConcreteDecoratorA\m содержит также'#13+
'символьное поле \Mch\m. В конструкторах классов \MConcreteDecoratorA\m'#13+
'и \MConcreteDecoratorB\m поля инициализируются с помощью одноименных параметров.'#13+
'\PМетод \MOperation\m конкретного декоратора~A возвращает строку, полученную'#13+
'путем добавления символа \Mch\m перед и после текста, возвращенного методом'#13+
'\MOperation\m объекта \Mcomp\m. Метод \MOperation\m конкретного декоратора~B возвращает'#13+
'строку, полученную путем добавления символа \<(\> перед текстом, возвращенным'#13+
'методом \MOperation\m объекта \Mcomp\m, и символа \<)\> после этого текста. Таким'#13+
'образом, каждый декоратор изменяет поведение метода \MOperation\m исходного'#13+
'объекта Component, добавляя к возвращаемому значению дополнительный префикс'#13+
'и суффикс; при этом декоратор A корректирует состояние исходного объекта,'#13+
'путем добавления к нему поля \Mch\m.'#13+
TestHeader+
'Дан символ {C}, целое число {N} (\l\,9) и {N} пар строк ({S},~{D}), причем строка~{S}'#13+
'является непустой, а строка~{D} содержит только буквы \<A\> и \<B\> и может быть'#13+
'пустой. Создать набор из {N} объектов типа \MComponent\m, формируя каждый элемент'#13+
'этого набора на основе соответствующей пары строк ({S},~{D}) следующим образом:'#13+
'вначале создать объект типа \MConcreteComponent\m, вызвав его конструктор'#13+
'с параметром~{S}, а затем последовательно применять к результирующему объекту'#13+
'декораторы~A или~В, причем количество и порядок декораторов определяется'#13+
'строкой~{D} (например, в случае строки \<AAB\> к исходному объекту типа'#13+
'\MConcreteComponent\m надо последовательно применить декораторы~A, A и~B).'#13+
'В качестве второго параметра конструктора всех декораторов~A использовать'#13+
'исходный символ~{C}.'#13+
'\PПеребирая созданный набор из {N} объектов \Iв обратном порядке\i, вызвать'#13+
'для каждого из них метод \MOperation\m и вывести его возвращаемое значение.'
);

n := Random(4) + 6;
repeat
max := 0;
empty := 0;
len1 := 0;
for i := 1 to n do
begin
repeat
  s[i] := LowerCase(EnWordSample(Random(EnWordCount)));
  b := true;
  for j := 1 to i - 1 do
    if s[i] = s[j] then
      b := false;
until b;
p[i] := '';
for j := 1 to Random(7) do
  if Random(2) = 0 then
    p[i] := p[i] + 'A'
  else
    p[i] := p[i] + 'B';
if p[i] = '' then
  empty := empty + 1;
if length(p[i]) = 1 then
  len1 := len1 + 1;
if length(s[i]+p[i]) > max then
  max := length(s[i]+p[i]);
end;
until (empty = 1) and
      (len1 = 1) and
      (max <= 11);
c := '=';
case Random(6) of
0: c := '=';
1: c := '*';
2: c := '+';
3: c := '*';
4: c := '^';
5: c := '-';
end;

DataC('C = ', c, xLeft, 1);
DataN('N = ', n, xRight, 1, 1);
for i := 1 to 3 do
begin
  DataS('S: ', s[i], Center(i, 3, max + 11, 3), 2);
  DataS('D: ', p[i], Center(i, 3, max + 11, 3) + length(s[i]) + 6, 2);
end;
for i := 1 to 3 do
begin
  DataS('S: ', s[i+3], Center(i, 3, max + 11, 3), 3);
  DataS('D: ', p[i+3], Center(i, 3, max + 11, 3) + length(s[i+3]) + 6, 3);
end;
for i := 1 to n-6 do
begin
  DataS('S: ', s[i+6], Center(i, 3, max + 11, 3), 4);
  DataS('D: ', p[i+6], Center(i, 3, max + 11, 3) + length(s[i+6]) + 6, 4);
end;

for i := n downto 1 do
  ResultS('', v(s[i], p[i], c), 0, n-i+1);



end;



procedure Pat9;
var n,i,j, max, len0, len35, len1, len5, cube, sq: integer;
    p: array [1..9] of string;
    len: array [1..9] of integer;
    x1, x2: integer;
    v1, v2: array[1..9] of integer;
    zero: boolean;

function v(p: string; x: integer): integer;
var i: integer;
begin
  result := x;
  for i := 1 to length(p) do
  begin
  case p[i] of
  'D':  result := 2 * result;
  'T':  result := 3 * result;
  'S':  result := result * result;
  'C':  result := result * result * result;
  end;
  if result > 1000 then
    result := 0;
  end;
end;

function form(p: string): string;
var i: integer;
begin
  result := 'X';
  for i := 1 to length(p) do
  case p[i] of
  'D':  result := '2*(' + result + ')';
  'T':  result := '3*(' + result + ')';
  'S':  result := '(' + result + ')^2';
  'C':  result := '(' + result + ')^3';
  end;
end;

begin
  CreateTask(Subgroup1);
TaskText(
'\BDecorator\b (\BДекоратор\b)~\= структурный паттерн.'#13+
'\P\SЗадание 2\s. Реализовать иерархию классов, включающую абстрактный класс'#13+
'\MFunction\m с абстрактными методами \MGetName\m (без параметров; возвращает строку)'#13+
'и \MGetValue(x)\m (с целочисленным параметром; возвращает целое число)'#13+
'и пять конкретных классов~\= потомков \MFunction\m:'#13+
'\MFX\m, \MFDouble\m, \MFTriple\m, \MFSquare\m, \MFCube\m.'#13+
'\PКласс \MFX\m не имеет полей; его метод \MGetName\m возвращает строку \<X\>,'#13+
'а функция \MGetValue(x)\m возвращает свой параметр \Mx\m. Остальные конкретные классы'#13+
'являются декораторами; все они содержат ссылочное поле~\Mf\m типа \MFunction\m'#13+
'и конструктор с параметром-ссылкой~\Mf\m типа \MFunction\m, который инициализирует'#13+
'это поле. Метод \MGetName\m данных классов вызывает метод \MGetName\m класса~\Mf\m'#13+
'и возвращает его результат, снабженный дополнительным префиксом и суффиксом:'#13+
'\<2*(\> и \<)\> для \MFDouble\m, \<3*(\> и \<)\> для \MFTriple\m, \<(\> и \<)\^2\> для \MFSquare\m,'#13+
'\<(\> и \<)\^3\> для \MFCube\m. Метод \MGetValue(x)\m данных классов вызывает метод'#13+
'\MGetValue(x)\m класса~\Mf\m и возвращает его результат, преобразованный следующим'#13+
'образом: результат умножается на~2 для \MFDouble\m, умножается на~3 для \MFTriple\m,'#13+
'возводится в квадрат для \MFSquare\m, возводится в куб для \MFCube\m.'#13+
TestHeader+
'Дано целое число {N} (\l\,10) и набор из {N} строк; каждая строка содержит комбинацию'#13+
'из букв \<D\>, \<T\>, \<S\> и \<C\> и может быть пустой. Кроме того, даны два целых'#13+
'числа {X}_1 и {X}_2. Создать набор из {N} объектов типа \MFunction\m, формируя каждый'#13+
'элемент следующим образом: вначале создать объект типа \MFX\m, а затем'#13+
'последовательно применять к результирующему объекту декораторы \MFDouble\m,'#13+
'\MFTriple\m, \MFSquare\m, \MFCube\m, причем количество и порядок декораторов определяется'#13+
'символами соответствующей строки из исходного набора (например, в случае'#13+
'строки \<TCSS\> к исходному объекту типа \MFX\m надо последовательно применить'#13+
'декораторы \MFTriple\m, \MFCube\m и два декоратора \MFSquare\m). Перебирая созданный набор'#13+
'из {N} объектов в исходном порядке, вызвать для каждого из них метод \MGetName\m,'#13+
'метод \MGetValue\m с параметром {X}_1, метод \MGetValue\m с параметром {X}_2'#13+
'и вывести их возвращаемые значения.'
);

n := Random(4) + 6;
repeat
len0 := 0;
len1 := 0;
len35 := 0;
len5 := 0;
for i := 1 to n do
begin
  len[i] := Random(6);
  if len[i] = 0 then
    len0 := len0 + 1;
  if len[i] = 1 then
    len1 := len1 + 1;
  if len[i] >= 3 then
    len35 := len35 + 1;
  if len[i] = 5 then
    len5 := len5 + 1;
end;
until (len1 = 1) and (len0 = 1) and (len35 >= n-3) and (len5 >= 1);

repeat
max := 0;
zero := false;
x1 := Random(9) + 2;
repeat
  x2 := Random(9) + 2;
until x1 <> x2;

cube := 0;
sq := 0;
for i := 1 to n do
begin
p[i] := '';
for j := 1 to len[i] do
  case Random(9) of
  0,1,7:  p[i] := p[i] + 'D';
  2,3,8:  p[i] := p[i] + 'T';
  4,5:  begin
          p[i] := p[i] + 'S';
          sq := sq + 1;
        end;
  6:    begin
          p[i] := 'C' + p[i];
          cube := cube + 1;
        end;
  end;
end;

for i := 1 to n do
begin
  v1[i] := v(p[i], x1);
  v2[i] := v(p[i], x2);
  if v1[i] > max then
    max := v1[i];
  if v2[i] > max then
    max := v2[i];
  if (v2[i] = 0) or (v1[i] = 0) then
    zero := true;
end;
until (max < 1000) and not zero and (sq > 0) and (cube > 0);



DataN('N = ', n, 0, 1, 1);
for i := 1 to n do
  DataS('', p[i], Center(i, n, 7, 1), 2);
DataN('X1 = ', x1, xLeft, 3, 1);
DataN('X2 = ', x2, xRight, 3, 1);


for i := 1 to n do
begin
  ResultS('', form(p[i]), xLeft, i);
  ResultN('', v1[i], 50, i, 1);
  ResultN('', v2[i], 60, i, 1);

end;
end;


function centers(s: string; start, width: integer): integer;
begin
  result := start + (width - Length(s)+1) div 2;
end;



procedure Pat10;
var i, n, a, b, k, c: integer;
    s: string;
    isA: boolean;


function MakeStr(a: integer; b: integer): string;
var i: integer;
    c: char;
begin
  result := '';
  for i := 1 to b do
  begin
    c := chr(Random(25) + 66);
    if Random(2) = 0 then
      Inc(c, 32);
    result := result + c;
  end;
  for i := 1 to a do
  begin
    c := 'A';
    if Random(2) = 0 then
      Inc(c, 32);
    Insert(c, result, Random(length(result)+1) + 1);
  end;
end;

procedure countc(s: string; var AIsCreated: boolean; var c: integer);
var i: integer;
begin
  for i := 1 to length(s) do
  begin
    if not (s[i] in ['A', 'a']) then
      c := c + 1
    else
    if (s[i] in ['A', 'a']) and not AIsCreated then
    begin
       c := c + 1;
       AIsCreated := true;
    end
  end;
end;

begin
  CreateTask(Subgroup2);
  TaskText(
'\G<Graph\OOPFlyweight.png>\BFlyweight\b (\BПриспособленец\b)~\= структурный паттерн.'#13+
'\P\SЧастота использования\s: низкая.'#13+
'\P\SНазначение\s: применяет \Iразделение\i (т.\,е. совместное использование одного и того'#13+
'же экземпляра) для эффективной поддержки множества объектов, сохраняя основную'#13+
'часть их состояния во внешних данных клиента.'#13+
'\P\SУчастники\s: \P\X~\IFlyweight\i (\IПриспособленец\i)~\= объявляет интерфейс, с помощью'#13+
'которого приспособленцы могут получать внешнее состояние или воздействовать'#13+
'на него; \P\X~\IConcreteFlyweight\i (\IКонкретный приспособленец\i)~\= реализует интерфейс'#13+
'класса Flyweight и добавляет при необходимости внутреннее состояние (объект'#13+
'класса ConcreteFlyweight должен быть разделяемым, любое сохраняемое им'#13+
'состояние должно быть \Iвнутренним\i, то есть не зависящим от контекста);'#13+
'\P\X~\IUnsharedConcreteFlyweight\i (\IНеразделяемый конкретный приспособленец\i)~\='#13+
'реализует интерфейс класса Flyweight, но не является разделяемым; данный класс'#13+
'может сохранять состояние, зависящее от контекста; \P\X~\IFlyweightFactory\i'#13+
'(\IФабрика приспособленцев\i)~\= создает объекты-приспособленцы и управляет ими;'#13+
'при запросе клиентом приспособленца объект FlyweightFactory предоставляет'#13+
'существующий экземпляр или создает новый, если готового еще нет;'#13+
'\P\X~\IClient\i (\IКлиент\i)~\= хранит ссылки на одного или нескольких приспособленцев;'#13+
'вычисляет или хранит внешнее состояние приспособленцев.'#13+
'\P\SЗадание 1\s. Реализовать иерархию классов, которая включает абстрактный класс'#13+
'\MFlyweight\m с абстрактным методом \MOperation(state)\m, который имеет логический'#13+
'параметр \Mstate\m и возвращает символьное значение, и конкретные классы'#13+
'\MConcreteFlyweight\m и \MUnsharedConcreteFlyweight\m~\= потомки класса \MFlyweight\m.'#13+
'Предполагается, что клиент будет использовать большое количество объектов'#13+
'класса \MConcreteFlyweight\m, поэтому этот класс должен поддерживать разделение.'#13+
'Метод \MOperation(state)\m класса \MConcreteFlyweight\m возвращает символ \<A\>,'#13+
'регистр которого зависит от значения \Mstate\m (если \Mstate\m равен \M\t\m,'#13+
'то используется верхний регистр, если \Mstate\m равен \M\f\m, то нижний).'#13+
'Конструктор класса \MConcreteFlyweight\m не имеет параметров'#13+
'и не выполняет дополнительных действий.'#13+
'\PКласс \MUnsharedConcreteFlyweight\m не является разделяемым; он хранит'#13+
'дополнительное символьное поле \Minf\m, которое инициализируется в конструкторе,'#13+
'имеющем соответствующий символьный параметр. Метод \MOperation(state)\m класса'#13+
'\MUnsharedConcreteFlyweight\m возвращает символ \Minf\m, его регистр определяется'#13+
'параметром \Mstate\m (как в методе \MOperation\m класса \MConcreteFlyweight\m).'#13+
'\PРеализовать класс-фабрику \MFlyweightFactory\m, содержащий поле-ссылку \Mcf\m типа'#13+
'\MConcreteFlyweight\m и поле \Mcount\m целого типа, а также конструктор без параметров'#13+
'(при создании данного объекта поле \Mcf\m содержит пустую ссылку, а поле \Mcount\m~\='#13+
'значение~0). Класс содержит метод \MGetFlyweight(inf)\m с символьным параметром'#13+
'и возвращаемым значением-ссылкой типа \MFlyweight\m. Если параметр отличен'#13+
'от символа \<A\> или \<a\>, то фабрика создает и возвращает новый объект'#13+
'типа \MUnsharedConcreteFlyweight\m, используя конструктор с параметром \Minf\m.'#13+
'Если параметр представляет собой символ \<A\> или \<a\>, то в случае, если'#13+
'поле \Mcf\m содержит ссылку на существующий объект типа \MConcreteFlyweight\m,'#13+
'возвращается этот объект, если же поле \Mcf\m является пустым, то объект типа'#13+
'\MConcreteFlyweight\m создается, сохраняется в поле \Mcf\m и возвращается методом'#13+
'\MGetFlyweight\m. Если в методе \MGetFlyweight\m создается новый объект, то поле'#13+
'\Mcount\m увеличивается на~1; таким образом, данное поле хранит общее количество'#13+
'созданных объектов. Значение поля \Mcount\m можно получить'#13+
'с помощью метода \MGetCount\m без параметров.'#13+
'\PРеализовать также класс \MClient\m, предназначенный для создания, хранения'#13+
'и обработки наборов объектов типа \MFlyweight\m. Класс содержит поля~\Mf\m~\= объект'#13+
'типа \MFlyweightFactory\m и \Mfw\m~\= структуру ссылочных данных (например, массив)'#13+
'с элементами типа \MFlyweight\m (можно считать, что число элементов \Mfw\m'#13+
'не превосходит~30). Конструктор класса \MClient\m не имеет параметров, в нем'#13+
'создается объект~\Mf\m и инициализируется структура данных \Mfw\m. Класс содержит'#13+
'методы \MMakeFlyweights(inf)\m, \MShowFlyweights(state)\m и \MGetFlyweightCount\m.'#13+
'Параметр \Minf\m метода \MMakeFlyweights\m является строкой, определяющей'#13+
'набор создаваемых объектов типа \MFlyweight\m (для создания требуемого набора'#13+
'в методе \MMakeFlyweights\m в цикле вызывается метод \MGetFlyweight\m объекта~\Mf\m'#13+
'с параметром~\= очередным символом строки \Minf\m). Ссылки на созданные объекты'#13+
'сохраняются в структуре \Mfw\m; при каждом вызове метода \MMakeFlyweights\m прежнее'#13+
'содержимое структуры \Mfw\m очищается. Метод \MShowFlyweights(state)\m возвращает'#13+
'строку, состоящую из символов, возвращаемых методом \MOperation(state)\m'#13+
'для каждого элемента структуры данных \Mfw\m. Метод \MGetFlyweightCount\m'#13+
'без параметров возвращает количество объектов, созданных к данному моменту'#13+
'фабрикой~\Mf\m; для этого используется ее метод \MGetCount\m.'#13+
TestHeader+
'Даны пять текстовых строк; длина каждой строки не превосходит~30, большинство'#13+
'символов в этих строках являются символами \<A\> в верхнем или нижнем регистре.'#13+
'Создать объект типа \MClient\m и для каждой исходной строки \Ms\m вызвать'#13+
'метод \MMakeFlyweights(s)\m и вывести значения, возвращаемые методами'#13+
'\MShowFlyweights(\t)\m, \MShowFlyweights(\f)\m и \MGetFlyweightCount\m.'
);

 k := CurrentTest;
 isA := false;
 c := 0;
 for i := 1 to 5 do
 begin
   case Random(4) of
   0: begin
        n := Random(5) + 2;
        b := n;
      end;
   1: begin
        n := Random(5) + 2;
        b := Random(n) + 1;
      end;
   2..3:
      begin
        n := Random(11) + 20;
        b := Random(5);
      end;
   end;
   if (i = 1) and (k = 3) then
   begin
     n := Random(5) + 5;
     b := n;
   end;
   a := n - b;
   s := MakeStr(a, b);
   DataS('', s, 0, i);
   ResultS('', Uppercase(s), centers(s, 1, 30)+3, i);
   ResultS('', Lowercase(s), centers(s, 35, 30)+3, i);
   countc(s, isA, c);
   ResultN('', c, 72, i, 3);
 end;


end;


procedure Pat11;
var k: array[1..3] of integer;
    tit: array[1..3] of string;
    realsub, def, prot, avail: boolean;
    t1, t2, i, j: integer;
    s: string;
    c: char;

function Operation(op: char; realsub, def, prot: boolean; var avail: boolean): string;
begin
  if realsub then
    result := op + ' (Real)'
  else
    if prot and (op in ['B', 'D']) then
      result := op + ' denied'
    else
      if (op in ['A', 'B']) and not avail then
      result := op + ' (Proxy)'
      else
      begin
        result := op + ' (Real)';
        avail := true;
      end;
end;

begin
  CreateTask(Subgroup2);
  TaskText(
'\G<Graph\OOPProxy.png>\BProxy\b (\BЗаместитель\b)~\= структурный паттерн.'#13+
'\PИзвестен также под именем \BSurrogate\b (\BСуррогат\b).'#13+
'\P\SЧастота использования\s: выше средней.'#13+
'\P\SНазначение\s: является суррогатом другого объекта и контролирует доступ к нему.'#13+
'\P\SУчастники\s: \P\X~\ISubject\i (\IСубъект\i)~\= определяет общий для RealSubject и Proxy'#13+
'интерфейс, так что класс Proxy можно использовать везде, где ожидается'#13+
'RealSubject; \P\X~\IRealSubject\i (\IРеальный субъект\i)~\= определяет реальный объект,'#13+
'представленный заместителем; \P\X~\IProxy\i (\IЗаместитель\i)~\= хранит ссылку, которая'#13+
'позволяет заместителю обратиться к реальному субъекту; контролирует доступ'#13+
'к реальному субъекту и может отвечать за его создание и удаление; прочие'#13+
'обязанности зависят от вида заместителя (\Iудаленный заместитель\i отвечает'#13+
'за отправление запроса реальному субъекту в другом адресном пространстве;'#13+
'\Iвиртуальный заместитель\i может отложить создание реального субъекта и вызывать'#13+
'некоторые его методы самостоятельно; \Iзащищающий заместитель\i проверяет,'#13+
'имеет ли вызывающий объект необходимые для выполнения запроса права;'#13+
'\Iкэширующий заместитель\i обеспечивает временное хранение результатов ранее'#13+
'выполненных высокозатратных запросов и совместный доступ к этим результатам;'#13+
'имеются и другие виды заместителей).'#13+
'\P\SЗадание 1\s. Реализовать иерархию классов, включающую абстрактный класс \MSubject\m'#13+
'с абстрактными методами \MRequestA\m, \MRequestB\m, \MRequestC\m, \MRequestD\m и конкретные'#13+
'классы \MRealSubject\m и \MProxy\m~\= потомки класса \MSubject\m. Указанные методы'#13+
'не имеют параметров и возвращают строку. Класс \MRealSubject\m не имеет полей,'#13+
'его методы возвращают строки \<A (Real)\>, \<B (Real)\>, \<C (Real)\>, \<D (Real)\>.'#13+
'\PКласс \MProxy\m является заместителем класса \MRealSubject\m, комбинирующим черты'#13+
'виртуального и защищающего заместителя. Предполагается, что запросы~A и~B'#13+
'являются простыми и могут быть реализованы в самом заместителе, в то время как'#13+
'запросы~C и~D являются сложными и доступны только в классе \MRealSubject\m.'#13+
'Кроме того, запросы~A и~C являются безопасными, а запросы~B и~D~\='#13+
'потенциально опасными, и в некоторых ситуациях их целесообразно заблокировать.'#13+
'Поэтому класс \MProxy\m содержит два логических поля: \MdeferredMode\m (отложенный'#13+
'режим) и \MprotectedMode\m (защищенный режим), которые задаются в его конструкторе'#13+
'с помощью одноименных параметров и определяют его поведение по отношению'#13+
'к реальному субъекту. Кроме того, класс \MProxy\m содержит поле \Mrsubj\m~\='#13+
'ссылку на объект типа \MRealSubject\m.'#13+
'\PЕсли поле \MdeferredMode\m равно \M\f\m, то объект \MRealSubject\m создается'#13+
'в конструкторе класса \MProxy\m (и связывается со ссылкой \Mrsubj\m),'#13+
'если \MdeferredMode\m равно \M\t\m, то начальное значение ссылки \Mrsubj\m'#13+
'является пустым. Если поле \MprotectedMode\m равно \M\f\m и при этом ссылка \Mrsubj\m'#13+
'не является пустой, то все запросы переадресуются объекту, на который'#13+
'ссылается \Mrsubj\m. Если \MprotectedMode\m равно \M\f\m, а ссылка \Mrsubj\m является'#13+
'пустой, то простые запросы~A и~B выполняются самим объектом \MProxy\m и при этом'#13+
'возвращаются строки \<A (Proxy)\> и \<B (Proxy)\>, а в случае вызова'#13+
'запроса~C или~D объект \MRealSubject\m создается и связывается со ссылкой'#13+
'\Mrsubj\m, после чего этот запрос переадресуется ему. Если \MprotectedMode\m равно'#13+
'\M\t\m, то выполнение запросов~A и~C не отличается от ранее описанного,'#13+
'а при попытке вызова запросов~B и~D они отменяются (независимо от значения'#13+
'ссылки \Mrsubj\m), причем соответствующие методы возвращают строки'#13+
'\<B denied\> и \<D denied\>.'#13+
TestHeader+
'Дан набор из трех целых чисел, принимающих значения от~\-1 до~3, и строка,'#13+
'содержащая только символы \<A\>, \<B\>, \<C\>, \<D\>~\= имена запросов.'#13+
'Создать массив из трех ссылочных элементов типа \MSubject\m, инициализировав'#13+
'элементы конкретными объектами в зависимости от значения исходных чисел:'#13+
'\-1~\= \MRealSubject\m, 0~\= \MProxy(\f, \f)\m, 1~\= \MProxy(\t, \f)\m,'#13+
'2~\= \MProxy(\f, \t)\m, 3~\= \MProxy(\t, \t)\m. Для каждого из созданных'#13+
'объектов выполнить набор запросов, определяемый исходной строкой,'#13+
'и вывести результат, возвращаемый каждым запросом.'
);

case CurrentTest of
0,6..9: k[1] := Random(5) - 1;
1: k[1] := -1;
2: k[1] := 0;
3: k[1] := 1;
4: k[1] := 2;
5: k[1] := 3;
end;

repeat
  k[2] := Random(5) - 1;
  k[3] := Random(5) - 1;
until (k[1]-k[2])*(k[2]-k[3])*(k[3]-k[1]) <> 0;

s := 'ABCD';
for i := 1 to 2 do
  s :=  s + chr(Random(4) + 65);

for i := 1 to 3 do
begin
  t1 := Random(6)+1;
  repeat
  t2 := Random(6)+1;
  until t2 <> t1;
  c := s[t1];
  s[t1] := s[t2];
  s[t2] := c;
end;

for i := 1 to 3 do
  DataN('', k[i], Center(i, 3, 2, 4) - 7, 1, 2);
DataS('', s, 45, 1);

tit[1] := 'Первый объект:';
tit[2] := 'Второй объект:';
tit[3] := 'Третий объект:';


for i := 1 to 3 do
begin
  case k[i] of
  -1: realsub := true;
  0: begin
       realsub := false;
       def := false;
       prot := false;
     end;
  1: begin
       realsub := false;
       def := true;
       prot := false;
     end;
  2: begin
       realsub := false;
       def := false;
       prot := true;
     end;
  3: begin
       realsub := false;
       def := true;
       prot := true;
     end;
   end;

   avail := not def;
   ResultComment(tit[i], 1, i*2-1);
   for j := 1 to 6 do
     ResultS('',Operation(s[j], realsub, def, prot, avail), Center(j, 6, 11, 2), 2*i);
end;
   SetTestCount(9);


end;





procedure InitTask(num: integer); stdcall;
begin
  case num of
  1: Pat1(1);
  2: Pat1(2);
  3: Pat3(1);
  4: Pat3(2);
  5: Pat6;
  6: Pat7;
  7: Pat8;
  8: Pat9;
  9: Pat11;
  10: Pat5;
  11: Pat10;
  end;
end;

procedure inittaskgroup;
begin
  // процедура inittaskgroup должна быть оформлена как экспортируемая
  // процедура данной библиотеки; в ней выполняется вызов стартовой
  // процедуры CreateGroup и могут вызываться процедуры, связанные
  // с добавлением комментариев (преамбул) для группы и ее подгрупп
  if CurrentLanguage = lgC then
    exit;
  CreateGroup('OOP2Struc', 'Структурные паттерны',
    'М. Э. Абрамян, 2022', 'qwке654#EnTopic<Structural patterns>#34444тоьdfttd', 11, InitTask);
end;

//exports inittaskgroup, activate;

begin
end.
