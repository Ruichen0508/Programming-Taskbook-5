{$A+,B-,D-,E+,F-,G-,I+,L-,N+,O-,P-,Q-,R-,S-,T-,V+,X+,Y-}

//---------------------------------
unit PT4MPI7Win_ru;

{$MODE Delphi}

interface


procedure InitTask(num: integer); stdcall;
procedure inittaskgroup;


implementation


uses PT5TaskMaker, SysUtils;

//-----------------------------------

const
  alphabet = '0123456789abcdefghijklmnopqrstuvwxyz';
  prcname = 'Процесс %d: ';
  title1 = 'Односторонние коммуникации с простейшей синхронизацией';
  title2 = 'Дополнительные виды синхронизации';

function RandomName(len: integer): string;
var i: integer;
begin
  result := '';
  for i := 1 to len do
    result := result + alphabet[Random(length(alphabet))+1];
end;

function Prc(n: integer): string;
begin
  result := Format(prcname, [n]);
end;

function PrcLong(n, nmax: integer): string;
begin
  result := Format(prcname, [n]);
  if (nmax > 9) and (n < 10) then
    result := result + ' ';
end;

procedure SwapN(var a,b: integer);
var c: integer;
begin
  c := a;
  a := b;
  b := c;
end;

procedure SwapR(var a,b: real);
var c: real;
begin
  c := a;
  a := b;
  b := c;
end;

var a: array[1..64] of integer;
    b, b1: array[1..64] of real;
    n, m, k: integer;

procedure MPIWin1;
var
  i, j, k0, x1, x2, y1, y2: integer;
begin
  n := RandomN(5,10);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В каждом из подчиненных процессов дано одно целое число. В главном процессе'#13#10
+'определить окно доступа размера {K} целых чисел ({K} \= количество подчиненных'#13#10
+'процессов) и, используя функцию MPI\_Put в подчиненных процессах, записать'#13#10
+'в главный процесс все исходные числа, после чего вывести эти числа в порядке'#13#10
+'возрастания рангов переславших их процессов.'
);
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    a[i] := RandomN(10,99);
    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;
    y1 := (i+1) div 2;
    DataN(prc(i), a[i], x1, y1, 2);
    end;
  SetProcess(0);
  ResultComment(prc(0),1,3);
  x2 := 13;
  y2 := 3;
  for i := 1 to n - 1 do
  begin
    ResultN(a[i], x2, y2, 2);
    x2 := x2 + 4;
  end;

end;

procedure MPIWin2;
var
  i, j, k0, x1, x2, y1, y2: integer;
begin
  n := RandomN(5,9);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В каждом из подчиненных процессов дано {R} вещественных чисел, где {R} \= ранг'#13#10
+'процесса (1, 2,~\.). В главном процессе определить окно доступа подходящего'#13#10
+'размера и, используя функцию MPI\_Put в подчиненных процессах, записать'#13#10
+'в главный процесс все исходные числа, после чего вывести эти числа в порядке'#13#10
+'возрастания рангов переславших их процессов.'
);
  k0 := 0;
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 38 * ((i+1) mod 2);
    y1 := (i+1) div 2;
    if i = 8 then
    begin
      x1 := 1;
      y1 := 5;
    end;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 5;
    for j := 1 to i do
    begin
      k0 := k0 + 1;
      b[k0] := RandomR(1,9.99);
      x1 := x1 + 5;
      DataR(b[k0], x1, y1, 5);
    end;
  end;
  SetProcess(0);
  ResultComment(prc(0),1,2);
  x2 := 12;
  y2 := 2;
  for i := 1 to k0 do
  begin
    ResultR(b[i], x2, y2, 2);
    x2 := x2 + 5;
    if x2 > 75 then
    begin
      x2 := 12;
      y2 := y2 + 1;
    end;
  end;

end;

procedure MPIWin3;
var
  i, j, k0, x1, x2, y1, y2: integer;
begin
  n := RandomN(5,10);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В главном процессе дан массив {A} из {K} целых чисел, где {K} \= количество'#13#10
+'подчиненных процессов. Определить в главном процессе окно доступа, содержащее'#13#10
+'массив {A}, и, используя функцию MPI\_Get в подчиненных процессах, получить'#13#10
+'и вывести в них по одному элементу массива {A}, перебирая элементы с конца'#13#10
+'(элемент {A}_0 получить в последнем процессе, {A}_1 в предпоследнем, и~т.\,д.).'
);
  for i := 1 to n - 1 do
    a[i] := RandomN(10,99);
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;

    y1 := (i+1) div 2;
    ResultN(prc(i), a[n-i], x1, y1, 2);
    end;
  SetProcess(0);
  DataComment(prc(0),1,3);
  x2 := 13;
  y2 := 3;
  for i := 1 to n - 1 do
  begin
    DataN(a[i], x2, y2, 2);
    x2 := x2 + 4;
  end;

end;

procedure MPIWin4;
var
  i, j, k0, x1, x2, y1, y2: integer;
begin
  n := RandomN(5,10);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В главном процессе дан массив {A} из {K}~+~4 вещественных чисел, где {K} \='#13#10
+'количество подчиненных процессов. Определить в главном процессе окно доступа,'#13#10
+'содержащее массив {A}, и, используя функцию MPI\_Get в подчиненных процессах,'#13#10
+'получить и вывести в них по пять элементов массива {A}, начиная с элемента'#13#10
+'с индексом {R}~\-~1, где {R} \= ранг подчиненного процесса ({R}~=~1, 2,~\., {K}~\-~1).'
);
  for i := 1 to 3 + n do
    b[i] := RandomR(1,9.99);
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i+1) mod 2);
    y1 := (i+1) div 2;
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 6;
    for j := i to i + 4 do
    begin
    x1 := x1 + 5;
    ResultR(b[j], x1, y1, 5);
    end;
    end;
  SetProcess(0);
  DataComment(prc(0),1,3);
  x2 := 12;
  y2 := 3;
  for i := 1 to 3 + n do
  begin
    DataR(b[i], x2, y2, 5);
    x2 := x2 + 5;
  end;

end;

procedure MPIWin5;
var
  i, j, x1, x2, y1, y2: integer;
  k0, k1, a1: array [1..20] of integer;
  f: boolean;
begin
  n := RandomN(5,10);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В главном процессе дан массив {A} из {K} целых чисел, где {K} \= количество'#13#10
+'подчиненных процессов. В каждом подчиненном процессе дан индекс {N}'#13#10
+'(число от 0 до {K}~\-~1) и целое число {B}. В главном процессе определить окно'#13#10
+'доступа, содержащее массив {A}, и, используя функцию MPI\_Accumulate в каждом'#13#10
+'подчиненном процессе, умножить элемент {A}_N на число {B}, после чего вывести'#13#10
+'в главном процессе измененный массив {A}.'#13#10
+'\P\SПримечание.\s Некоторые подчиненные процессы могут содержать совпадающие'#13#10
+'значения {N}; в этом случае элемент {A}_N должен умножаться на несколько чисел.'#13#10
+'Данное обстоятельство не требует дополнительных действий по синхронизации'#13#10
+'в силу особенностей реализации функции MPI\_Accumulate.'
);
  x2 := 9;
  y2 := 1;
  DataComment(prc(0),x2,1);
  x2 := x2 + 8;
  for i := 1 to n - 1 do
  begin
    x2 := x2 + 4;
    a[i] := RandomN(1,20);
    DataN(a[i], x2, y2, 3);
  end;
  repeat
  for i := 1 to n - 1 do
  begin
    k0[i] := RandomN(0, n-2);
    k1[i] := RandomN(2, 8);
    a1[i] := a[i];
  end;
  f := true;
  for i := 1 to n - 1 do
  begin
    a1[k0[i]+1] := a1[k0[i]+1] * k1[i];
    if a1[k0[i]+1] > 999 then
    begin
      f := false;
      break;
    end;
  end;
  until f;
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 9 + 39 * ((i+1) mod 2);
    y1 := (i+1) div 2 + 1;
    DataN(prc(i)+' N = ', k0[i], x1, y1, 1);
    DataN('B = ', k1[i], x1+19, y1, 1);
    end;
  SetProcess(0);
  x2 := 9;
  y2 := 1;
  ResultComment(prc(0),x2,1);
  x2 := x2 + 8;
  for i := 1 to n - 1 do
  begin
    x2 := x2 + 4;
    ResultN(a1[i], x2, y2, 3);
  end;
end;

procedure MPIWin6;
var
  i, j, k0, x1, x2, y1, y2: integer;
  b0: real;
begin
  n := RandomN(4,7);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В главном процессе дан вещественный массив {A} размера 2{K}~\-~1 ({K} \= количество'#13#10
+'подчиненных процессов), в каждом подчиненном процессе дан вещественный'#13#10
+'массив {B} размера {R}, где {R} \= ранг процесса (1, 2,~\., {K}~\-~1). В главном'#13#10
+'процессе определить окно доступа, содержащее массив {A}, и, используя функцию'#13#10
+'MPI\_Accumulate в каждом подчиненном процессе, прибавить к элементам массива {A},'#13#10
+'начиная с индекса {R}~\-~1, значения всех элементов массива {B} из процесса'#13#10
+'ранга {R}, после чего вывести в главном процессе измененный массив {A}'#13#10
+'(единственный элемент {B}_0 из процесса 1 прибавляется к элементу {A}_0, элементы {B}_0'#13#10
+'и {B}_1 из процесса 2 прибавляются соответственно к элементам {A}_1 и {A}_2,'#13#10
+'элементы {B}_0, {B}_1 и {B}_2 из процесса 3 прибавляются соответственно'#13#10
+'к элементам {A}_2, {A}_3 и {A}_4, и~т.\,д.).'#13#10
+'\P\SПримечание.\s К элементам массива {A}, начиная с индекса 2, потребуется прибавлять'#13#10
+'несколько значений из разных подчиненных процессов. Данное обстоятельство'#13#10
+'не требует дополнительных действий по синхронизации в силу особенностей'#13#10
+'реализации функции MPI\_Accumulate.'
);
  SetProcess(0);
  DataComment(prc(0),1,1);
  x2 := 12;
  y2 := 1;
  for i := 1 to 2*n-3 do
  begin
    b[i] := RandomR(10,50);
    DataR(b[i], x2, y2, 5);
    x2 := x2 + 6;
  end;
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 38 * ((i+1) mod 2);
    y1 := (i+1) div 2 + 1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 5;
    for j := 1 to i do
    begin
      b0 := RandomR(1,9.99);
      x1 := x1 + 5;
      DataR(b0, x1, y1, 5);
      b[i+j-1] := b[i+j-1] + b0;
    end;
  end;
  SetProcess(0);
  ResultComment(prc(0),1,2);
  x2 := 12;
  y2 := 2;
  for i := 1 to 2*n-3 do
  begin
    ResultR(b[i], x2, y2, 5);
    x2 := x2 + 6;
  end;

end;


procedure MPIWin7;
var
  i, j, k0, x1, x2, y1, y2: integer;
begin
  n := RandomN(5,9);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В главном процессе дан массив {A} из 2{K} целых чисел, где {K} \= количество'#13#10
+'подчиненных процессов. Во всех подчиненных процессах определить окно доступа'#13#10
+'из двух целых чисел и, используя несколько вызовов функции MPI\_Put в главном'#13#10
+'процессе, записать и вывести в каждом подчиненном процессе по два элемента'#13#10
+'из массива {A}, перебирая их в исходном порядке (элементы {A}_0 и {A}_1 надо вывести'#13#10
+'в процессе 1, элементы {A}_2 и {A}_3 \= в процессе 2, и~т.\,д.).'
);
  for i := 1 to 2*n - 2 do
    a[i] := RandomN(10,99);
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;

    y1 := (i+1) div 2;
    ResultN2(prc(i), a[2*i-1], a[2*i], x1, y1, 3);
    end;
  SetProcess(0);
  DataComment(prc(0),1,3);
  x2 := 13;
  y2 := 3;
  for i := 1 to 2*n - 2 do
  begin
    DataN(a[i], x2, y2, 2);
    x2 := x2 + 4;
  end;

end;

procedure MPIWin8;
var
  i, j, x1, x2, y1, y2: integer;
begin
  n := RandomN(5,10);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дано целое число {R} и вещественное число {B}. Все числа {R}'#13#10
+'различны и лежат в диапазоне от 0 до {K}~\-~1, где {K} \= количество процессов.'#13#10
+'Во всех процессах определить окно доступа из одного вещественного числа и,'#13#10
+'используя функцию MPI\_Put в каждом процессе, переслать число {B} из этого'#13#10
+'процесса в процесс {R}, после чего вывести полученные числа во всех процессах.'
);
  for i := 1 to n do
  begin
    a[i] := i-1;
    b[i] := RandomR(10,99.99);
  end;
  for i := 1 to 2 * n do
    SwapN(a[RandomN(1, n)], a[RandomN(1, n)]);

  for i := 0 to n-1 do
  begin
    SetProcess(i);
    x1 := 7 + 39 * ((i) mod 2);
    y1 := (i) div 2 + 1;
    DataN(prc(i)+' R = ', a[i+1], x1, y1, 1);
    DataR('B = ', b[a[i+1]+1], x1+19, y1, 5);
  end;
  for i := 0 to n-1 do
  begin
    SetProcess(i);
    if not Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;
    y1 := (i) div 2 + 1;
    ResultR(prc(i), b[i+1], x1, y1, 1);
  end;
end;

procedure MPIWin9;
var
  i, j, x1, x2, y1, y2: integer;
  c: array[1..20,1..20] of integer;
begin
  n := RandomN(5,9);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дан массив {A} из {K} целых чисел, где {K} \= количество процессов.'#13#10
+'Во всех процессах определить окно доступа, содержащее массив {A}, и, используя'#13#10
+'несколько вызовов функции MPI\_Get в каждом процессе {R} ({R}~=~0,~\., {K}~\-~1),'#13#10
+'получить и вывести элементы всех массивов {A} с индексом {R}, перебирая'#13#10
+'эти элементы в порядке убывания рангов содержащих их процессов'#13#10
+'(вначале выводится элемент, полученный из процесса ранга {K}~\-~1,'#13#10
+'затем элемент из процесса ранга {K}~\-~2, и~т.\,д.).'#13#10
+'\P\SПримечание.\s Функцию MPI\_Get, как и другие функции, обеспечивающие'#13#10
+'односторонние коммуникации, можно использовать и для доступа к окну,'#13#10
+'определенному в вызывающем процессе.'
);
  for i := 1 to n do
  for j := 1 to n do
    c[i,j] := RandomN(10,99);
  for i := 0 to n-1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
    y1 := (i) div 2 + 1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n do
    begin
    DataN(c[i+1,j], x1, y1, 2);
    x1 := x1 + 3;
    end;
    x1 := 1 + 40 * ((i) mod 2);
    y1 := (i) div 2 + 1;
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n do
    begin
    ResultN(c[n-j+1,i+1], x1, y1, 2);
    x1 := x1 + 3;
    end;
  end;
end;

procedure MPIWin10;
var
  i, j, k1, k2, x1, x2, y1, y2: integer;
  c: array[1..20,1..20] of real;
begin
  n := RandomN(5,10);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дан массив {A} из 3 вещественных чисел и целые числа {N}_1 и {N}_2,'#13#10
+'каждое из которых лежит в диапазоне от 0 до 2. Во всех процессах определить'#13#10
+'окно доступа, содержащее массив {A}, и, используя по два вызова функции MPI\_Get'#13#10
+'в каждом процессе, получить из предыдущего процесса элемент его массива {A}'#13#10
+'с индексом {N}_1, а из последующего процесса \= элемент с индексом {N}_2 (числа {N}_1'#13#10
+'и {N}_2 берутся из вызывающего процесса, процессы перебираются циклически).'#13#10
+'Вывести в каждом процессе полученные числа в указанном порядке.'
);
  for i := 1 to n do
  for j := 1 to 3 do
    c[i,j] := RandomR(1,9.99);
  for i := 0 to n-1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
    y1 := (i) div 2 + 1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to 3 do
    begin
    DataR(c[i+1,j], x1, y1, 4);
    x1 := x1 + 5;
    end;
    k1 := RandomN(0,2);
    k2 := RandomN(0,2);
    DataN('N_1=', k1, x1+1, y1, 1);
    DataN('N_2=', k2, x1+7, y1, 1);
    if not Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;
    y1 := (i) div 2 + 1;
    ResultR2(prc(i), c[(i+n-1) mod n + 1, k1+1],
      c[(i+1) mod n + 1, k2+1], x1, y1, 5);
  end;
end;

procedure MPIWin11;
var
  i, j, x1, x2, y1, y2: integer;
  c: array[1..20,1..20] of integer;
begin
  n := 2*RandomN(3,5);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе дан массив {A}'#13#10
+'из {K}/2 целых чисел. Во всех процессах нечетного ранга (1, 3,~\., {K}~\-~1)'#13#10
+'определить окно доступа, содержащее массив {A}, и, используя требуемое число'#13#10
+'вызовов функции MPI\_Accumulate в каждом процессе четного ранга, добавить'#13#10
+'элемент {A}[{I}] из процесса ранга 2{J} к элементу {A}[{J}] из процесса ранга 2{I}~+~1'#13#10
+'({I}, {J}~=~0,~\., {K}/2~\-~1) и вывести измененные массивы {A} во всех процессах'#13#10
+'нечетного ранга.'#13#10
+'\P\SУказание.\s Требуемое преобразование можно описать по-другому: если через {B}'#13#10
+'обозначить матрицу порядка {K}/2, строки которой совпадают с массивами {A}'#13#10
+'из процессов четного ранга, а через {C} \= матрицу того же порядка,'#13#10
+'строки которой совпадают с массивами {A} из процессов нечетного ранга,'#13#10
+'то преобразование состоит в прибавлении к {I}-му столбцу матрицы {C}'#13#10
+'соответствующих элементов {I}-й строки матрицы {B}.'
);

  for i := 1 to n do
  for j := 1 to n div 2 do
    c[i,j] := RandomN(10,99);
  for i := 0 to n-1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    y1 := (i) div 2 + 1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n div 2 do
    begin
    DataN(c[i+1,j], x1, y1, 2);
    x1 := x1 + 3;
    end;
  end;
  for i := 0 to n div 2 - 1 do
  begin
    SetProcess(2*i+1);
    x1 := 29 - 2 * (n div 2 - 3);//1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    y1 := i+1;
    ResultComment(prc(2*i+1), x1, y1);
    x1 := x1 + 11;
    for j := 0 to n div 2 - 1 do
    begin
    ResultN(c[2*j+1,i+1] + c[2*(i+1),j+1], x1, y1, 3);
    x1 := x1 + 4;
    end;
  end;

end;

procedure MPIWin12;
var
  i, j, x1, x2, y1, y2: integer;
  c: array[1..20,1..20] of integer;
begin
  n := 2*RandomN(3,5);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Решить задачу \1, определив окна доступа в процессах четного ранга'#13#10
+'и используя вместо функций MPI\_Accumulate функции MPI\_Get в процессах'#13#10
+'нечетного ранга.'#13#10
+'\P\SУказание.\s Поскольку числа, полученные из процессов четного ранга, необходимо'#13#10
+'добавлять к элементам массива {A} после вызова функции синхронизации'#13#10
+'MPI\_Win\_fence, удобно использовать вспомогательный массив'#13#10
+'для хранения полученных чисел.'
);

  for i := 1 to n do
  for j := 1 to n div 2 do
    c[i,j] := RandomN(10,99);
  for i := 0 to n-1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    y1 := (i) div 2 + 1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n div 2 do
    begin
    DataN(c[i+1,j], x1, y1, 2);
    x1 := x1 + 3;
    end;
  end;
  for i := 0 to n div 2 - 1 do
  begin
    SetProcess(2*i+1);
    x1 := 29 - 2 * (n div 2 - 3);//1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    y1 := i+1;
    ResultComment(prc(2*i+1), x1, y1);
    x1 := x1 + 11;
    for j := 0 to n div 2 - 1 do
    begin
    ResultN(c[2*j+1,i+1] + c[2*(i+1),j+1], x1, y1, 3);
    x1 := x1 + 4;
    end;
  end;

end;


procedure MPIWin13;
var
  i, j, k0, x1, x2, y1, y2: integer;
  c: array[1..10,1..10] of real;
  k: array[1..10,1..3] of integer;
  f: boolean;
begin
  n := RandomN(4,7);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе даны три целых числа {N}_1, {N}_2, {N}_3, каждое из которых лежит'#13#10
+'в диапазоне от 0 до {K}~\-~1, где {K} \= количество процессов (значения некоторых'#13#10
+'из этих чисел в каждом процессе могут совпадать). Кроме того, в каждом'#13#10
+'процессе дан массив {A} вещественных чисел размера {R}~+~1, где {R} \= ранг процесса'#13#10
+'(0,~\., {K}~\-~1). Во всех процессах определить окно доступа, содержащее'#13#10
+'массив {A}, и, используя по три вызова функции MPI\_Accumulate в каждом процессе,'#13#10
+'добавить ко всем элементам массива {A} в процессах рангов {N}_1, {N}_2 и {N}_3'#13#10
+'вещественное число, равное {R}~+~1, где {R} \= ранг процесса, вызвавшего функции'#13#10
+'MPI\_Accumulate (например, если число {N}_1 в процессе ранга 3 равно 2, то ко всем'#13#10
+'элементам массива {A} из процесса 2 надо добавить вещественное число 4.0).'#13#10
+'Если некоторые из чисел {N}_1, {N}_2, {N}_3 в процессе {R} совпадают, то числа {R}~+~1'#13#10
+'надо добавлять к элементам соответствующих массивов несколько раз.'#13#10
+'Вывести измененные массивы {A} в каждом процессе.'
);
  repeat
    for i := 1 to n do
    begin
      for j := 1 to 3 do
        k[i,j] := RandomN(0, n-1);
      if (k[i,1]=k[i,2]) or (k[i,2]=k[i,3]) or (k[i,1]=k[i,3]) then
        f := true;
    end;
  until f;
  k0 := 0;
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 38 * ((i) mod 2);
    y1 := (i) div 2 + 1;
    if i >= 4 then
    begin
      x1 := 1;
      y1 := i-1;
    end;
    DataN3(prc(i), k[i+1,1], k[i+1,2], k[i+1,3], x1, y1, 2);
    x1 := x1 + 13;
    for j := 1 to i+1 do
    begin
      c[i+1, j] := RandomR(1,9.99);
      x1 := x1 + 5;
      DataR(c[i+1, j], x1, y1, 5);
    end;
  end;
  for i := 0 to n-1 do
    for j := 1 to 3 do
      for k0 := 1 to k[i+1, j]+ 1 do
        c[k[i+1, j]+1, k0] := c[k[i+1, j]+1, k0] + (i+1);
  for i := 0 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 38 * ((i) mod 2);
    y1 := (i) div 2 + 1;
    if i >= 4 then
    begin
      x1 := 1;
      y1 := i-1;
    end;
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 5;
    for j := 1 to i+1 do
    begin
      x1 := x1 + 6;
      ResultR(c[i+1, j], x1, y1, 6);
    end;
  end;

end;


procedure MPIWin14;
var
  i, j, x1, x2, y1, y2: integer;
  c: array[1..20,1..20] of real;
begin
  n := RandomN(3,6);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дан массив вещественных чисел размера {K} ({K} \= количество'#13#10
+'процессов), содержащий строку верхнетреугольной матрицы {A}, включая ее'#13#10
+'начальную нулевую часть (процесс ранга {R} содержит {R}-ю строку матрицы'#13#10
+'в предположении, что строки нумеруются от~0). Во всех процессах определить'#13#10
+'окно доступа, содержащее исходный массив, и, используя требуемое количество'#13#10
+'вызовов функции MPI\_Get в каждом процессе, записать в эти массивы'#13#10
+'(и затем вывести) строки матрицы, транспонированной к исходной матрице {A},'#13#10
+'включая ее завершающую нулевую часть. Вспомогательные массивы не использовать.'#13#10
+'\P\SУказания.\s (1)~Строки транспонированной матрицы совпадают со столбцами исходной'#13#10
+'матрицы, таким образом, полученная матрица будет нижнетреугольной.'#13#10
+'(2)~Обнулять требуемые элементы массивов перед их выводом необходимо после'#13#10
+'второго вызова функции MPI\_Win\_fence.'#13#10
+'(3)~Окно доступа для последнего процесса можно не создавать.'
);

  for i := 1 to n do
  for j := 1 to n do
    c[i,j] := 0;
  for i := 1 to n do
  for j := i to n do
    c[i,j] := RandomR(1,9.9);
  for i := 0 to n-1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    x1 := 20+5*(6-n) div 2;
    y1 := i + 1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n do
    begin
    DataR(c[i+1,j], x1, y1, 4);
    x1 := x1 + 5;
    end;
  end;
//    DataComment('----------------------------------------', 0, 7);
  for i := 1 to n do
    for j := i + 1 to n do
      swapR(c[i,j], c[j,i]);

  for i := 0 to n-1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    x1 := 20+5*(6-n) div 2;
    y1 := i + 1;
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n do
    begin
    ResultR(c[i+1,j], x1, y1, 4);
    x1 := x1 + 5;
    end;
  end;

end;

procedure MPIWin15;
var
  i, j, x1, x2, y1, y2: integer;
  c: array[1..20,1..20] of real;
begin
  n := RandomN(3,6);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'Решить задачу \1, используя вместо вызовов функций MPI\_Get'#13#10
+'вызовы функций MPI\_Put.'#13#10
+'\P\SУказание.\s В данном случае можно не создавать окно доступа'#13#10
+'для главного процесса.'
);

  for i := 1 to n do
  for j := 1 to n do
    c[i,j] := 0;
  for i := 1 to n do
  for j := i to n do
    c[i,j] := RandomR(1,9.9);
  for i := 0 to n-1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    x1 := 20+5*(6-n) div 2;
    y1 := i + 1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n do
    begin
    DataR(c[i+1,j], x1, y1, 4);
    x1 := x1 + 5;
    end;
  end;
//    DataComment('----------------------------------------', 0, 7);
  for i := 1 to n do
    for j := i + 1 to n do
      swapR(c[i,j], c[j,i]);

  for i := 0 to n-1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    x1 := 20+5*(6-n) div 2;
    y1 := i + 1;
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n do
    begin
    ResultR(c[i+1,j], x1, y1, 4);
    x1 := x1 + 5;
    end;
  end;

end;

procedure MPIWin16;
var
  i, j, x1, x2, y1, y2: integer;
  c: array[1..20,1..20] of real;
begin
  n := RandomN(3,6);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дана одна строка вещественной квадратной матрицы {A}'#13#10
+'порядка {K}, где {K} \= количество процессов (процесс ранга {R} содержит {R}-ю строку'#13#10
+'матрицы в предположении, что строки нумеруются от~0). Кроме того, в каждом'#13#10
+'процессе дано вещественное число {B}. Во всех процессах определить окно доступа,'#13#10
+'содержащее строку матрицы {A}, и, используя требуемое число вызовов функции'#13#10
+'MPI\_Accumulate в каждом процессе ранга {R} ({R}~=~0,~\., {K}~\-~1), заменить'#13#10
+'в строке матрицы из следующего процесса все элементы, меньшие числа {B}'#13#10
+'из процесса {R}, на это число (процессы перебираются циклически). Затем,'#13#10
+'используя {K} вызовов функции MPI\_Get в каждом процессе, получить и вывести'#13#10
+'столбец преобразованной матрицы {A} с номером, совпадающим с рангом процесса'#13#10
+'(столбцы также нумеруются от~0).'#13#10
+'\P\SУказание.\s При выполнении этого задания в каждом процессе необходимо \Iтрижды\i'#13#10
+'вызывать функцию синхронизации MPI\_Win\_fence.'
);

  for i := 1 to n do
  begin
    for j := 1 to n do
      c[i,j] := RandomR(1,9.99);
    b[i] := RandomR(1,9.99);
  end;
  for i := 0 to n-1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    x1 := 20+5*(6-n) div 2;
    y1 := i + 1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n do
    begin
    DataR(c[i+1,j], x1, y1, 4);
    x1 := x1 + 5;
    end;
    DataR('B = ', b[i+1], x1+2, y1, 4);

  end;
//    DataComment('----------------------------------------', 0, 7);
  for i := 1 to n do
    for j := 1 to n do
      if c[i mod n + 1, j] < b[i] then
         c[i mod n + 1, j] := b[i];

  for i := 0 to n-1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    x1 := 20+5*(6-n) div 2;
    y1 := i + 1;
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n do
    begin
    ResultR(c[j,i+1], x1, y1, 4);
    x1 := x1 + 5;
    end;
  end;

end;


procedure MPIWin17;
var
  i, j, x1, x2, y1, y2: integer;
  c: array[1..20,1..20] of real;
begin
  n := RandomN(3,6);
  CreateTask(title1, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дана одна строка вещественной квадратной матрицы {A}'#13#10
+'порядка {K}, где {K} \= количество процессов (процесс ранга {R} содержит {R}-ю строку'#13#10
+'матрицы в предположении, что строки нумеруются от~0). Кроме того, в каждом'#13#10
+'процессе дано вещественное число {B}. Во всех процессах определить окно доступа,'#13#10
+'содержащее строку матрицы {A}, и, используя требуемое число вызовов функции'#13#10
+'MPI\_Accumulate в каждом процессе ранга {R} ({R}~=~0,~\., {K}~\-~1), заменить'#13#10
+'в строке матрицы из предыдущего процесса все элементы, большие числа {B}'#13#10
+'из процесса {R}, на это число (процессы перебираются циклически). Затем,'#13#10
+'используя {K} вызовов функции MPI\_Accumulate в каждом подчиненном процессе,'#13#10
+'добавить начальный элемент строки из каждого подчиненного процесса ранга {R}'#13#10
+'(1,~\., {K}~\-~1) ко всем элементам столбца преобразованной матрицы {A}'#13#10
+'с номером {R} (столбцы также нумеруются от 0). После всех описанных'#13#10
+'преобразований вывести в каждом процессе новое содержимое'#13#10
+'соответствующей строки матрицы {A}.'#13#10
+'\P\SУказание.\s При выполнении этого задания в каждом процессе необходимо \Iтрижды\i'#13#10
+'вызывать функцию синхронизации MPI\_Win\_fence.'
);

  for i := 1 to n do
  begin
    for j := 1 to n do
      c[i,j] := RandomR(1,4.95);
    b[i] := RandomR(1,4.95);
  end;
  for i := 0 to n-1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    x1 := 20+5*(6-n) div 2;
    y1 := i + 1;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n do
    begin
    DataR(c[i+1,j], x1, y1, 4);
    x1 := x1 + 5;
    end;
    DataR('B = ', b[i+1], x1+2, y1, 4);

  end;
//    DataComment('----------------------------------------', 0, 7);
  for i := 1 to n do
    for j := 1 to n do
      if c[(i+n-2) mod n + 1, j] > b[i] then
         c[(i+n-2)  mod n + 1, j] := b[i];
  for i := 1 to n do
    for j := 2 to n do
      c[i,j] := c[i,j] + c[j,1];
  for i := 0 to n-1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    x1 := 20+5*(6-n) div 2;
    y1 := i + 1;
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 11;
    for j := 1 to n do
    begin
    ResultR(c[i+1,j], x1, y1, 4);
    x1 := x1 + 5;
    end;
  end;

end;

procedure MPIWin18;
var
  i, j, k0, x1, x2, y1, y2: integer;
begin
  n := 2*RandomN(3,5);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В каждом процессе четного ранга'#13#10
+'(0, 2,~\., {K}~\-~2) дано целое число {A}. Во всех процессах нечетного ранга'#13#10
+'(1, 3,~\., {K}~\-~1) определить окно доступа из одного целого числа и, используя'#13#10
+'функцию MPI\_Put в каждом процессе четного ранга 2{N}, переслать число {A}'#13#10
+'в процесс ранга 2{N}~+~1 и вывести его в этом процессе. Для синхронизации'#13#10
+'использовать функции MPI\_Win\_start и MPI\_Win\_complete в процессах четного'#13#10
+'ранга и функции MPI\_Win\_post и MPI\_Win\_wait в процессах нечетного ранга;'#13#10
+'для создания группы процессов, указываемой в качестве первого параметра'#13#10
+'функций MPI\_Win\_start и MPI\_Win\_post, использовать функцию MPI\_Group\_incl,'#13#10
+'применив ее к группе, полученной из коммуникатора MPI\_COMM\_WORLD'#13#10
+'(с помощью функции MPI\_Comm\_group).'#13#10
+'\P\SПримечание.\s В отличие от \Iколлективной\i функции MPI\_Win\_fence,'#13#10
+'использовавшейся в предыдущих заданиях данной группы, синхронизирующие'#13#10
+'функции, используемые в этом и последующих заданиях, являются \Iлокальными\i'#13#10
+'и, кроме того, позволяют явным образом определить группы инициирующих (origin)'#13#10
+'и целевых (target) процессов при односторонних коммуникациях.'
);
  for i := 1 to n div 2 do
  begin
    SetProcess(2*(i-1));
//    x1 := 1 + 40 * ((i+1) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    y1 := i;
    a[i] := RandomN(10,99);
    DataN(prc(2*(i-1)), a[i], 0, y1, 2);
    end;
  for i := 1 to n div 2 do
  begin
    SetProcess(2*(i-1)+1);
//    x1 := 1 + 40 * ((i+1) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    y1 := i;
//    a[i] := RandomN(10,99);
    ResultN(prc(2*(i-1)+1), a[i], 0, y1, 2);
    end;

end;

procedure MPIWin19;
var
  i, j, k0, x1, x2, y1, y2: integer;
begin
  n := RandomN(5,10);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'В главном процессе дан массив {A} из {K} вещественных чисел, где {K} \= количество'#13#10
+'подчиненных процессов. В главном процессе определить окно доступа, содержащее'#13#10
+'массив {A}, и, используя функцию MPI\_Get в каждом подчиненном процессе, получить'#13#10
+'и вывести один из элементов массива {A}, перебирая элементы в обратном порядке'#13#10
+'(в процессе ранга 1 надо получить элемент массива с индексом {K}~\-~1, в процессе'#13#10
+'ранга 2 \= элемент с индексом {K}~\-~2, и~т.\,д.). Для синхронизации использовать'#13#10
+'функции MPI\_Win\_start и MPI\_Win\_complete в подчиненных процессах и функции'#13#10
+'MPI\_Win\_post и MPI\_Win\_wait в главном процессе; для создания группы процессов,'#13#10
+'указываемой в качестве первого параметра функции MPI\_Win\_start, использовать'#13#10
+'функцию MPI\_Group\_incl, для создания группы, указываемой в функции'#13#10
+'MPI\_Win\_post, использовать функцию MPI\_Group\_excl (применив обе эти функции'#13#10
+'к группе, полученной из коммуникатора MPI\_COMM\_WORLD).'
);
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    b[i] := RandomR(1,9.99);
//    x1 := 1 + 40 * ((i+1) mod 2);
    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;
    y1 := (i+1) div 2;
    ResultR(prc(i), b[i], x1, y1, 4);
    end;
  SetProcess(0);
  DataComment(prc(0),1,3);
  x2 := 13;
  y2 := 3;
  for i := 1 to n - 1 do
  begin
    DataR(b[n-i], x2, y2, 4);
    x2 := x2 + 5;
  end;

end;

procedure MPIWin20;
var
  i, j, k0, x1, x2, y1, y2: integer;
  k1, k2, k3: real;
begin
  n := 3*RandomN(2,5);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Число процессов {K} кратно 3. В процессах ранга 3{N} ({N}~=~0,~\., {K}/3~\-~1)'#13#10
+'дан массив {A} из трех вещественных чисел. Во всех процессах, в которых дан'#13#10
+'массив, определить окно доступа, содержащее этот массив, и, используя'#13#10
+'по одному вызову функции MPI\_Get в процессах ранга 3{N}~+~1 и 3{N}~+~2'#13#10
+'({N}~=~0,~\., {K}/3~\-~1), прочесть и вывести соответственно один элемент {A}_0'#13#10
+'и два элемента {A}_1 и {A}_2 из процесса ранга 3{N} (процесс 1 должен вывести'#13#10
+'элемент {A}_0, полученный из процесса~0, процесс 2 \= элементы {A}_1 и {A}_2, полученные'#13#10
+'из процесса~0, процесс 4 \= элемент {A}_0, полученный из процесса~3, и~т.\,д.).'#13#10
+'Для синхронизации использовать функции MPI\_Win\_post и MPI\_Win\_wait в процессах'#13#10
+'ранга 3{N} и функции MPI\_Win\_start и MPI\_Win\_complete в остальных процессах.'
);
  for i := 1 to n div 3 do
  begin
    SetProcess(3*(i-1));
    k1 := RandomR(1,9.99);
    k2 := RandomR(1,9.99);
    k3 := RandomR(1,9.99);
//    x1 := 1 + 40 * ((i+1) mod 2);
    DataR3(prcLong(3*(i-1),n-1), k1, k2, k3, 0, i, 5);
    SetProcess(3*(i-1)+1);
    ResultR(prcLong(3*(i-1)+1,n-1), k1, xLeft, i, 5);
    SetProcess(3*(i-1)+2);
    ResultR2(prcLong(3*(i-1)+2,n-1), k2, k3, xRight, i, 5);
  end;

end;

procedure MPIWin21;
var
  i, j, k0, x1, x2, y1, y2: integer;
  c: array[1..20] of real;
begin
  n := 2*RandomN(2,5);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} \= четное число. В главном процессе дан массив {A}'#13#10
+'из {K}/2 вещественных чисел и массив {N} целых чисел того же размера. Все элементы'#13#10
+'массива {N} различны и лежат в диапазоне от 1 до {K}~\-~1. В каждом подчиненном'#13#10
+'процессе определить окно доступа из одного вещественного числа и, используя'#13#10
+'требуемое количество вызовов функции MPI\_Put в главном процессе, переслать'#13#10
+'в каждый из подчиненных процессов ранга {N}_I ({I}~=~0,~\., {K}/2~\-~1) число {A}_I'#13#10
+'и вывести полученное число (в остальных подчиненных процессах вывести'#13#10
+'вещественное число 0.0). Для синхронизации использовать функции MPI\_Win\_post'#13#10
+'и MPI\_Win\_wait в подчиненных процессах и функции MPI\_Win\_start'#13#10
+'и MPI\_Win\_complete в главном процессе.'
);
  for i := 1 to n-1 do
  begin
    a[i] := i;
    c[i] := 0;
  end;
  for i := 1 to 2 * n do
    SwapN(a[RandomN(1, n-1)], a[RandomN(1, n-1)]);

  for i := 1 to n div 2 do
    b[i] := RandomR(1,9.99);

  for i := 1 to n div 2 do
    c[a[i]] := b[i];

  SetProcess(0);
  DataComment(prc(0), 1, 1);
  x1 := 14;
  DataComment('A:', x1, 1);
  for i := 1 to n div 2 do
  begin
    x1 := x1 + 6;
    DataR(b[i], x1, 1, 4);
  end;
  x1 := 14;
  DataComment('N:', x1, 2);
  for i := 1 to n div 2 do
  begin
    x1 := x1 + 6;
    DataN(a[i], x1, 2, 4);
  end;
  for i := 1 to n-1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i+1) mod 2);
    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;
    y1 := (i+1) div 2;
    ResultR(prc(i), c[i], x1, y1, 4);
  end;

end;

procedure MPIWin22;
var
  i, j, x1, x2, y1, y2: integer;
  c: array[1..10,1..10] of real;
begin
  n := RandomN(5,8);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'В главном процессе дан массив {A} вещественных чисел размера {K} ({K} \= количество'#13#10
+'подчиненных процессов) и массив {N} целых чисел размера 8. Все элементы'#13#10
+'массива {N} лежат в диапазоне от 1 до {K}; некоторые элементы данного массива'#13#10
+'могут совпадать. В каждом подчиненном процессе дан вещественный массив {B}'#13#10
+'размера {R}, где {R} \= ранг процесса ({R}~=~1,~\., {K}). Определить в каждом'#13#10
+'подчиненном процессе окно доступа, содержащее массив {B}, и, используя требуемое'#13#10
+'количество вызовов функции MPI\_Accumulate в главном процессе, добавить ко всем'#13#10
+'элементам массивов {B} из процессов ранга {N}_I ({I}~=~0,~\., 7) элементы массива {A}'#13#10
+'с теми же индексами (к элементу {B}_0 добавляется элемент {A}_0, к элементу {B}_1 \='#13#10
+'элемент {A}_1, и~т.\,д.); для некоторых массивов {B} элементы из массива {A} могут'#13#10
+'добавляться несколько раз. В каждом подчиненном процессе вывести массив {B}'#13#10
+'(который либо изменится, либо сохранит исходные значения элементов). Для'#13#10
+'синхронизации использовать функции MPI\_Win\_post и MPI\_Win\_wait в подчиненных'#13#10
+'процессах и функции MPI\_Win\_start и MPI\_Win\_complete в главном процессе.'
);
  for i := 1 to 8 do
  begin
    a[i] := RandomN(1, n-1);
  end;
  for i := 1 to n do
  begin
    b[i] := RandomR(1, 8.99);
  end;
  SetProcess(0);
  x1 := 1;
  DataComment(prc(0), x1, 1);
  x1 := x1 + 6;
  for i := 1 to n-1 do
  begin
    x1 := x1 + 5;
    DataR(b[i], x1, 1, 4);
  end;
  x1 := x1 + 5;
  for i := 1 to 8 do
  begin
    x1 := x1 + 3;
    DataN(a[i], x1, 1, 1);
  end;

  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 38 * ((i+1) mod 2);
    y1 := (i+1) div 2 + 1;
{    if i > 5 then
    begin
      x1 := 1;
      y1 := i-2;
    end;}
    DataComment(prc(i), x1, y1);
    x1 := x1 + 5;
    for j := 1 to i do
    begin
      c[i,j] := RandomR(1,9.99);
      x1 := x1 + 5;
      DataR(c[i,j], x1, y1, 5);
    end;
  end;

  for i := 1 to 8 do
  begin
    for j := 1 to a[i] do
     c[a[i], j] := c[a[i], j] + b[j];
  end;

  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 38 * ((i+1) mod 2);
    y1 := (i+1) div 2 + 1;
    if i > 5 then
    begin
      x1 := 1;
      y1 := i-1;
    end;
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 4;
    for j := 1 to i do
    begin
      x1 := x1 + 6;
      ResultR(c[i,j], x1, y1, 6);
    end;
  end;

end;

procedure MPIWin23;
var
  i, j, x1, x2, y1, y2: integer;
  c: array[1..10,1..10] of real;
  k,m: array[1..10] of integer;
begin
  n := 9;//RandomN(5,9);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Во всех процессах даны вещественные массивы {A} размера 5. Кроме того, в главном'#13#10
+'процессе даны целочисленные массивы {N} и {M} размера 5 каждый. Все элементы'#13#10
+'массива {N} лежат в диапазоне от 1 до {K}, где {K} \= количество подчиненных'#13#10
+'процессов, все элементы массива {M} лежат в диапазоне от 0 до 4; некоторые'#13#10
+'элементы как в массиве {N}, так и в массиве {M} могут совпадать. В каждом'#13#10
+'подчиненном процессе определить окно доступа, содержащее массив {A},'#13#10
+'и, используя требуемое количество вызовов функции MPI\_Get в главном процессе,'#13#10
+'получить из процесса ранга {N}_I ({I}~=~0,~\., 4) элемент массива {A} с индексом {M}_I'#13#10
+'и добавить его значение к элементу массива {A} главного процесса с индексом {I}.'#13#10
+'После изменения массива {A} в главном процессе выполнить следующую корректировку'#13#10
+'массивов {A} всех подчиненных процессов: заменить в них те элементы, которые'#13#10
+'больше элемента массива {A} с тем же индексом из главного процесса, на этот'#13#10
+'элемент, используя требуемое количество вызовов функции MPI\_Accumulate'#13#10
+'в главном процессе. В каждом процессе вывести преобразованные массивы {A}.'#13#10
+'Для синхронизации использовать два вызова пары функции MPI\_Win\_post'#13#10
+'и MPI\_Win\_wait в подчиненных процессах и два вызова пары функции MPI\_Win\_start'#13#10
+'и MPI\_Win\_complete в главном процессе.'
);
  for j := 1 to 5 do
  begin
    m[j] := RandomN(0,4);
    k[j] := RandomN(1,n-1);
  end;
  for j := 1 to n do
  begin
    c[1,j] := RandomR(1, 1.99);
  end;
  for i := 2 to n do
  for j := 1 to n do
    c[i,j] := RandomR(1, 9.99);
  SetProcess(0);
  x1 := 1;
  DataComment(prc(0), x1, 1);
  x1 := x1 + 6;
  for i := 1 to 5 do
  begin
    x1 := x1 + 5;
    DataR(c[1,i], x1, 1, 4);
  end;
  x1 := x1 + 7;
  DataComment('N:', x1, 1);
  x1 := x1 + 2;
  for i := 1 to 5 do
  begin
    x1 := x1 + 2;
    DataN(k[i], x1, 1, 1);
  end;
  x1 := x1 + 4;
  DataComment('M:', x1, 1);
  x1 := x1 + 2;
  for i := 1 to 5 do
  begin
    x1 := x1 + 2;
    DataN(m[i], x1, 1, 1);
  end;

  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 38 * ((i+1) mod 2);
    y1 := (i+1) div 2 + 1;
{    if i > 5 then
    begin
      x1 := 1;
      y1 := i-2;
    end;}
    DataComment(prc(i), x1, y1);
    x1 := x1 + 5;
    for j := 1 to 5 do
    begin
      x1 := x1 + 5;
      DataR(c[i+1,j], x1, y1, 5);
    end;
  end;

{  for i := 1 to 8 do
  begin
    for j := 1 to a[i] do
     c[a[i], j] := c[a[i], j] + b[j];
  end;
}


  for i := 1 to 5 do
    c[1,i] := c[1,i] + c[k[i]+1, m[i]+1];
  for i := 2 to n do
    for j := 1 to 5 do
      if c[1,j] < c[i, j] then
        c[i, j] := c[1,j];




  SetProcess(0);
  x1 := 20;
  ResultComment(prc(0), x1, 1);
  x1 := x1 + 5;
  for i := 1 to 5 do
  begin
    x1 := x1 + 6;
    ResultR(c[1,i], x1, 1, 5);
  end;

  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 38 * ((i+1) mod 2);
    y1 := (i+1) div 2 + 1;
{    if i > 5 then
    begin
      x1 := 1;
      y1 := i-2;
    end;}
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 5;
    for j := 1 to 5 do
    begin
      x1 := x1 + 5;
      ResultR(c[i+1,j], x1, y1, 5);
    end;
  end;


end;

procedure MPIWin24;
var
  i, j, k0, x1, x2, y1, y2: integer;
  c: array[1..10] of integer;
begin
  n := RandomN(5,10);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'В каждом подчиненном процессе дано целое число {N}; все числа {N} различны'#13#10
+'и лежат в диапазоне от 0 до {K}~\-~1, где {K} \= количество подчиненных процессов.'#13#10
+'В главном процессе определить окно доступа, содержащее целочисленный массив {A}'#13#10
+'размера {K}. Не выполняя никаких вызовов синхронизирующих функций в главном'#13#10
+'процессе (кроме вызова функции MPI\_Barrier) и используя в подчиненных'#13#10
+'процессах последовательность вызовов синхронизирующих функции MPI\_Win\_lock,'#13#10
+'MPI\_Win\_unlock, MPI\_Barrier, MPI\_Win\_lock, MPI\_Win\_unlock, записать в элементы'#13#10
+'массива {A} с индексом {N} ранг подчиненного процесса, содержащего данное'#13#10
+'значение {N} (с помощью функции MPI\_Put), после чего получить и вывести в каждом'#13#10
+'подчиненном процессе все элементы преобразованного массива {A} (с помощью'#13#10
+'функции MPI\_Get). В качестве первого параметра функции MPI\_Win\_lock'#13#10
+'указывать MPI\_LOCK\_SHARED.'#13#10
+'\P\SПримечание.\s Синхронизирующие функции MPI\_Win\_lock, MPI\_Win\_unlock используются'#13#10
+'преимущественно при односторонних коммуникациях с \Iпассивными целевыми\i'#13#10
+'\Iпроцессами\i (passive targets), при которых целевой процесс не обрабатывает'#13#10
+'переданные ему данные, а выступает в роли их хранилища,'#13#10
+'доступного для других процессов.'
);
  for i := 1 to n - 1 do
    a[i] := i;
  for i := 1 to 2 * n do
    SwapN(a[RandomN(1, n-1)], a[RandomN(1, n-1)]);
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i+1) mod 2);
    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;
    y1 := (i+1) div 2;
    DataN(prc(i), a[i]-1, x1, y1, 2);
  end;
  for i := 1 to n - 1 do
    c[a[i]] := i;
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i+1) mod 2);
{    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;}
    y1 := (i+1) div 2;
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 8;
    for j := 1 to n-1 do
    begin
      x1 := x1 + 3;
      ResultN(c[j], x1, y1, 2);
    end;
  end;


end;


procedure MPIWin25;
var
  i, j, k, k1, x1, x2, y1, y2: integer;
  c: array[1..10,1..10] of real;
  s: string;
begin
  n := 3*RandomN(3,5);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Количество процессов {K} кратно 3. В процессах ранга 3{N} ({N}~=~0,~\., {K}/3~\-~1)'#13#10
+'дан вещественный массив {A} размера 5, в процессах ранга 3{N}~+~1 дано целое'#13#10
+'число {M}, лежащее в диапазоне от 0 до 4, и вещественное число {B}. В каждом'#13#10
+'процессе, содержащем исходный массив {A}, определить окно доступа с этим'#13#10
+'массивом. Используя функцию MPI\_Accumulate в каждом процессе ранга 3{N}~+~1'#13#10
+'({N}~=~0,~\., {K}/3~\-~1), преобразовать массив {A} из процесса ранга 3{N} следующим'#13#10
+'образом: если элемент массива с индексом {M} больше числа {B}, то он заменяется'#13#10
+'на число {B} (числа {M} и {B} берутся из процесса ранга 3{N}~+~1). После этого,'#13#10
+'используя функцию MPI\_Get в каждом процессе ранга 3{N}~+~2, получить и вывести'#13#10
+'в нем все элементы преобразованного массива {A} из процесса ранга 3{N}.'#13#10
+'Использовать синхронизирующие функции MPI\_Win\_Lock, MPI\_Win\_unlock,'#13#10
+'MPI\_Barrier в процессах ранга 3{N}~+~1, функции MPI\_Barrier, MPI\_Win\_Lock,'#13#10
+'MPI\_Win\_unlock в процессах ранга 3{N}~+~2 и функцию MPI\_Barrier в процессах'#13#10
+'ранга 3{N}. В качестве первого параметра функции MPI\_Win\_lock'#13#10
+'указывать MPI\_LOCK\_EXCLUSIVE.'
);
  k := n div 3;
  for i := 1 to k do
    for j := 1 to 5 do
      c[i,j] := RandomR(1,9.99);
  repeat
  k1 := 0;
  for i := 1 to k do
  begin
    a[i] := RandomN(1,5);
    b[i] := RandomR(1,9.99);
    if c[1,a[i]] > b[i] then
      k1 := k1 + 1;
  end;
  until k1 > 1;
  for i := 1 to k do
  begin
  SetProcess(3*(i-1));
  x1 := 1;
  y1 := i;
  s := prclong(3*(i-1),3*k+2);
  DataComment(s, x1, y1);
  x1 := x1 + 7;
  for j := 1 to 5 do
  begin
    x1 := x1 + 5;
    DataR(c[i,j], x1, y1, 4);
  end;
  SetProcess(3*(i-1)+1);
  x1 := 40;
  s := prclong(3*(i-1)+1,3*k+2);
  DataN(s + ' M = ', a[i]-1, x1, y1, 1);
  x1 := x1 + 19;
  DataR('  B = ', b[i], x1, y1, 4);
  end;

  for i := 1 to k do
  begin
    if c[i,a[i]] > b[i] then
      c[i,a[i]] := b[i];
  end;
  for i := 1 to k do
  begin
  SetProcess(3*(i-1)+2);
  x1 := 1;
  y1 := i;
  ResultComment(prclong(3*(i-1)+2,3*k+2), x1, y1);
  x1 := x1 + 7;
  for j := 1 to 5 do
  begin
    x1 := x1 + 5;
    ResultR(c[i,j], x1, y1, 4);
  end;
  end;



end;


procedure MPIWin26;
var
  i, j, k0, x1, x2, y1, y2: integer;
  c: array[0..10,1..5] of real;
  x, y: real;
begin
  n := RandomN(5,10);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'В каждом подчиненном процессе дан вещественный массив {A} размера 5'#13#10
+'с положительными элементами. В главном процессе определить окно доступа,'#13#10
+'содержащее вещественный массив {B} размера 5 с нулевыми элементами. Не выполняя'#13#10
+'никаких вызовов синхронизирующих функций в главном процессе (кроме вызова'#13#10
+'функции MPI\_Barrier) и используя в подчиненных процессах последовательность'#13#10
+'вызовов синхронизирующих функции MPI\_Win\_lock, MPI\_Win\_unlock, MPI\_Barrier,'#13#10
+'MPI\_Win\_lock, MPI\_Win\_unlock, записать в каждый из элементов массива {B}'#13#10
+'максимальный из элементов массивов {A} с тем же индексом (с помощью функции'#13#10
+'MPI\_Accumulate), после чего получить и вывести в каждом подчиненном процессе'#13#10
+'все элементы преобразованного массива {B} (с помощью функции MPI\_Get).'#13#10
+'В качестве первого параметра функции MPI\_Win\_lock указывать MPI\_LOCK\_SHARED.'
);
  for j := 1 to 5 do
  begin
  c[0,j] := 0;
  for i := 1 to n - 1 do
    c[i,j] := RandomR(1,9.9);
  end;
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i+1) mod 2);
//    if Odd(i) then
//      x1 := xLeft
//    else
//      x1 := xRight;

    y1 := (i+1) div 2;
    DataComment(prc(i), x1, y1);
    x1 := x1 + 6;
    for j := 1 to 5 do
    begin
    x1 := x1 + 5;
    DataR(c[i,j], x1, y1, 5);
    end;
  end;
  for i := 1 to n - 1 do
  for j := 1 to 5 do
    if c[0,j]<c[i,j] then
      c[0,j] := c[i,j];

  for i := 1 to n - 1 do
  begin
    SetProcess(i);
    x1 := 1 + 40 * ((i+1) mod 2);
//    if Odd(i) then
//      x1 := xLeft
//    else
//      x1 := xRight;

    y1 := (i+1) div 2;
    ResultComment(prc(i), x1, y1);
    x1 := x1 + 6;
    for j := 1 to 5 do
    begin
    x1 := x1 + 5;
    ResultR(c[0,j], x1, y1, 5);
    end;
  end;


end;

procedure MPIWin27;
var
  i, j, k0, x1, x2, y1, y2: integer;
  c: array[0..10,1..2] of real;
  x, y: real;
begin
  n := RandomN(5,10);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'В каждом подчиненном процессе даны два вещественных числа {X}, {Y} \= координаты'#13#10
+'точки на плоскости. Используя вызовы функции MPI\_Get в главном процессе,'#13#10
+'получить в нем числа {X}_0, {Y}_0, равные координатам той точки ({X},~{Y}) среди точек,'#13#10
+'данных в подчиненных процессах, которая является наиболее удаленной от начала'#13#10
+'координат. После этого, используя вызовы функции MPI\_Get в подчиненных'#13#10
+'процессах, получить и вывести в каждом из них числа {X}_0, {Y}_0, найденные'#13#10
+'в главном процессе. В каждом процессе определить окно доступа, содержащее'#13#10
+'два вещественных числа ({X}, {Y} для подчиненных процессов, {X}_0, {Y}_0 для главного'#13#10
+'процесса). Использовать синхронизирующие функции MPI\_Win\_lock, MPI\_Win\_unlock,'#13#10
+'MPI\_Barrier в главном процессе и функции MPI\_Barrier, MPI\_Win\_lock,'#13#10
+'MPI\_Win\_unlock в подчиненных процессах.'#13#10
+'\P\SПримечание.\s Данную задачу невозможно решить, используя односторонние'#13#10
+'коммуникации только на стороне подчиненных процессов и при этом выполняя'#13#10
+'синхронизацию с помощью блокировок lock/unlock.'
);
  for j := 1 to 2 do
  begin
  c[0,j] := 0;
  for i := 1 to n - 1 do
    c[i,j] := RandomR(-9.9,9.9);
  end;
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i+1) mod 2);
    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;

    y1 := (i+1) div 2;
    DataR2(prc(i), c[i,1], c[i,2], x1, y1, 6);
  end;
  for i := 1 to n - 1 do
    if sqr(c[0,1])+sqr(c[0,2]) <
       sqr(c[i,1])+sqr(c[i,2]) then
    begin
      c[0,1] := c[i,1];
      c[0,2] := c[i,2];
    end;

  for i := 1 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i+1) mod 2);
    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;

    y1 := (i+1) div 2;
    ResultR2(prc(i), c[0,1], c[0,2], x1, y1, 6);
  end;


end;


procedure MPIWin28;
var
  i, j, k0, x1, x2, y1, y2: integer;
  c: array[0..10,1..2] of real;
  x, y: real;
begin
  n := RandomN(5,10);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Решить задачу \1, используя единственное окно доступа в главном'#13#10
+'процессе, содержащее числа {X}_0, {Y}_0. Для нахождения чисел {X}_0, {Y}_0 использовать'#13#10
+'функцию MPI\_Get и функцию MPI\_Put в подчиненных процессах (для некоторых'#13#10
+'процессов вызывать функцию MPI\_Put не потребуется), для пересылки найденных'#13#10
+'чисел {X}_0, {Y}_0 во все подчиненные процессы использовать в них функцию MPI\_Get'#13#10
+'(как и в задаче \1). Для синхронизации обменов на этапе нахождения'#13#10
+'чисел {X}_0, {Y}_0 использовать два вызова пары функций MPI\_Win\_start'#13#10
+'и MPI\_Win\_complete в подчиненных процессах и вызовы \Iв цикле\i двух пар функций'#13#10
+'MPI\_Win\_post и MPI\_Win\_wait в главном процессе (при этом на каждой итерации'#13#10
+'цикла необходимо определять \Iновую группу процессов\i, используемую при вызове'#13#10
+'функций MPI\_Win\_post). Для синхронизации действий при пересылке'#13#10
+'чисел {X}_0, {Y}_0 в подчиненные процессы использовать, как и в задаче \1,'#13#10
+'функцию MPI\_Barrier в главном процессе и функции MPI\_Barrier, MPI\_Win\_Lock,'#13#10
+'MPI\_Win\_unlock в подчиненных процессах.'#13#10
+'\P\SПримечание.\s Описанный вариант решения (в отличие от варианта, приведенного'#13#10
+'в задаче \1) позволяет использовать односторонние коммуникации только'#13#10
+'на стороне подчиненных процессов, однако при этом на первом этапе решения'#13#10
+'требуется применять вариант синхронизации, отличный от блокировок lock/unlock.'
);
  for j := 1 to 2 do
  begin
  c[0,j] := 0;
  for i := 1 to n - 1 do
    c[i,j] := RandomR(-9.9,9.9);
  end;
  for i := 1 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i+1) mod 2);
    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;

    y1 := (i+1) div 2;
    DataR2(prc(i), c[i,1], c[i,2], x1, y1, 6);
  end;
  for i := 1 to n - 1 do
    if sqr(c[0,1])+sqr(c[0,2]) <
       sqr(c[i,1])+sqr(c[i,2]) then
    begin
      c[0,1] := c[i,1];
      c[0,2] := c[i,2];
    end;

  for i := 1 to n - 1 do
  begin
    SetProcess(i);
//    x1 := 1 + 40 * ((i+1) mod 2);
    if Odd(i) then
      x1 := xLeft
    else
      x1 := xRight;

    y1 := (i+1) div 2;
    ResultR2(prc(i), c[0,1], c[0,2], x1, y1, 6);
  end;


end;

procedure MPIWin29;
var
  i, j, k0, k1, k3, x1, x2, y1, y2: integer;
  c: array[0..10,0..10] of integer;
  x, y: real;
function s(i: integer): integer;
var j: integer;
begin
  result := 0;
  for j := 1 to n do
    result := result + c[i,j];
end;
begin
  n := RandomN(5,8);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'В каждом процессе дана одна строка целочисленной квадратной матрицы порядка {K},'#13#10
+'где {K} \= количество процессов (в процессе ранга {R} дана строка матрицы'#13#10
+'с номером {R}; строки нумеруются от~0). Используя вызовы функции MPI\_Get'#13#10
+'в главном процессе, получить в нем строку матрицы с минимальной суммой'#13#10
+'элементов {S} и, кроме того, найти количество {N} строк с минимальной суммой'#13#10
+'(если {N}~>~1, то в главном процессе надо сохранить последнюю из таких строк,'#13#10
+'т.\,е. строку с наибольшим номером). После этого, используя вызовы функции'#13#10
+'MPI\_Get в подчиненных процессах, получить и вывести в каждом из них строку'#13#10
+'с минимальной суммой {S}, найденную в главном процессе, значение суммы {S}'#13#10
+'и количество {N} строк с минимальной суммой. В каждом процессе определить окно'#13#10
+'доступа, содержащее {K}~+~2 целых числа; в первых {K} элементах окна содержатся'#13#10
+'элементы строки матрицы, в следующем элементе \= сумма их значений {S},'#13#10
+'а последний элемент предназначен для хранения числа~{N}. Использовать'#13#10
+'синхронизирующие функции MPI\_Win\_lock, MPI\_Win\_unlock, MPI\_Barrier в главном'#13#10
+'процессе и функции MPI\_Barrier, MPI\_Win\_lock, MPI\_Win\_unlock'#13#10
+'в подчиненных процессах.'#13#10
+'\P\SПримечание.\s Данную задачу невозможно решить, используя односторонние'#13#10
+'коммуникации только на стороне подчиненных процессов и выполняя синхронизацию'#13#10
+'с помощью блокировок lock/unlock.'
);
  k3 := RandomN(1,5);
  repeat
  for i := 1 to n do
  begin
    for j := 1 to n do
      c[i,j] := RandomN(0,9);
  end;
  for i := 1 to 5 do
  begin
    x1 := RandomN(1,n);
    x2 := RandomN(1,n);
    for j := 1 to n do
      SwapN(c[x1,j],c[x2,j]);
    for j := 1 to 2 * n do
      SwapN(c[x1,RandomN(1, n)], c[x1,RandomN(1, n)]);
  end;
  k0 := n; k1 := 1;
  for i := n-1 downto 1 do // ищем с конца!
    if s(k0) = s(i) then
      k1 := k1 + 1
    else
      if s(k0) > s(i) then
      begin
        k0 := i;
        k1 := 1;
      end;
  until (k1 >= k3) and (s(k0) > 9);

  for i := 1 to n do
  begin
    SetProcess(i-1);
    x1 := 1;
    y1 := i;
    DataComment(prc(i-1), x1, y1);
    x1 := x1 + 6;
    for j := 1 to n do
    begin
      x1 := x1 + 4;
      DataN(c[i,j], x1, y1, 3);
    end;
  end;

  for i := 1 to n do
  begin
    SetProcess(i-1);
    x1 := 1;
    y1 := i;
    ResultComment(prc(i-1), x1, y1);
    x1 := x1 + 6;
    for j := 1 to n do
    begin
      x1 := x1 + 4;
      ResultN(c[k0,j], x1, y1, 3);
    end;
      x1 := x1 + 8;
      ResultN('S = ', s(k0), x1, y1, 2);
      x1 := x1 + 11;
      ResultN('N = ', k1, x1, y1, 1);
  end;


end;


procedure MPIWin30;
var
  i, j, k0, k1, k3, x1, x2, y1, y2: integer;
  c: array[0..10,0..10] of integer;
  x, y: real;
function s(i: integer): integer;
var j: integer;
begin
  result := 0;
  for j := 1 to n do
    result := result + c[i,j];
end;
begin
  n := RandomN(5,8);
  CreateTask(title2, n);
  if n = 0 then exit;
TaskText(
 'Решить задачу \1, используя единственное окно доступа в главном'#13#10
+'процессе, содержащее строку матрицы и числа {S} и {N}. Для нахождения строки'#13#10
+'с минимальной суммой элементов и связанных с ней характеристик использовать'#13#10
+'функцию MPI\_Get и функцию MPI\_Put в подчиненных процессах (для некоторых'#13#10
+'процессов вызывать функцию MPI\_Put не потребуется), для пересылки найденных'#13#10
+'данных во все подчиненные процессы использовать в них функцию MPI\_Get'#13#10
+'(как и в задаче \1). На этапе нахождения строки с минимальной суммой'#13#10
+'функцию MPI\_Get следует использовать только для получения значений {S} и {N}.'#13#10
+'Для синхронизации обменов на этапе нахождения строки с минимальной суммой'#13#10
+'использовать два вызова пары функций MPI\_Win\_start и MPI\_Win\_complete'#13#10
+'в подчиненных процессах и вызовы \Iв цикле\i двух пар функций MPI\_Win\_post'#13#10
+'и MPI\_Win\_wait в главном процессе (при этом на каждой итерации цикла'#13#10
+'необходимо определять \Iновую группу процессов\i, используемую при вызове функций'#13#10
+'MPI\_Win\_post). Для синхронизации действий при пересылке найденных данных'#13#10
+'в подчиненные процессы использовать, как и в задаче \1, функцию'#13#10
+'MPI\_Barrier в главном процессе и функции MPI\_Barrier, MPI\_Win\_Lock,'#13#10
+'MPI\_Win\_unlock в подчиненных процессах.'#13#10
+'\P\SПримечание.\s Описанный вариант решения (в отличие от варианта, приведенного'#13#10
+'в задаче \1) позволяет использовать односторонние коммуникации только'#13#10
+'на стороне подчиненных процессов, однако при этом на первом этапе решения'#13#10
+'требуется применять вариант синхронизации, отличный от блокировок lock/unlock.'
);
  k3 := RandomN(1,5);
  repeat
  for i := 1 to n do
  begin
    for j := 1 to n do
      c[i,j] := RandomN(0,9);
  end;
  for i := 1 to 5 do
  begin
    x1 := RandomN(1,n);
    x2 := RandomN(1,n);
    for j := 1 to n do
      SwapN(c[x1,j],c[x2,j]);
    for j := 1 to 2 * n do
      SwapN(c[x1,RandomN(1, n)], c[x1,RandomN(1, n)]);
  end;
  k0 := n; k1 := 1;
  for i := n-1 downto 1 do // ищем с конца!
    if s(k0) = s(i) then
      k1 := k1 + 1
    else
      if s(k0) > s(i) then
      begin
        k0 := i;
        k1 := 1;
      end;
  until (k1 >= k3) and (s(k0) > 9);

  for i := 1 to n do
  begin
    SetProcess(i-1);
    x1 := 1;
    y1 := i;
    DataComment(prc(i-1), x1, y1);
    x1 := x1 + 6;
    for j := 1 to n do
    begin
      x1 := x1 + 4;
      DataN(c[i,j], x1, y1, 3);
    end;
  end;

  for i := 1 to n do
  begin
    SetProcess(i-1);
    x1 := 1;
    y1 := i;
    ResultComment(prc(i-1), x1, y1);
    x1 := x1 + 6;
    for j := 1 to n do
    begin
      x1 := x1 + 4;
      ResultN(c[k0,j], x1, y1, 3);
    end;
      x1 := x1 + 8;
      ResultN('S = ', s(k0), x1, y1, 2);
      x1 := x1 + 11;
      ResultN('N = ', k1, x1, y1, 1);
  end;


end;

procedure InitTask(num: integer); stdcall;
begin
  case num of
  1: MPIWin1;
  2: MPIWin2;
  3: MPIWin3;
  4: MPIWin4;
  5: MPIWin5;
  6: MPIWin6;
  7: MPIWin7;
  8: MPIWin8;
  9: MPIWin9;
  10: MPIWin10;
  11: MPIWin11;
  12: MPIWin12;
  13: MPIWin13;
  14: MPIWin14;
  15: MPIWin15;
  16: MPIWin16;
  17: MPIWin17;
  18: MPIWin18;
  19: MPIWin19;
  20: MPIWin20;
  21: MPIWin21;
  22: MPIWin22;
  23: MPIWin23;
  24: MPIWin24;
  25: MPIWin25;
  26: MPIWin26;
  27: MPIWin27;
  28: MPIWin28;
  29: MPIWin29;
  30: MPIWin30;

  end;
end;


procedure inittaskgroup;
begin
  if CurrentLanguage and lgCPP = 0 then exit;
  CreateGroup('MPI7Win', 'Односторонние коммуникации (MPI-2)',
    'М. Э. Абрамян, 2017', 'sddwertfghklbfdgfgd', 30, InitTask);
end;

// exports inittaskgroup;  //----------------------------------------

begin
end.
