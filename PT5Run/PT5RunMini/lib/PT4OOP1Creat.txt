[=CS][1]
public abstract class Product
{
    public abstract string GetInfo();
    public abstract void Transform();
}

// Implement the ConcreteProduct1
//   and ConcreteProduct2 descendant classes

public abstract class Creator
{
    protected abstract Product FactoryMethod(string info);
    public string AnOperation(string info)
    {
        Product p = FactoryMethod(info);
        p.Transform();
        p.Transform();
        return p.GetInfo();
    }
}

// Implement the ConcreteCreator1
//   and ConcreteCreator2 descendant classes;
//   the AnOperation method should not be
//   overridden in these classes
[2]
[text]
%{S}Указание (C#).%{s} При определении конструктора класса %{M}ConcreteProduct2%{m}
используйте выражение %{M}: base(info)%{m} после его заголовка (для вызова конструктора предка),
при модификации метода %{M}Transform%{m} класса %{M}ConcreteProduct2%{m} используйте вызов %{M}base.Transform()%{m}.
[code]
public class ConcreteProduct1
{
    protected string info;
    public string GetInfo()
    {
        return info;
    }
    public ConcreteProduct1(string info)
    {
        // Implement the constructor
    }
    public virtual void Transform()
    {
        // Implement the method
    }
}

// Implement the ConcreteProduct2 descendant class

public class ConcreteCreator1
{
    protected virtual ConcreteProduct1 FactoryMethod(string info)
    {
        return new ConcreteProduct1(info);
    }
    public string AnOperation(string info)
    {
        ConcreteProduct1 p = FactoryMethod(info);
        p.Transform();
        p.Transform();
        return p.GetInfo();
    }
}

// Implement the ConcreteCreator2 descendant class
[3]
public abstract class Animal
{
    public abstract string GetInfo();
}

public class Lion : Animal
{
    string name;
    public Lion(string name)
    {
        this.name = name;
    }
    public override string GetInfo()
    {
        return "Lion " + name;
    }
}

// Implement the Tiger, Leopard, Gorilla,
//   Orangutan and Chimpanzee descendant classes

public abstract class AnimalCreator
{
    protected abstract Animal CreateAnimal(int ind, string name);
    public Animal[] GetZoo(int[] inds, string[] names)
    {
        Animal[] zoo = new Animal[inds.Length];
        for (int i = 0; i < zoo.Length; i++)
            zoo[i] = CreateAnimal(inds[i], names[i]);
        return zoo;
    }
}

// Implement the CatCreator and ApeCreator descendant classes
[4]
public abstract class AbstractProductA
{
    public abstract void A();
    public abstract string GetInfo();
}

// Implement the ProductA1 and ProductA2 descendant classes

public abstract class AbstractProductB
{
    public abstract void B(AbstractProductA objA);
    public abstract string GetInfo();
}

// Implement the ProductB1 and ProductB2 descendant classes

public abstract class AbstractFactory
{
    public abstract AbstractProductA CreateProductA(int info);
    public abstract AbstractProductB CreateProductB(int info);
}

// Implement the ConcreteFactory1
//   and ConcreteFactory2 descendant classes
[5]
public abstract class AbstractButton
{
    public abstract string GetControl();
}

// Implement the Button1 and Button2 descendant classes

public abstract class AbstractLabel
{
    public abstract string GetControl();
}

// Implement the Label1 and Label2 descendant classes

public abstract class ControlFactory
{
    public abstract AbstractButton CreateButton(string text);
    public abstract AbstractLabel CreateLabel(string text);
}

// Implement the Factory1 and Factory2 descendant classes

public class Client
{
    // Add required fields
    public Client(ControlFactory f)
    {
        // Implement the constructor
    }
    public void AddButton(string text)
    {
        // Implement the method
    }
    public void AddLabel(string text)
    {
        // Implement the method
    }
    public string GetControls()
    {
        return "";
        // Remove the previous statement and implement the method
    }
}
[6]
[text]
%{S}Указание (C#).%{s} Для языка C# задачник Programming Taskbook выполняет тестирование
при %{I}однократном%{i} запуске программы путем %{I}многократного%{i} вызова
ее функции %{M}Solve%{m}. Так как между вызовами функции %{M}Solve%{m} содержимое
статических полей классов сохраняется, в%~случае данного задания
это приведет к%~ошибочным результатам, начиная со %{I}второго%{i} тестового
испытания. Чтобы избежать сообщения об ошибке, следует реализовать
в%~классах %{M}Singleton%{m}, %{M}Doubleton%{m} и%~%{M}Tenton%{m} вспомогательный статический
метод %{M}Reset%{m}, который обнуляет все статические ссылки (%{M}uniqueInstance%{m}
для класса %{M}Singleton%{m}, элементы массива %{M}instances%{m} для классов %{M}Doubleton%{m}
и%~%{M}Tenton%{m}), и%~вызывать методы %{M}Reset%{m} для этих классов после вывода
всех результирующих данных.

%{S}Примечание (C#).%{s} В языке C# для описания %{I}статических членов класса%{i} (полей и%~методов)
используется модификатор %{M}static%{m}; при этом поля обычно делаются закрытыми (private), а%~методы открытыми (public).
При описании статических полей (как и%~обычных) можно сразу задавать их начальные значения.
Класс может содержать особый статический конструктор (без параметров), который вызывается автоматически.
При вызове статических методов перед ними надо указывать не имя какого-либо объекта, а%~имя класса,
которое отделяется от имени метода точкой.
[code]
public abstract class BaseClass
{
    int data;
    public void IncData(int increment)
    {
        data += increment;
    }
    public int GetData()
    {
        return data;
    }
}

public class Singleton : BaseClass
{
    static Singleton uniqueInstance;
    Singleton() {}
    public static void Reset()
    {
        uniqueInstance = null;
    }
    // Complete the implementation of the class
}

public class Doubleton : BaseClass
{
    static Doubleton[] instances = new Doubleton[2];
    Doubleton() {}
    public static void Reset()
    {
        instances[0] = instances[1] = null;
    }
    // Complete the implementation of the class
}

public class Tenton : BaseClass
{
    static Tenton[] instances = new Tenton[10];
    Tenton() {}
    public static void Reset()
    {
        for (int i = 0; i < instances.Length; i++)
            instances[i] = null;
    }
    // Complete the implementation of the class
}
[7]
public abstract class Prototype
{
    public abstract Prototype Clone();
    public abstract void ChangeId(int id);
    public abstract string GetInfo();
}

// Implement the ConcretePrototype1
//   and ConcretePrototype2 descendant classes

public class Client
{
    // Add required fields
    public Client(Prototype p)
    {
        // Implement the constructor
    }
    public void Operation(int id)
    {
        // Implement the method
    }
    public string GetObjects()
    {
        return "";
        // Remove the previous statement and implement the method
    }
}
[8]
public abstract class AbstractGraphic
{
    public abstract AbstractGraphic Clone();
    public abstract void ChangeLocation(int x1, int y1,
        int x2, int y2);
    public abstract string Draw();
}

// Implement the Ellip, Line and Rect descendant classes

public class GraphEditor
{
    // Add required fields
    public GraphEditor(AbstractGraphic p0, AbstractGraphic p1)
    {
        // Implement the constructor
    }
    public void AddGraphic(int ind, int x1, int y1, int x2, int y2)
    {
        // Implement the method
    }
    public string DrawAll()
    {
        return "";
        // Remove the previous statement and implement the method
    }
}
[9]
public abstract class Builder
{
    public virtual void BuildStart() {}
    public virtual void BuildPartA() {}
    public virtual void BuildPartB() {}
    public virtual void BuildPartC() {}
    public abstract string GetResult();
}

// Implement the ConcreteBuilder1
//   and ConcreteBuilder2 descendant classes

public class Director
{
    Builder b;
    public Director(Builder b)
    {
        this.b = b;
    }
    public string GetResult()
    {
        return b.GetResult();
    }
    public void Construct(string templat)
    {
        // Implement the method
    }
}
[10]
public abstract class Builder
{
    public virtual void BuildStart(char c) {}
    public virtual void BuildFirstChar(char c) {}
    public virtual void BuildNextChar(char c) {}
    public virtual void BuildDelim() {}
    public abstract string GetResult();
}

// Implement the BuilderPascal, BuilderPyhton
//   and BuilderC descendant classes

public class Director
{
    Builder b;
    public Director(Builder b)
    {
        this.b = b;
    }
    public string GetResult()
    {
        return b.GetResult();
    }
    public void Construct(string templat)
    {
        b.BuildStart(templat[0]);
        // Complete the implementation of the method
    }
}
[1-10]
[-WH]

public static void Solve()
{
    Task("%{task}");

}
[+WH]
[=CPP]
[0]
[<]
[text]
В%~заготовки включены описания деструкторов, выводящих имена классов
в%~раздел отладки. Это позволяет проверить правильность действий
по освобождению памяти для объектов, которые используются в%~программе.
[code]
[>]
#include <vector>
#include <memory>
[1]
class Product
{
public:
    virtual string GetInfo() = 0;
    virtual void Transform() = 0;
    virtual ~Product()
    {
        Show("Product");
    }
};

// Implement the ConcreteProduct1
//   and ConcreteProduct2 descendant classes

class Creator
{
protected:
    virtual shared_ptr<Product> FactoryMethod(string info) = 0;
public:
    string AnOperation(string info);
    virtual ~Creator()
    {
        Show("Creator");
    }
};

string Creator::AnOperation(string info)
{
    auto p = FactoryMethod(info);
    p->Transform();
    p->Transform();
    return p->GetInfo();
}

// Implement the ConcreteCreator1
//   and ConcreteCreator2 descendant classes;
//   the AnOperation method should not be
//   overridden in these classes
[2]
[text]
%{S}Указание (C++).%{s}
При определении конструктора класса %{M}ConcreteProduct2%{m} используйте выражение %{M}: ConcreteProduct1(info)%{m}
после его заголовка (для вызова конструктора предка),
при модификации метода %{M}Transform%{m} класса %{M}ConcreteProduct2%{m} используйте вызов
%{M}ConcreteProduct1::Transform()%{m}.
[code]
class ConcreteProduct1
{
protected:
    string info;
public:
    string GetInfo()
    {
        return info;
    }
    ConcreteProduct1(string info);
    virtual void Transform();
    virtual ~ConcreteProduct1()
    {
        Show("ConcreteProduct1");
    }
};

ConcreteProduct1::ConcreteProduct1(string info)
{
    // Implement the constructor
}
void ConcreteProduct1::Transform()
{
    // Implement the method
}

// Implement the ConcreteProduct2 descendant class

class ConcreteCreator1
{
protected:
    virtual shared_ptr<ConcreteProduct1> FactoryMethod(string info)
    {
        return make_shared<ConcreteProduct1>(info);
    }
public:
    string AnOperation(string info);
    virtual ~ConcreteCreator1()
    {
        Show("ConcreteCreator1");
    }
};

string ConcreteCreator1::AnOperation(string info)
{
    auto p = FactoryMethod(info);
    p->Transform();
    p->Transform();
    string s = p->GetInfo();
    delete p;
    return s;
}

// Implement the ConcreteCreator2 descendant class
[3]
class Animal
{
public:
    virtual string GetInfo() = 0;
    virtual ~Animal()
    {
        Show("Animal");
    }
};

class Lion : public Animal
{
    string name;
public:
    Lion(string name) : name(name) {}
    string GetInfo()
    {
        return "Lion " + name;
    }
};

// Implement the Tiger, Leopard, Gorilla,
//   Orangutan and Chimpanzee descendant classes

class AnimalCreator
{
protected:
    virtual shared_ptr<Animal> CreateAnimal(int ind,
        string name) = 0;
public:
    vector<shared_ptr<Animal>> GetZoo(vector<int> inds,
        vector<string> names);
    virtual ~AnimalCreator()
    {
        Show("AnimalCreator");
    }
};

vector<shared_ptr<Animal>> AnimalCreator::GetZoo(vector<int> inds,
    vector<string> names)
{
    vector<shared_ptr<Animal>> zoo;
    for (int i = 0; i < inds.size(); i++)
        zoo.push_back(CreateAnimal(inds[i], names[i]));
    return zoo;
}

// Implement the CatCreator and ApeCreator descendant classes
[4]
class AbstractProductA
{
public:
    virtual void A() = 0;
    virtual string GetInfo() = 0;
    virtual ~AbstractProductA()
    {
        Show("AbstractProductA");
    }
};

// Implement the ProductA1 and ProductA2 descendant classes

class AbstractProductB
{
public:
    virtual void B(const AbstractProductA& objA) = 0;
    virtual string GetInfo() = 0;
    virtual ~AbstractProductB()
    {
        Show("AbstractProductB");
    }
};

// Implement the ProductB1 and ProductB2 descendant classes

class AbstractFactory
{
public:
    virtual shared_ptr<AbstractProductA> CreateProductA(int info)
        = 0;
    virtual shared_ptr<AbstractProductB> CreateProductB(int info)
        = 0;
    virtual ~AbstractFactory()
    {
        Show("AbstractFactory");
    }
};

// Implement the ConcreteFactory1
//   and ConcreteFactory2 descendant classes
[5]
class AbstractButton
{
public:
    virtual string GetControl() = 0;
    virtual ~AbstractButton()
    {
        Show("AbstractButton");
    }
};

// Implement the Button1 and Button2 descendant classes

class AbstractLabel
{
public:
    virtual string GetControl() = 0;
    virtual ~AbstractLabel()
    {
        Show("AbstractLabel");
    }
};

// Implement the Label1 and Label2 descendant classes

class ControlFactory
{
public:
    virtual shared_ptr<AbstractButton> CreateButton(string text)
        = 0;
    virtual shared_ptr<AbstractLabel> CreateLabel(string text) = 0;
    virtual ~ControlFactory()
    {
        Show("ControlFactory");
    }
};

// Implement the Factory1 and Factory2 descendant classes

class Client
{
    // Add required fields
public:
    Client(shared_ptr<ControlFactory> f);
    void AddButton(string text);
    void AddLabel(string text);
    string GetControls();
    ~Client()
    {
        Show("Client");
    }
};

Client::Client(shared_ptr<ControlFactory> f)
{
    // Implement the constructor
}
void Client::AddButton(string text)
{
    // Implement the method
}
void Client::AddLabel(string text)
{
    // Implement the method
}
string Client::GetControls()
{
    return "";
    // Remove the previous statement and implement the method
}
[6]
[text]
%{S}Примечание 1 (C++).%{s} В языке C++ для описания %{I}статических членов класса%{i} (полей и%~методов)
используется модификатор %{M}static%{m}; при этом поля обычно делаются закрытыми (private), а%~методы открытыми (public).
Определение начальных значений статических полей выполняется после определения класса,
причем перед именем поля надо указать имя класса, отделив его от имени поля символами %{M}::%{m}
(аналогично определяются и%~методы). При определении полей и%~методов модификатор %{M}static%{m} уже не указывается.
При вызове статических методов перед ними можно указывать имя объекта, но обычно вместо этого указывается имя класса,
которое отделяется от имени метода символами%~%{M}::%{m}.

%{S}Примечание 2 (C++).%{s} При реализации класса %{M}Singleton%{m} (и%~аналогичных ему) в%~языке С++
необходимо объявить закрытым не только конструктор,
но%~и%~%{I}деструктор%{i} класса. Это, в%~частности, не%~позволит
внешней программе применить операцию %{M}delete%{m} к%~возвращенному
результату функции %{M}Instance%{m} (и%~тем самым разрушить статический
объект %{M}uniqueInstance%{m}). Кроме того, наличие закрытого
деструктора делает невозможным %{I}копирование%{i} объекта (и%~тем самым
создание еще одного его экземпляра).

%{S}Примечание 3 (C++).%{s} Наличие в%~классе закрытых конструктора и%~деструктора не позволяет использовать
%<<умные%>> указатели %{M}shared_ptr%{m} для объектов этого класса, поэтому в данном задании
следует применять обычные указатели и%~операции %{M}new%{m}%--%{M}delete%{m}.
[code]
class BaseClass
{
    int data = 0;
public:
    void IncData(int increment);
    int GetData();
};

void BaseClass::IncData(int increment)
{
    data += increment;
}
int BaseClass::GetData()
{
    return data;
}

class Singleton : public BaseClass
{
    static Singleton* uniqueInstance;
    Singleton() {}
    ~Singleton() 
    {
        Show("Singleton");
    }
public:
    // Complete the implementation of the class
};

Singleton* Singleton::uniqueInstance = nullptr;

class Doubleton : public BaseClass
{
    static Doubleton* instances[];
    Doubleton() {}
    ~Doubleton() 
    {
        Show("Doubleton");
    }
public:
    // Complete the implementation of the class
};

Doubleton* Doubleton::instances[2];

class Tenton : public BaseClass
{
    static Tenton* instances[];
    Tenton() {}
    ~Tenton() 
    {
        Show("Tenton");
    }
public:
    // Complete the implementation of the class
};

Tenton* Tenton::instances[10];
[7]
class Prototype
{
public:
    virtual shared_ptr<Prototype> Clone() = 0;
    virtual void ChangeId(int id) = 0;
    virtual string GetInfo() = 0;
    virtual ~Prototype()
    {
        Show("Prototype");
    }
};

// Implement the ConcretePrototype1
//   and ConcretePrototype2 descendant classes

class Client
{
    // Add required fields
public:
    Client(shared_ptr<Prototype> p);
    void Operation(int id);
    string GetObjects();
    ~Client()
    {
        Show("Client");
    }
};

Client::Client(shared_ptr<Prototype> p)
{
    // Implement the constructor
}
void Client::Operation(int id)
{
    // Implement the method
}
string Client::GetObjects()
{
    return "";
    // Remove the previous statement and implement the method
}
[8]
class AbstractGraphic
{
public:
    virtual shared_ptr<AbstractGraphic> Clone() = 0;
    virtual void ChangeLocation(int x1, int y1, int x2,
        int y2) = 0;
    virtual string Draw() = 0;
    virtual ~AbstractGraphic()
    {
        Show("AbstractGraphic");
    }
};

// Implement the Ellip, Line and Rect descendant classes

class GraphEditor
{
    // Add required fields
public:
    GraphEditor(shared_ptr<AbstractGraphic> p0,
        shared_ptr<AbstractGraphic> p1);
    void AddGraphic(int ind, int x1, int y1, int x2, int y2);
    string DrawAll();
    ~GraphEditor()
    {
        Show("GraphEditor");
    }
};

GraphEditor::GraphEditor(shared_ptr<AbstractGraphic> p0,
    shared_ptr<AbstractGraphic> p1)
{
    // Implement the constructor
}
void GraphEditor::AddGraphic(int ind, int x1, int y1,
    int x2, int y2)
{
    // Implement the method
}
string GraphEditor::DrawAll()
{
    return "";
    // Remove the previous statement and implement the method
};
[9]
class Builder
{
public:
    virtual void BuildStart() {}
    virtual void BuildPartA() {}
    virtual void BuildPartB() {}
    virtual void BuildPartC() {}
    virtual string GetResult() = 0;
    virtual ~Builder()
    {
        Show("Builder");
    }
};

// Implement the ConcreteBuilder1
//   and ConcreteBuilder2 descendant classes

class Director
{
    shared_ptr<Builder> b;
public:
    Director(shared_ptr<Builder> b);
    string GetResult();
    void Construct(string templat);
    ~Director()
    {
        Show("Director");
    }
};

Director::Director(shared_ptr<Builder> b) : b(b) {}
string Director::GetResult()
{
    return b->GetResult();
}
void Director::Construct(string templat)
{
    // Implement the method
}
[10]
class Builder
{
public:
    virtual void BuildStart(char c) {}
    virtual void BuildFirstChar(char c) {}
    virtual void BuildNextChar(char c) {}
    virtual void BuildDelim() {}
    virtual string GetResult() = 0;
    virtual ~Builder()
    {
        Show("Builder");
    }
};

// Implement the BuilderPascal, BuilderPyhton
//   and BuilderC descendant classes

class Director
{
    shared_ptr<Builder> b;
public:
    Director(shared_ptr<Builder> b);
    string GetResult();
    void Construct(string templat);
    ~Director()
    {
        Show("Director");
    }
};

Director::Director(shared_ptr<Builder> b) : b(b) {}
string Director::GetResult()
{
    return b->GetResult();
}
void Director::Construct(string templat)
{
    b->BuildStart(templat[0]);
    // Complete the implementation of the method
}
[1-10]
[-WH]

void Solve()
{
    Task("%{task}");

}
[+WH]
[=JAVA]
[0]

import java.util.ArrayList;

[1]
abstract class Product {
    public abstract String getInfo();
    public abstract void transform();
}

// Implement the ConcreteProduct1
//   and ConcreteProduct2 descendant classes

abstract class Creator {
    protected abstract Product factoryMethod(String info);

    public String anOperation(String info) {
        Product p = factoryMethod(info);
        p.transform();
        p.transform();
        String s = p.getInfo();
        return s;
    }
}

// Implement the ConcreteCreator1
//   and ConcreteCreator2 descendant classes;
//   the anOperation method should not be
//   overridden in these classes
[2]
[text]
%{S}Указание (Java).%{s}
При определении конструктора класса %{M}ConcreteProduct2%{m} используйте выражение %{M}: super(info)%{m}
после его заголовка (для вызова конструктора предка),
при модификации метода %{M}transform%{m} класса %{M}ConcreteProduct2%{m} используйте вызов %{M}super.transform()%{m}.
[code]
class ConcreteProduct1 {
    protected String info;

    public ConcreteProduct1(String info) {
        // Implement the constructor
    }

    public String getInfo() {
        return info;
    }

    public void transform() {
        // Implement the method
    }
}

// Implement the ConcreteProduct2 descendant class

class ConcreteCreator1 {
    protected ConcreteProduct1 factoryMethod(String info) {
        return new ConcreteProduct1(info);
    }

    public String anOperation(String info) {
        ConcreteProduct1 p = factoryMethod(info);
        p.transform();
        p.transform();
        String s = p.getInfo();
        return s;
    }
}

// Implement the ConcreteCreator2 descendant class
[3]
import java.util.ArrayList;
abstract class Animal {
    public abstract String getInfo();
}

class Lion extends Animal {
    String name;
    public Lion(String name) {
        this.name = name;
    }
    public String getInfo() {
        return "Lion " + name;
    }
}

// Implement the Tiger, Leopard, Gorilla,
//   Orangutan and Chimpanzee descendant classes

abstract class AnimalCreator {
    protected abstract Animal createAnimal(int ind, String name);
    public ArrayList<Animal> getZoo(int[] inds, String[] names) {
        ArrayList<Animal> zoo = new ArrayList<Animal>();
        for (int i = 0; i < inds.length; i++)
            zoo.add(createAnimal(inds[i], names[i]));
        return zoo;
    }
}

// Implement the CatCreator and ApeCreator descendant classes
[4]
abstract class AbstractProductA {
    public abstract void A();
    public abstract String getInfo();
}

// Implement the ProductA1 and ProductA2 descendant classes

abstract class AbstractProductB {
    public abstract void B(AbstractProductA objA);
    public abstract String getInfo();
}

// Implement the ProductB1 and ProductB2 descendant classes

abstract class AbstractFactory {
    public abstract AbstractProductA createProductA(int info);
    public abstract AbstractProductB createProductB(int info);
}

// Implement the ConcreteFactory1
//   and ConcreteFactory2 descendant classes
[5]
abstract class AbstractButton {
    public abstract String getControl();
}

// Implement the Button1 and Button2 descendant classes

abstract class AbstractLabel {
    public abstract String getControl();
}

// Implement the Label1 and Label2 descendant classes

abstract class ControlFactory {
    public abstract AbstractButton createButton(String text);
    public abstract AbstractLabel createLabel(String text);
}

// Implement the Factory1 and Factory2 descendant classes

class Client {
    // Add required fields

    Client(ControlFactory f) {
        // Implement the constructor
    }

    public void addButton(String text) {
        // Implement the method
    }

    public void addLabel(String text) {
        // Implement the method
    }

    public String getControls() {
        return "";
        // Remove the previous statement and implement the method
    }
}
[6]
[text]
%{S}Указание (Java).%{s} Для языка Java задачник Programming Taskbook выполняет тестирование
при %{I}однократном%{i} запуске программы путем %{I}многократного%{i} вызова
ее функции %{M}solve%{m}. Так как между вызовами функции %{M}solve%{m} содержимое
статических полей классов сохраняется, в%~случае данного задания
это приведет к%~ошибочным результатам, начиная со %{I}второго%{i} тестового
испытания. Чтобы избежать сообщения об ошибке, следует реализовать
в%~классах %{M}Singleton%{m}, %{M}Doubleton%{m} и%~%{M}Tenton%{m} вспомогательный статический
метод %{M}reset%{m}, который обнуляет все статические ссылки (%{M}uniqueInstance%{m}
для класса %{M}Singleton%{m}, элементы массива %{M}instances%{m} для классов %{M}Doubleton%{m}
и%~%{M}Tenton%{m}), и%~вызывать методы %{M}reset%{m} для этих классов после вывода
всех результирующих данных.

%{S}Примечание (Java).%{s} В языке Java для описания %{I}статических членов класса%{i} (полей и%~методов)
используется модификатор %{M}static%{m}; при этом поля обычно делаются закрытыми (private), а%~методы открытыми (public).
При описании статических полей (как и%~обычных) можно сразу задавать их начальные значения.
При вызове статических методов перед ними можно указывать имя объекта, но можно указывать и%~имя класса,
которое, как и%~имя объекта, отделяется от имени метода точкой.
[code]
class BaseClass {
    private int data = 0;

    public void incData(int increment) {
        this.data += increment;
    }

    public int getData() {
        return data;
    }
}

class Singleton extends BaseClass {
    private static Singleton uniqueInstance = null;

    private Singleton() {}

    // Complete the implementation of the class
}

class Doubleton extends BaseClass {
    private static Doubleton instances[] = new Doubleton[2];

    private Doubleton() {}

    // Complete the implementation of the class
}

class Tenton extends BaseClass {
    private static Tenton instances[] = new Tenton[10];

    private Tenton() {}

    // Complete the implementation of the class
}
[7]
abstract class Prototype extends Cloneable {
    public abstract Prototype clone();
    public abstract void changeId(int id);
    public abstract String getInfo();
}

// Implement the ConcretePrototype1
//   and ConcretePrototype2 descendant classes

class Client {
    // Add required fields

    public Client(Prototype p) {
        // Implement the constructor
    }

    public void operation(int id) {
        // Implement the method
    }

    public String getObjects() {
        return "";
        // Remove the previous statement and implement the method
    }
}
[8]
abstract class AbstractGraphic extends Cloneable {
    public abstract AbstractGraphic clone();
    public abstract void changeLocation(int x1, int y1,
        int x2, int y2);
    public abstract String draw();
}

// Implement the Ellip, Line and Rect descendant classes

class GraphEditor {
    // Add required fields

    public GraphEditor(AbstractGraphic p0, AbstractGraphic p1) {
        // Implement the constructor
    }

    public void addGraphic(int ind, int x1, int y1,
        int x2, int y2) {
        // Implement the method
    }

    public String drawAll() {
        return "";
        // Remove the previous statement and implement the method
    }
}
[9]
abstract class Builder {
    public void buildStart() {}
    public void buildPartA() {}
    public void buildPartB() {}
    public void buildPartC() {}
    public abstract String getResult();
}

// Implement the ConcreteBuilder1
//   and ConcreteBuilder2 descendant classes

class Director {
    private Builder b;

    public Director(Builder b) {
        this.b = b;
    }

    public String getResult() {
        return b.getResult();
    }

    public void construct(String templat) {
        // Implement the method
    }
}
[10]
abstract class Builder {
    public void buildStart(char c) {}
    public void buildFirstChar(char c) {}
    public void buildNextChar(char c) {}
    public void buildDelim() {}
    public abstract String getResult();
}

// Implement the BuilderPascal, BuilderPyhton
//   and BuilderC descendant classes

class Director {
    private Builder b;

    public Director(Builder b) {
        this.b = b;
    }

    public String getResult() {
        return b.getResult();
    }

    public void construct(String templat) {
        b.buildStart(templat.charAt(0));
        // Complete the implementation of the method
    }
}
[1-10]
[-WH]

public class MyTask extends PT
{
    public static void solve() throws Exception
    {
        task("%{task}");

    }
[+WH]
[=RUBY][1]
class ConcreteProduct1
    def initialize(info)
        # Implement the "constructor"
    end

    def getInfo
        # Implement the method
    end

    def transform
        # Implement the method
    end
end

# Implement the ConcreteProduct2 class

class Creator
    def anOperation(info)
        p = factoryMethod(info)
        p.transform
        p.transform
        return p.getInfo
    end
end

class ConcreteCreator1 < Creator
    def factoryMethod(info)
        # Implement the method
    end
end

# Implement the ConcreteCreator2 descendant class;
#   the anOperation method should not be
#   overridden in this class
[2]
[text]
%{S}Указание (Ruby).%{s}
При определении конструктора класса %{M}ConcreteProduct2%{m} используйте выражение %{M}: super%{m}
после его заголовка (для вызова конструктора предка),
при модификации метода %{M}transform%{m} класса %{M}ConcreteProduct2%{m} используйте вызов %{M}super%{m}.
[code]
class ConcreteProduct1
    def initialize(info)
        # Implement the "constructor"
    end

    def getInfo
        # Implement the method
    end

    def transform
        # Implement the method
    end
end
# Implement the ConcreteProduct2 descendant class

class ConcreteCreator1
    def factoryMethod(info)
        return ConcreteProduct1.new(info)
    end

    def anOperation(info)
        p = factoryMethod(info)
        p.transform
        p.transform
        return p.getInfo
    end
end

# Implement the ConcreteCreator2 descendant class
[3]
class Lion
    def initialize(name)
        @name = name
    end

    def getInfo
        return "Lion " + @name
    end
end

# Implement the Tiger, Leopard, Gorilla,
#   Orangutan and Chimpanzee classes

class AnimalCreator
    def getZoo(inds, names)
        zoo = []
        inds.length.times do |i|
            zoo << createAnimal(inds[i], names[i])
        end
        return zoo
    end
end

class CatCreator < AnimalCreator
    def createAnimal(ind, name)
        # Implement the method
    end
end

# Implement the ApeCreator descendant class
[4]
class ProductA1
    def initialize(info)
        # Implement the "constructor"
    end

    def A
        # Implement the method
    end

    def getInfo
        # Implement the method
    end
end

# Implement the ProductA2 class

class ProductB1
    def initialize(info)
        # Implement the "constructor"
    end

    def B(objA)
        # Implement the method
    end

    def getInfo
        # Implement the method
    end
end

# Implement the ProductB2 class

class ConcreteFactory1
    def createProductA(info)
        # Implement the method
    end

    def createProductB(info)
        # Implement the method
    end
end

# Implement the ConcreteFactory2 class
[5]
class Button1
    def initialize(text)
        # Implement the "constructor"
    end

    def getControl
        # Implement the method
    end
end

# Implement the Button2 class

class Label1
    def initialize(text)
        # Implement the "constructor"
    end

    def getControl
        # Implement the method
    end
end

# Implement the Label2 class

class Factory1
    def createButton(text)
        # Implement the method
    end

    def createLabel(text)
        # Implement the method
    end
end

# Implement the Factory2 class

class Client
    def initialize(f)
        # Implement the "constructor"
    end

    def addButton(text)
        # Implement the method
    end

    def addLabel(text)
        # Implement the method
    end

    def getControls
        # Implement the method
    end
end
[6]
[text]
%{S}Указание (Ruby).%{s} Для языка Ruby задачник Programming Taskbook выполняет тестирование
при %{I}однократном%{i} запуске программы путем %{I}многократного%{i} вызова
ее функции %{M}solve%{m}. Так как между вызовами функции %{M}solve%{m} содержимое
статических полей классов сохраняется, в%~случае данного задания
это приведет к%~ошибочным результатам, начиная со %{I}второго%{i} тестового
испытания. Чтобы избежать сообщения об ошибке, следует реализовать
в%~классах %{M}Singleton%{m}, %{M}Doubleton%{m} и%~%{M}Tenton%{m} вспомогательный статический
метод %{M}reset%{m}, который обнуляет все статические ссылки (%{M}uniqueInstance%{m}
для класса %{M}Singleton%{m}, элементы массива %{M}instances%{m} для классов %{M}Doubleton%{m}
и%~%{M}Tenton%{m}), и%~вызывать методы %{M}reset%{m} для этих классов после вывода
всех результирующих данных.

%{S}Примечание (Ruby).%{s} В языке Ruby в%~именах %{I}статических полей%{i} используется особый префикс%~%{M}@@%{m},
а%~при описании %{I}статических методов%{i} перед их именами указывается self и%~точка (например, %{M}self.instanceCount%{m}).
При описании статических полей (как и%~обычных) можно сразу задавать их начальные значения.
При вызове статических методов перед ними надо указывать не имя какого-либо объекта, а имя класса,
которое отделяется от имени метода точкой.
[code]
class BaseClass
    def initialize
        @data = 0
    end

    def incData(increment)
        @data += increment
    end

    def getData
        return @data
    end
end

class Singleton < BaseClass
    @@uniqueInstance = nil

    # Complete the implementation of the class

    private_class_method :new
end

class Doubleton < BaseClass
    @@instances = Array.new(2)

    # Complete the implementation of the class

    private_class_method :new
end

class Tenton < BaseClass
    @@instances = Array.new(10)

    # Complete the implementation of the class

    private_class_method :new
end
[7]
[text]
%{S}Указание (Ruby).%{s} Все классы в языке Ruby имеют встроенную реализацию метода %{M}clone%{m},
поэтому описывать этот метод при решении задачи не требуется: достаточно использовать существующую реализацию.
[code]
class ConcretePrototype1
    def initialize(str)
        # Implement the "constructor"
    end

    def changeId(id)
        # Implement the method
    end

    def getInfo
        # Implement the method
    end
end

# Implement the ConcretePrototype2 class

class Client
    def initialize(p)
        # Implement the "constructor"
    end

    def operation(id)
        # Implement the method
    end

    def getObjects
        # Implement the method
    end
end
[8]
[text]
%{S}Указание (Ruby).%{s} См. указание к заданию %{ref-1}.
[code]
class Ellip
    def initialize
        # Implement the "constructor"
    end

    def changeLocation(x1,y1,x2,y2)
        # Implement the method
    end

    def draw
        # Implement the method
    end
end

# Implement the Line and Rect classes

class GraphEditor
    def initialize(p0,p1)
        # Implement the "constructor"
    end

    def addGraphic(ind,x1,y1,x2,y2)
        # Implement the method
    end

    def drawAll
        # Implement the method
    end
end
[9]
class ConcreteBuilder1
    def initialize
        # Implement the "constructor"
    end

    def buildStart
        # Implement the method
    end

    def buildPartA
        # Implement the method
    end

    def buildPartB
        # Implement the method
    end

    def buildPartC
        # Implement the method
    end

    def getResult
        # Implement the method
    end
end

# Implement the ConcreteBuilder2 class

class Director
    def initialize(b)
        @b = b
    end

    def getResult
        return @b.getResult
    end

    def construct(templat)
        # Implement the method
    end
end
[10]
class BuilderPascal
    def initialize
        # Implement the "constructor"
    end

    def buildStart(c)
        # Implement the method
    end

    def buildFirstChar(c)
        # Implement the method
    end

    def buildNextChar(c)
        # Implement the method
    end

    def buildDelim
        # Implement the method
    end

    def getResult
        # Implement the method
    end
end

# Implement the BuilderPyhton and BuilderC classes

class Director
    def initialize(b)
        @b = b
    end

    def getResult
        return @b.getResult
    end

    def construct(templat)
        @b.buildStart(templat[0])
        # Complete the implementation of the method
    end
end
[1-10]
[-WH]

def solve()
    task "%{task}"

end
[+WH]
[=PYTHON][1]
class ConcreteProduct1:
    def __init__(self, info):
        pass
        # Implement the "constructor"

    def getInfo(self):
        pass
        # Implement the method

    def transform(self):
        pass
        # Implement the method

# Implement the ConcreteProduct2 class

class Creator:
    def anOperation(self, info):
        p = self.factoryMethod(info)
        p.transform()
        p.transform()
        return p.getInfo()

class ConcreteCreator1(Creator):
    def factoryMethod(self, info):
        pass
        # Implement the method

# Implement the ConcreteCreator2 descendant class;
#   the anOperation method should not be
#   overridden in this class
[2]
[text]
%{S}Указание (Python).%{s}
При определении конструктора класса %{M}ConcreteProduct2%{m} используйте выражение %{M}: super().__init__(info)%{m}
после его заголовка (для вызова конструктора предка),
при модификации метода %{M}transform%{m} класса %{M}ConcreteProduct2%{m} используйте вызов %{M}super().transform()%{m}.
[code]
class ConcreteProduct1:
    def __init__(self, info):
        pass
        # Implement the "constructor"

    def getInfo(self):
        pass
        # Implement the method

    def transform(self):
        pass
        # Implement the method

# Implement the ConcreteProduct2 descendant class

class ConcreteCreator1:
    def factoryMethod(self, info):
        return ConcreteProduct1(info)

    def anOperation(self, info):
        p = self.factoryMethod(info)
        p.transform()
        p.transform()
        return p.getInfo()

# Implement the ConcreteCreator2 descendant class
[3]
class Lion:
    def __init__(self, name):
        self.__name = name
    def getInfo(self):
        return "Lion " + self.__name

# Implement the Tiger, Leopard, Gorilla,
#   Orangutan and Chimpanzee classes

class AnimalCreator:
    def getZoo(self, inds, names):
        zoo = []
        for i in range(len(inds)):
            zoo.append(self.createAnimal(inds[i], names[i]))
        return zoo

class CatCreator(AnimalCreator):
    def createAnimal(self, ind, name):
        pass
        # Implement the method

# Implement the ApeCreator descendant class
[4]
class ProductA1:
    def __init__(self, info):
        pass
        # Implement the "constructor"

    def A(self):
        pass
        # Implement the method

    def getInfo(self):
        pass
        # Implement the method

# Implement the ProductA2 class

class ProductB1:
    def __init__(self, info):
        pass
        # Implement the "constructor"

    def B(self, objA):
        pass
        # Implement the method

    def getInfo(self):
        pass
        # Implement the method

# Implement the ProductB2 class

class ConcreteFactory1:
    def createProductA(self, info):
        pass
        # Implement the method

    def createProductB(self, info):
        pass
        # Implement the method

# Implement the ConcreteFactory2 class
[5]
class Button1:
    def __init__(self, text):
        pass
        # Implement the "constructor"

    def getControl(self):
        pass
        # Implement the method

# Implement the Button2 class

class Label1:
    def __init__(self, text):
        pass
        # Implement the "constructor"

    def getControl(self):
        pass
        # Implement the method

# Implement the Label2 class

class Factory1:
    def createButton(self, text):
        pass
        # Implement the method

    def createLabel(self, text):
        pass
        # Implement the method

# Implement the Factory2 class

class Client:
    def __init__(self, f):
        pass
        # Implement the "constructor"

    def addButton(self, text):
        pass
        # Implement the method

    def addLabel(self, text):
        pass
        # Implement the method

    def getControls(self):
        pass
        # Implement the method
[6]
[text]
%{S}Указание (Python).%{s} Для языка Python задачник Programming Taskbook выполняет тестирование
при %{I}однократном%{i} запуске программы путем %{I}многократного%{i} вызова
ее функции %{M}solve%{m}. Так как между вызовами функции %{M}solve%{m} содержимое
статических полей классов сохраняется, в%~случае данного задания
это приведет к%~ошибочным результатам, начиная со %{I}второго%{i} тестового
испытания. Чтобы избежать сообщения об ошибке, следует реализовать
в классах %{M}Singleton%{m}, %{M}Doubleton%{m} и%~%{M}Tenton%{m} вспомогательный статический
метод %{M}reset%{m}, который обнуляет все статические ссылки (%{M}uniqueInstance%{m}
для класса %{M}Singleton%{m}, элементы массива %{M}instances%{m} для классов %{M}Doubleton%{m}
и%~%{M}Tenton%{m}), и%~вызывать методы %{M}reset%{m} для этих классов после вывода
всех результирующих данных.

%{S}Примечание 1 (Python).%{s} В языке Python для определения %{I}статических полей%{i}, т.%~е. полей,
относящихся к%~классу в%~целом, достаточно описать и%~инициализировать эти поля внутри описания класса
(не указывая перед ними слово %{M}self%{m}, в%~отличие от%~обычных полей при доступе к%~ним из обычных методов).
Статические поля, как и%~обычные, можно сделать закрытыми, указав в%~начале их имени два символа подчеркивания.
Что касается методов, то в%~языке Python есть два вида методов, относящихся к%~классу в%~целом: это
собственно %{I}статические методы%{i}, перед определением которых указывается модификатор %{M}@staticmethod%{m},
и%~%{I}классовые методы%{i}, перед определением которых указывается модификатор %{M}@classmethod%{m}.
Статические методы в%~Python %--- это методы, определяемые внутри класса и%~не%~имеющие специальных
параметров. У%~классовых методов первый параметр имеет особый смысл %--- это передаваемый ему класс
(обычно этот параметр имеет имя %{M}cls%{m}). С%~помощью параметра %{M}cls%{m} можно обращаться к%~статическим полям
класса, например, %{M}cls.__static_field%{m}
(подобно тому, как с%~помощью параметра %{M}self%{m} обычных методов можно обращаться к%~полям объекта).
В%~обычных методах тоже можно обращаться к статическим полям; для доступа к%~ним надо использовать параметр %{M}self%{m},
например, %{M}self.__static_field%{m}).
При вызове как статических, так и%~классовых методов перед ними надо указывать не имя какого-либо объекта,
а%~имя класса, которое отделяется от имени метода точкой. При этом для классовых методов указанное имя класса
считается %{I}первым параметром метода%{i} (параметром %{M}cls%{m}).

%{S}Примечание 2 (Python).%{s} Поскольку в%~языке Python нельзя определить закрытый конструктор, необходимо
предусмотреть специальные средства, делающие невозможным вызов конструктора из внешней программы.
Для этого можно поступить следующим образом: определить закрытое статическое поле %{M}__private_key%{m},
которое инициализируется некоторым объектом (недоступным внешней программе),
и%~снабдить метод %{M}__init__%{m} параметром %{M}private_key%{m}.
Вызов конструктора будет считаться успешным только в%~случае, если ему в%~качестве этого параметра
будет передан объект %{M}__private_key%{m},
а%~это может сделать только какой-либо %{I}метод класса%{i}, так как вне класса
доступ к полю %{M}__private_key%{m} невозможен.
[code]
class BaseClass:
    def __init__(self):
        self.__data = 0

    def incData(self, increment):
        self.__data += increment

    def getData(self):
        return self.__data

class Singleton(BaseClass):
    __private_key = object()
    __uniqueInstance = None

    def __init__(self, private_key):
        if private_key != self.__private_key:
            raise Exception("Error")
        super().__init__()

    # Complete the implementation of the class

class Doubleton(BaseClass):
    __private_key = object()
    __instances = [None] * 2

    def __init__(self, private_key):
        if private_key != self.__private_key:
            raise Exception("Error")
        super().__init__()

    # Complete the implementation of the class

class Tenton(BaseClass):
    __private_key = object()
    __instances = [None] * 10

    def __init__(self, private_key):
        if private_key != self.__private_key:
            raise Exception("Error")
        super().__init__()

    # Complete the implementation of the class
[7]
class ConcretePrototype1:
    def __init__(self, str):
        pass
        # Implement the "constructor"

    def clone(self):
        pass
        # Implement the method

    def changeId(self, id):
        pass
        # Implement the method

    def getInfo(self):
        pass
        # Implement the method

# Implement the ConcretePrototype2 class

class Client:
    def __init__(self, p):
        pass
        # Implement the "constructor"

    def operation(self, id):
        pass
        # Implement the method

    def getObjects(self):
        pass
        # Implement the method
[8]
class Ellip:
    def __init__(self):
        pass
        # Implement the "constructor"

    def changeLocation(self, x1, y1, x2, y2):
        pass
        # Implement the method

    def draw(self):
        pass
        # Implement the method

# Implement the Line and Rect classes

class GraphEditor:
    def __init__(self, p0, p1):
        pass
        # Implement the "constructor"

    def addGraphic(self, ind, x1, y1, x2, y2):
        pass
        # Implement the method

    def drawAll(self):
        pass
        # Implement the method
[9]
class ConcreteBuilder1:
    def __init__(self):
        pass
        # Implement the "constructor"

    def buildStart(self):
        pass
        # Implement the method

    def buildPartA(self):
        pass
        # Implement the method

    def buildPartB(self):
        pass
        # Implement the method

    def buildPartC(self):
        pass
        # Implement the method

    def getResult(self):
        pass
        # Implement the method

# Implement the ConcreteBuilder2 class

class Director:
    def __init__(self, b):
        self.__b = b

    def getResult(self):
        return self.__b.getResult()

    def construct(self, templat):
        pass
        # Implement the method
[10]
class BuilderPascal:

    def __init__(self):
        pass
        # Implement the "constructor"

    def buildStart(self, c):
        pass
        # Implement the method

    def buildFirstChar(self, c):
        pass
        # Implement the method

    def buildNextChar(self, c):
        pass
        # Implement the method

    def buildDelim(self):
        pass
        # Implement the method

    def getResult(self):
        pass
        # Implement the method

# Implement the BuilderPyhton and BuilderC classes

class Director:
    def __init__(self, b):
        self.__b = b

    def getResult(self):
        return self.__b.getResult()

    def construct(self, templat):
        self.__b.buildStart(templat[0])
        # Complete the implementation of the method
[1-10]
[-WH]

def solve():
    task("%{task}")
[+WH]

